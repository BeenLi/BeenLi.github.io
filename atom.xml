<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeenLi&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/a560576344d33015bbc0603eeb844702</icon>
  <subtitle>趁还年轻, 多折腾几下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.beenli.com/"/>
  <updated>2020-04-04T12:23:05.201Z</updated>
  <id>http://blog.beenli.com/</id>
  
  <author>
    <name>Wan Li</name>
    <email>wanli.99@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图床+评论</title>
    <link href="http://blog.beenli.com/posts/7928fb24/"/>
    <id>http://blog.beenli.com/posts/7928fb24/</id>
    <published>2020-04-04T10:11:31.000Z</published>
    <updated>2020-04-04T12:23:05.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是图床"><a href="#1、什么是图床" class="headerlink" title="1、什么是图床"></a>1、什么是图床</h2><blockquote><p>图床一般是指储存图片的服务器；就跟百度网盘差不多。只不过它是专门存储图片的。</p><p>有的也可以存储文件。有很多免费的图床。会赠送10G存储空间</p></blockquote><h2 id="2、为什么要用图床"><a href="#2、为什么要用图床" class="headerlink" title="2、为什么要用图床"></a>2、为什么要用图床</h2><ol><li>用图床很方便。服务器会生成一个外链。在互联网任何地方都能访问到</li><li>用图床访问速度很快。服务商会使用cdn加速</li><li>用图床可以节省本地空间。</li></ol><h2 id="3、七牛云图床的使用"><a href="#3、七牛云图床的使用" class="headerlink" title="3、七牛云图床的使用"></a>3、<a href="https://www.qiniu.com" rel="external nofollow noreferrer">七牛云</a>图床的使用</h2><ol><li>注册一个账号（需要身份认证）</li><li>创建一个存储空间</li></ol><center><img src="http://image.beenli.cn/img/20200404/vzoF3Gv83OLc.jpg?imageslim" srcset="/img/loading.gif" alt="mark" style="zoom:50%"></center><ol start="3"><li><p>注意空间名称是唯一。</p><p><code>访问控制</code>：选择私有：别人无法访问。如果是写博客或者公众号还是选择公开吧！</p><p>这样外链别人是可以看得到的。</p></li></ol><center><img src="http://image.beenli.cn/img/20200404/powS6CQubT69.jpg?imageslim" srcset="/img/loading.gif" alt="mark" style="zoom:50%"></center><ol start="4"><li>绑定备案的<code>域名</code></li></ol><p><img src="http://image.beenli.cn/img/20200404/YHkGJVGQk87W.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>​ 可以看到：如果不绑定自己的域名；系统30天后回收回。那么你之前的外链都失效了</p><p>​ 所以最好绑定自己的域名才上线。</p><ol start="5"><li><p>如果你只想试试，那么到这里你就可以结束了。开始体验图床。</p><p><img src="http://image.beenli.cn/img/20200404/uo7Np1Vojilw.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li><li><hr><p>上传完文件，然后返回。你就可以点击<code>操作</code>—&gt;<code>更多</code>—–&gt;<code>复制外链</code></p><p>这时候你就可以直接从浏览器输入这个外链访问到你刚刚上传的文件。</p></li><li><p>这里推荐一个Windows平台<a href="http://mpic.lzhaofu.cn/" rel="external nofollow noreferrer">图床神器</a>；大概长这样。登陆上你之前注册的七牛云账号就可以使用了。</p><p><img src="http://image.beenli.cn/img/20200404/TdnAh5RKQ2V8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><h4 id="用图床上传图片遇到的坑："><a href="#用图床上传图片遇到的坑：" class="headerlink" title="用图床上传图片遇到的坑："></a>用图床上传图片遇到的坑：</h4><ol><li><p>由于七牛云默认生成的外链的是http的，有些浏览器会阻塞这种不安全资源。</p><p>我只好去修改协议。</p></li><li><p>这时遇到第二个坑。要使用https协议，你绑定的域名必须有证书。</p><p>我在网上到处找，买的证书太贵，划不来。免费的证书授权又太慢。</p><p>最后终于找到了一款免费证书ssl发放机构。<a href="https://freessl.cn/" rel="external nofollow noreferrer">freessl</a></p><p>其间要下载一个软件（keymanager)最后生成证书的过程很快几分钟就搞定。</p></li></ol><h2 id="4、Valine评论系统"><a href="#4、Valine评论系统" class="headerlink" title="4、Valine评论系统"></a>4、<a href="https://valine.js.org/" rel="external nofollow noreferrer">Valine</a>评论系统</h2><ol><li><p>hexo的很多主题都内嵌了这个系统，你只需要去<a href="https://www.leancloud.cn/" rel="external nofollow noreferrer">cleancloud</a>注册个账号获取id和key填入配置文件里面就能用</p></li><li><p>如果你想要邮件通知或者后台评论管理可以用这个插件<a href="https://github.com/panjunwen/Valine-Admin" rel="external nofollow noreferrer">Valine-Admin</a></p></li><li><p>项目部署的一定要注意smtp_pass是授权码或者QQ独立密码，不是登陆密码。</p></li><li><p>部署完成效果如下。</p><p><img src="http://image.beenli.cn/img/20200404/2DWW9TYEy7ih.png?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><center><img src="http://image.beenli.cn/img/20200404/CLyDSF8dzvEd.png?imageslim" srcset="/img/loading.gif" alt="mark" style="zoom:50%"></center><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、什么是图床&quot;&gt;&lt;a href=&quot;#1、什么是图床&quot; class=&quot;headerlink&quot; title=&quot;1、什么是图床&quot;&gt;&lt;/a&gt;1、什么是图床&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;图床一般是指储存图片的服务器；就跟百度网盘差不多。只不过它是专门存储图片的。
      
    
    </summary>
    
    
      <category term="Software skills" scheme="http://blog.beenli.com/categories/Software-skills/"/>
    
    
      <category term="Hexo" scheme="http://blog.beenli.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>testbench(1)</title>
    <link href="http://blog.beenli.com/posts/26241a85/"/>
    <id>http://blog.beenli.com/posts/26241a85/</id>
    <published>2020-04-04T02:38:11.000Z</published>
    <updated>2020-04-04T15:41:21.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、testbench的结构"><a href="#1、testbench的结构" class="headerlink" title="1、testbench的结构"></a>1、testbench的结构</h3><p><img src="https://image.beenli.cn/img/20200404/5eSun5gqIQrU.png?imageslim" srcset="/img/loading.gif" alt="testbench"></p><ol><li><p>testbench没有<code>输入输出</code>接口</p></li><li><p>测试模块只负责对<code>待测试系统接口</code>提供<code>激励信号</code>;并监控<code>输出</code></p></li><li><p>testbench代码<code>不需要可综合</code>，即不被实现成电路</p></li><li><p>产生适当的激励并达到<code>覆盖率</code>要求</p><hr></li></ol><h3 id="2、测试激励的描述方式"><a href="#2、测试激励的描述方式" class="headerlink" title="2、测试激励的描述方式"></a>2、测试激励的描述方式</h3><ol><li><p><strong>信号的初始化</strong></p><pre><code class="verilog">第一种: initial 初始化initial a = 0;第二种: 定义信号时初始化reg[3:0] cnt = 4'b1010;</code></pre></li><li><p><strong>延迟控制</strong></p><ol><li><p>延迟语句</p><ul><li><p>外部时间控制</p><pre><code class="verilog">initial #5 a = b;(等待5tick后计算右端的值并赋值给左边👈)等价于:initialbegin    #5;    a=b;end</code></pre></li><li><p>内部时间控制</p><pre><code class="verilog">initial a = #5 b;(先计算右端的值，等待5tick后再把值赋给左边👈)等价于initialbegin    temp = b;    #5;    a = temp;end</code></pre><blockquote><p>验证程序如下：</p></blockquote><center><img src="http://image.beenli.cn/global/20200404/X3hFItEUrx99.jpg?imageslim" srcset="/img/loading.gif" alt="测试" style="zoom:33%"></center><center><img src="http://image.beenli.cn/global/20200404/SJSV1lqyRQJe.jpg?imageslim" srcset="/img/loading.gif" alt="2" style="zoom:33%"></center><p>可以清楚地看到：</p><p>​ 第一种延时语句，在0-5tick之间只要b变化了,那么第五tick</p><p>时刻a被赋予的值就是b第五时刻的值。</p><p>​ 而第二种延时语句：b的值在0时刻已经定好了，不管</p><p>b在这期间怎么变化，a最终得到的是b在0时刻的值。</p></li></ul></li><li><p>事件语句</p><blockquote><p><strong>@(&lt;事件表达式&gt;);</strong></p><p><strong>@(&lt;事件表达式&gt;)行为语句;</strong></p></blockquote><pre><code class="verilog">initialbegin    # 10    @(posedge en) in = ~in; //en的👆上升沿到来时,in取反end</code></pre><p>事件语句<code>@</code>必须等指定事件到来才执行</p></li><li><p>等待语句</p><blockquote><p><strong>wait(&lt;条件表达式&gt;) 行为语句</strong></p></blockquote><pre><code class="verilog">always    #5 cnt=cnt+1'b1;initial    wait(cnt == 4'b1111)     $display($time,,,"cnt = %b", cnt);end</code></pre><p>等待语句只有条件为真时才执行。</p><p><img src="http://image.beenli.cn/global/20200404/xTxXL9tRH35N.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到第0时刻cnt = 0</p><p>第5时刻cnt = 1</p><p>以此类推；直到第75时刻 cnt = 15</p><p>再过10tick 就终止仿真了。总过时常85tick</p></blockquote></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、testbench的结构&quot;&gt;&lt;a href=&quot;#1、testbench的结构&quot; class=&quot;headerlink&quot; title=&quot;1、testbench的结构&quot;&gt;&lt;/a&gt;1、testbench的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://imag
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="http://blog.beenli.com/categories/Digital-IC/"/>
    
    
      <category term="verilog" scheme="http://blog.beenli.com/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>单链表翻转</title>
    <link href="http://blog.beenli.com/posts/39c22857/"/>
    <id>http://blog.beenli.com/posts/39c22857/</id>
    <published>2020-03-31T15:51:58.000Z</published>
    <updated>2020-04-03T12:21:04.484Z</updated>
    
    <content type="html"><![CDATA[<h5 id="单链表翻转"><a href="#单链表翻转" class="headerlink" title="单链表翻转"></a>单链表翻转</h5><h6 id="解法一、拆卸-拼接"><a href="#解法一、拆卸-拼接" class="headerlink" title="解法一、拆卸+拼接"></a><code>解法一</code>、拆卸+拼接</h6><pre><code class="c">struct ListNode *reverseList(struct ListNode* head){    struct ListNOde *newHead = NUll;    struct ListNode *node = NULL;    while (head != NULL) {        //1. 对之前的链表做头删        node = head; // node始终指向head的前驱        head = head-&gt;next;        //2. 对新链表做头插        node-&gt;next = newHead;        newHead = node;    }    return newHead;}</code></pre><a id="more"></a><img src="/assets/photoes/reverse_linked_list.jpg" srcset="/img/loading.gif" style="zoom:80%;"><hr><h6 id="解法二、三指针法"><a href="#解法二、三指针法" class="headerlink" title="解法二、三指针法"></a><code>解法二</code>、三指针法</h6><pre><code class="c">struct ListNode *reverseList(struct ListNode* head) {    if (head == NULL) { // 如果为NULL，那么后指针越界。        return NULL;    }    struct ListNode *p0 = NULL;    struct ListNode *p1 = head;    struct ListNode *p2 = head-&gt;next;    while (p1 != NULL) {        p1-&gt;next = p0;        p0 = p1;         p1 = p2;        if (p2 != NULL) {            p2 = p2-&gt;next;        }    }    return p0;}</code></pre><img src="/assets/photoes/three_pointer.jpg" srcset="/img/loading.gif" style="zoom:80%;"><blockquote><p><a href="https://blog.csdn.net/qq_42351880/article/details/88637387" rel="external nofollow noreferrer">参考博客</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;单链表翻转&quot;&gt;&lt;a href=&quot;#单链表翻转&quot; class=&quot;headerlink&quot; title=&quot;单链表翻转&quot;&gt;&lt;/a&gt;单链表翻转&lt;/h5&gt;&lt;h6 id=&quot;解法一、拆卸-拼接&quot;&gt;&lt;a href=&quot;#解法一、拆卸-拼接&quot; class=&quot;headerlink&quot; title=&quot;解法一、拆卸+拼接&quot;&gt;&lt;/a&gt;&lt;code&gt;解法一&lt;/code&gt;、拆卸+拼接&lt;/h6&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct ListNode *reverseList(struct ListNode* head){
    struct ListNOde *newHead = NUll;
    struct ListNode *node = NULL;
    while (head != NULL) {
        //1. 对之前的链表做头删
        node = head; // node始终指向head的前驱
        head = head-&amp;gt;next;

        //2. 对新链表做头插
        node-&amp;gt;next = newHead;
        newHead = node;
    }
    return newHead;
}&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.beenli.com/categories/Data-Structure/"/>
    
    
      <category term="C" scheme="http://blog.beenli.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>开发工具</title>
    <link href="http://blog.beenli.com/posts/bc753b52/"/>
    <id>http://blog.beenli.com/posts/bc753b52/</id>
    <published>2020-03-31T11:57:08.000Z</published>
    <updated>2020-04-03T12:11:16.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim-iverilog-gtkwave"><a href="#vim-iverilog-gtkwave" class="headerlink" title="vim + iverilog + gtkwave "></a><center>vim + iverilog + gtkwave </center></h1><h3 id="1、What-is-Icarus-Verilog"><a href="#1、What-is-Icarus-Verilog" class="headerlink" title="1、What is Icarus Verilog"></a>1、What is Icarus Verilog</h3><blockquote><p><em>Icarus Verilog</em> is a <strong>Verilog simulation and synthesis</strong> tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called <em>vvp assembly</em>. This intermediate form is executed by the <code>vvp</code>command. For synthesis, the compiler generates netlists in the desired format.<a href="http://iverilog.icarus.com/" rel="external nofollow noreferrer">^iverilog</a></p></blockquote><p>​    从官网的描述我们可以看到: 它是一个<code>仿真器</code>和<code>综合器</code>。</p><p>​    有趣的是：开发者是一名软件工程师</p><p>​    a software engineer specializing in device drivers and embedded systems</p><h3 id="2、Why-we-choose-Icarus-Verilog"><a href="#2、Why-we-choose-Icarus-Verilog" class="headerlink" title="2、Why we choose Icarus Verilog"></a>2、Why we choose Icarus Verilog</h3><ol><li>软件非常小，没有图形界面。跑跑小的程序足够了</li><li>软件扩展性特别好。我现在还没有去探索。<a href="http://iverilog.icarus.com/page/plug-ins" rel="external nofollow noreferrer">详情见</a></li><li>软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的</li></ol><h3 id="3、How-to-use-it"><a href="#3、How-to-use-it" class="headerlink" title="3、How to  use it"></a>3、How to  use it</h3><ol><li><p>像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码</p><p><img src="vim_iverilog.jpg" srcset="/img/loading.gif" alt="Verilog"></p></li><li><p>然后在编辑器里一键运行脚本，或者在终端运行。</p><blockquote><p>终端主要记住几个命令即可: (<a href="">后面很会详细说明</a>)</p></blockquote><pre><code class="c">iverilog -o filename filename.v       // 编译源文件 【-o 指定生成的文件名称】vvp filename                        // 仿真testbenchgtkwave filename.vcd                // 查看仿真的波形图</code></pre></li></ol><h3 id="4、Instance-case"><a href="#4、Instance-case" class="headerlink" title="4、Instance case"></a>4、Instance case</h3><ol><li><blockquote><p>编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)</p></blockquote><pre><code class="verilog">// 模8计数器。存储为count8.vmodule count8(clk, rst_n, cnt);   input clk, rst_n;   output[3:0] cnt;   reg[3:0] cnt;   always @ (posedge clk or negedge rst_n)   begin   if(!rst_n)       cnt &lt;= 4'b0000;   else if(cnt[3])       cnt &lt;=4'b0000;   else       cnt &lt;= cnt + 1'b1;   endendmodule</code></pre></li><li><blockquote><p>编译一下</p></blockquote><pre><code class="bash"> iverilog  -o counter8 counter8.v</code></pre><p>​        <img src="synthesize.png" srcset="/img/loading.gif" alt="image-20200403162524369"></p><p>​    可以看到已经编译成功，生成了<code>count8</code>文件。即上述命令-o后面指定的。</p></li><li><blockquote><p>如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。</p></blockquote><p><img src="RTLviewer.png" srcset="/img/loading.gif" alt="image-20200403163232250"></p></li><li><blockquote><p>编写测试代码</p></blockquote><pre><code class="verilog">`include "count8.v"`timescale 1ns/1nsmodule count8_tb;    // 数据结构声明    reg clk;    reg rst_n;    wire[3:0] cnt;    // 实例化待测试模块    count8 U1(clk, rst_n, cnt);    // 测试激励信号    always    #50 clk = ~ clk;    initial    begin    clk = 1'b0;    rst_n = 1'b0;    #20 rst_n = 1'b0;    #200 rst_n = 1'b1;    end    // 输出响应    initial    begin    wait(cnt == 4'b1000)    $display($time,,,"cnt = %b", cnt);    $dumpfile("count8_tb.vcd");     // 很关键，把仿真的数据存储到文件,待会波形图要用    $dumpvars(0, count8_tb);         // 设置要观察的变量    endendmodule</code></pre></li><li><blockquote><p>编译，仿真，生成波形图</p></blockquote><pre><code class="bash">iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd</code></pre><p><img src="simulate.png" srcset="/img/loading.gif" alt="image-20200403170800780"></p><p>注意:</p><ol><li><p>由于仿真程序没有设定停止时间。程序会一直执行。</p></li><li><p>如果你想自动停止（可以在testbench上加上<code># 500$stop</code>,那么程序仿真500个tick就停止)</p></li><li><p>如果你没有加停止指令。只能手动停止<code>ctrl+c</code>然后你可以打印当前仿真的时间。如果不够</p><p>你可以继续仿真。如果可以了就<code>finish</code></p></li><li><p>最后用<code>gtkwave</code> 查看你刚刚仿真生成的<code>count8_tb.vcd</code>文件。</p></li></ol><p><img src="gtkwave.png" srcset="/img/loading.gif" alt="image-20200403171326769"></p></li><li><blockquote><p>如果你喜欢用<code>modelsim</code>也可以。</p></blockquote><p>也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。</p><p><a href="https://wenku.baidu.com/view/cd93f34ecf84b9d528ea7a95.html" rel="external nofollow noreferrer">具体教程见</a></p><p><img src="modelsim.png" srcset="/img/loading.gif" alt="image-20200403171721915"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim-iverilog-gtkwave&quot;&gt;&lt;a href=&quot;#vim-iverilog-gtkwave&quot; class=&quot;headerlink&quot; title=&quot;vim + iverilog + gtkwave &quot;&gt;&lt;/a&gt;&lt;center&gt;vim + iverilo
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="http://blog.beenli.com/categories/Digital-IC/"/>
    
    
      <category term="verilog" scheme="http://blog.beenli.com/tags/verilog/"/>
    
  </entry>
  
</feed>
