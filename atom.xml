<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeenLi&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/a560576344d33015bbc0603eeb844702</icon>
  <subtitle>趁还年轻, 多折腾几下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.beenli.com/"/>
  <updated>2020-04-04T07:12:28.338Z</updated>
  <id>http://blog.beenli.com/</id>
  
  <author>
    <name>Wan Li</name>
    <email>wanli.99@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>testbench(1)</title>
    <link href="http://blog.beenli.com/posts/26241a85/"/>
    <id>http://blog.beenli.com/posts/26241a85/</id>
    <published>2020-04-04T02:38:11.000Z</published>
    <updated>2020-04-04T07:12:28.338Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="http://blog.beenli.com/categories/Digital-IC/"/>
    
    
      <category term="verilog" scheme="http://blog.beenli.com/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>单链表翻转</title>
    <link href="http://blog.beenli.com/posts/39c22857/"/>
    <id>http://blog.beenli.com/posts/39c22857/</id>
    <published>2020-03-31T15:51:58.000Z</published>
    <updated>2020-04-03T12:21:04.484Z</updated>
    
    <content type="html"><![CDATA[<h5 id="单链表翻转"><a href="#单链表翻转" class="headerlink" title="单链表翻转"></a>单链表翻转</h5><h6 id="解法一、拆卸-拼接"><a href="#解法一、拆卸-拼接" class="headerlink" title="解法一、拆卸+拼接"></a><code>解法一</code>、拆卸+拼接</h6><pre><code class="c">struct ListNode *reverseList(struct ListNode* head){    struct ListNOde *newHead = NUll;    struct ListNode *node = NULL;    while (head != NULL) {        //1. 对之前的链表做头删        node = head; // node始终指向head的前驱        head = head-&gt;next;        //2. 对新链表做头插        node-&gt;next = newHead;        newHead = node;    }    return newHead;}</code></pre><a id="more"></a><img src="/assets/photoes/reverse_linked_list.jpg" srcset="/img/loading.gif" style="zoom:80%;"><hr><h6 id="解法二、三指针法"><a href="#解法二、三指针法" class="headerlink" title="解法二、三指针法"></a><code>解法二</code>、三指针法</h6><pre><code class="c">struct ListNode *reverseList(struct ListNode* head) {    if (head == NULL) { // 如果为NULL，那么后指针越界。        return NULL;    }    struct ListNode *p0 = NULL;    struct ListNode *p1 = head;    struct ListNode *p2 = head-&gt;next;    while (p1 != NULL) {        p1-&gt;next = p0;        p0 = p1;         p1 = p2;        if (p2 != NULL) {            p2 = p2-&gt;next;        }    }    return p0;}</code></pre><img src="/assets/photoes/three_pointer.jpg" srcset="/img/loading.gif" style="zoom:80%;"><blockquote><p><a href="https://blog.csdn.net/qq_42351880/article/details/88637387" rel="external nofollow noreferrer">参考博客</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;单链表翻转&quot;&gt;&lt;a href=&quot;#单链表翻转&quot; class=&quot;headerlink&quot; title=&quot;单链表翻转&quot;&gt;&lt;/a&gt;单链表翻转&lt;/h5&gt;&lt;h6 id=&quot;解法一、拆卸-拼接&quot;&gt;&lt;a href=&quot;#解法一、拆卸-拼接&quot; class=&quot;headerlink&quot; title=&quot;解法一、拆卸+拼接&quot;&gt;&lt;/a&gt;&lt;code&gt;解法一&lt;/code&gt;、拆卸+拼接&lt;/h6&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct ListNode *reverseList(struct ListNode* head){
    struct ListNOde *newHead = NUll;
    struct ListNode *node = NULL;
    while (head != NULL) {
        //1. 对之前的链表做头删
        node = head; // node始终指向head的前驱
        head = head-&amp;gt;next;

        //2. 对新链表做头插
        node-&amp;gt;next = newHead;
        newHead = node;
    }
    return newHead;
}&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.beenli.com/categories/Data-Structure/"/>
    
    
      <category term="C" scheme="http://blog.beenli.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>开发工具</title>
    <link href="http://blog.beenli.com/posts/bc753b52/"/>
    <id>http://blog.beenli.com/posts/bc753b52/</id>
    <published>2020-03-31T11:57:08.000Z</published>
    <updated>2020-04-03T12:11:16.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim-iverilog-gtkwave"><a href="#vim-iverilog-gtkwave" class="headerlink" title="vim + iverilog + gtkwave "></a><center>vim + iverilog + gtkwave </center></h1><h3 id="1、What-is-Icarus-Verilog"><a href="#1、What-is-Icarus-Verilog" class="headerlink" title="1、What is Icarus Verilog"></a>1、What is Icarus Verilog</h3><blockquote><p><em>Icarus Verilog</em> is a <strong>Verilog simulation and synthesis</strong> tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called <em>vvp assembly</em>. This intermediate form is executed by the <code>vvp</code>command. For synthesis, the compiler generates netlists in the desired format.<a href="http://iverilog.icarus.com/" rel="external nofollow noreferrer">^iverilog</a></p></blockquote><p>​    从官网的描述我们可以看到: 它是一个<code>仿真器</code>和<code>综合器</code>。</p><p>​    有趣的是：开发者是一名软件工程师</p><p>​    a software engineer specializing in device drivers and embedded systems</p><h3 id="2、Why-we-choose-Icarus-Verilog"><a href="#2、Why-we-choose-Icarus-Verilog" class="headerlink" title="2、Why we choose Icarus Verilog"></a>2、Why we choose Icarus Verilog</h3><ol><li>软件非常小，没有图形界面。跑跑小的程序足够了</li><li>软件扩展性特别好。我现在还没有去探索。<a href="http://iverilog.icarus.com/page/plug-ins" rel="external nofollow noreferrer">详情见</a></li><li>软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的</li></ol><h3 id="3、How-to-use-it"><a href="#3、How-to-use-it" class="headerlink" title="3、How to  use it"></a>3、How to  use it</h3><ol><li><p>像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码</p><p><img src="vim_iverilog.jpg" srcset="/img/loading.gif" alt="Verilog"></p></li><li><p>然后在编辑器里一键运行脚本，或者在终端运行。</p><blockquote><p>终端主要记住几个命令即可: (<a href="">后面很会详细说明</a>)</p></blockquote><pre><code class="c">iverilog -o filename filename.v       // 编译源文件 【-o 指定生成的文件名称】vvp filename                        // 仿真testbenchgtkwave filename.vcd                // 查看仿真的波形图</code></pre></li></ol><h3 id="4、Instance-case"><a href="#4、Instance-case" class="headerlink" title="4、Instance case"></a>4、Instance case</h3><ol><li><blockquote><p>编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)</p></blockquote><pre><code class="verilog">// 模8计数器。存储为count8.vmodule count8(clk, rst_n, cnt);   input clk, rst_n;   output[3:0] cnt;   reg[3:0] cnt;   always @ (posedge clk or negedge rst_n)   begin   if(!rst_n)       cnt &lt;= 4'b0000;   else if(cnt[3])       cnt &lt;=4'b0000;   else       cnt &lt;= cnt + 1'b1;   endendmodule</code></pre></li><li><blockquote><p>编译一下</p></blockquote><pre><code class="bash"> iverilog  -o counter8 counter8.v</code></pre><p>​        <img src="synthesize.png" srcset="/img/loading.gif" alt="image-20200403162524369"></p><p>​    可以看到已经编译成功，生成了<code>count8</code>文件。即上述命令-o后面指定的。</p></li><li><blockquote><p>如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。</p></blockquote><p><img src="RTLviewer.png" srcset="/img/loading.gif" alt="image-20200403163232250"></p></li><li><blockquote><p>编写测试代码</p></blockquote><pre><code class="verilog">`include "count8.v"`timescale 1ns/1nsmodule count8_tb;    // 数据结构声明    reg clk;    reg rst_n;    wire[3:0] cnt;    // 实例化待测试模块    count8 U1(clk, rst_n, cnt);    // 测试激励信号    always    #50 clk = ~ clk;    initial    begin    clk = 1'b0;    rst_n = 1'b0;    #20 rst_n = 1'b0;    #200 rst_n = 1'b1;    end    // 输出响应    initial    begin    wait(cnt == 4'b1000)    $display($time,,,"cnt = %b", cnt);    $dumpfile("count8_tb.vcd");     // 很关键，把仿真的数据存储到文件,待会波形图要用    $dumpvars(0, count8_tb);         // 设置要观察的变量    endendmodule</code></pre></li><li><blockquote><p>编译，仿真，生成波形图</p></blockquote><pre><code class="bash">iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd</code></pre><p><img src="simulate.png" srcset="/img/loading.gif" alt="image-20200403170800780"></p><p>注意:</p><ol><li><p>由于仿真程序没有设定停止时间。程序会一直执行。</p></li><li><p>如果你想自动停止（可以在testbench上加上<code># 500$stop</code>,那么程序仿真500个tick就停止)</p></li><li><p>如果你没有加停止指令。只能手动停止<code>ctrl+c</code>然后你可以打印当前仿真的时间。如果不够</p><p>你可以继续仿真。如果可以了就<code>finish</code></p></li><li><p>最后用<code>gtkwave</code> 查看你刚刚仿真生成的<code>count8_tb.vcd</code>文件。</p></li></ol><p><img src="gtkwave.png" srcset="/img/loading.gif" alt="image-20200403171326769"></p></li><li><blockquote><p>如果你喜欢用<code>modelsim</code>也可以。</p></blockquote><p>也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。</p><p><a href="https://wenku.baidu.com/view/cd93f34ecf84b9d528ea7a95.html" rel="external nofollow noreferrer">具体教程见</a></p><p><img src="modelsim.png" srcset="/img/loading.gif" alt="image-20200403171721915"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim-iverilog-gtkwave&quot;&gt;&lt;a href=&quot;#vim-iverilog-gtkwave&quot; class=&quot;headerlink&quot; title=&quot;vim + iverilog + gtkwave &quot;&gt;&lt;/a&gt;&lt;center&gt;vim + iverilo
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="http://blog.beenli.com/categories/Digital-IC/"/>
    
    
      <category term="verilog" scheme="http://blog.beenli.com/tags/verilog/"/>
    
  </entry>
  
</feed>
