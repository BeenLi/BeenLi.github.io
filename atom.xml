<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeenLi&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/a560576344d33015bbc0603eeb844702</icon>
  <subtitle>趁还年轻, 多折腾几下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.beenli.cn/"/>
  <updated>2020-08-01T04:27:30.666Z</updated>
  <id>https://www.beenli.cn/</id>
  
  <author>
    <name>Wan Li</name>
    <email>wanli.99@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>riscv-gnu-toolchain 下载、编译</title>
    <link href="https://www.beenli.cn/posts/6c0abcd9/"/>
    <id>https://www.beenli.cn/posts/6c0abcd9/</id>
    <published>2020-08-01T01:23:29.000Z</published>
    <updated>2020-08-01T04:27:30.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p><a href="https://hub.fastgit.org/riscv/riscv-gnu-toolchain" rel="external nofollow noreferrer">riscv-gnu-toolchain</a> 是学习 <code>risc-v</code> 的前提，但是网上对这方面的介绍很少，并且工具链种类繁多，很可能让我们摸不清头脑。</p><h2 id="2、下载篇"><a href="#2、下载篇" class="headerlink" title="2、下载篇"></a>2、下载篇</h2><blockquote><p>由于<code>riscv-gnu-toolchain</code>包含有好多第三方库，整个项目文件很大[官方说的是6.65GB]，加上国内GitHub堪比🐢速，你多半是不可能按官方教程下下来。</p></blockquote><div class="table-container"><table><thead><tr><th>项目名称</th><th>项目描述</th><th>项目用途</th></tr></thead><tbody><tr><td><a href="https://git.qemu.org/git/qemu.git" rel="external nofollow noreferrer">qemu</a></td><td>模拟器（类似bochs,PearPC)</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-binutils-gdb.git" rel="external nofollow noreferrer">riscv-binutils</a></td><td>开发工具(compiler、assemble、linker、debugger…)</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-dejagnu.git" rel="external nofollow noreferrer">riscv-dejagnu</a></td><td>测试其它程序的框架(framework)</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-gcc.git" rel="external nofollow noreferrer">riscv-gcc</a></td><td>GNU Compiler Collection</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-binutils-gdb.git" rel="external nofollow noreferrer">riscv-gdb</a></td><td>同riscv-binutils</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-glibc" rel="external nofollow noreferrer">riscv-glibc</a></td><td>GNU C Library(system-API,其它的语言也通过它访问OS)</td><td></td></tr><tr><td><a href="https://hub.fastgit.org/riscv/riscv-newlib.git" rel="external nofollow noreferrer">riscv-newlib</a></td><td>一套开发工具（用的库有别于riscv-binutils)</td></tr></tbody></table></div><blockquote><p>binutils 和 newlib 之间的区别（坑待填o_o ….）</p></blockquote><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p>PC: x86</p><p>OS: Ubuntu 20.04.1 LTS</p><p>VM: wmware15.5Pro</p><hr><ol><li><p>下载源代码（推荐使用<code>hub.fastgit.org</code>镜像站，比原生站快几百倍）</p><pre><code class="hljs jboss-cli">git clone https:<span class="hljs-string">//hub.fastgit.org/riscv/riscv-gnu-toolchain</span><span class="hljs-keyword">cd</span> riscv-gnu-toolchaingit submodule update <span class="hljs-params">--init</span> <span class="hljs-params">--recursive</span></code></pre></li><li><p>安装依赖（其它系统查看官方readme)</p><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install autoconf automake autotools-<span class="hljs-built_in">dev</span> curl python3 libmpc-<span class="hljs-built_in">dev</span> libmpfr-<span class="hljs-built_in">dev</span> libgmp-<span class="hljs-built_in">dev</span> gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-<span class="hljs-built_in">dev</span> libexpat-<span class="hljs-built_in">dev</span></code></pre></li></ol><h3 id="下载失败解决方案"><a href="#下载失败解决方案" class="headerlink" title="下载失败解决方案"></a>下载失败解决方案</h3><ol><li><p>git clone qemu下载速度太慢导致失败（因为qemu没有把项目托管在GitHub上)</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1xGrafiu4I0yPAnE0iuTYzw" rel="external nofollow noreferrer">https://pan.baidu.com/s/1xGrafiu4I0yPAnE0iuTYzw</a><br>提取码：3iyy</p></blockquote><p>下载源码, 解压到相应的目录上即可。</p></li><li><p>其它模块没有拉下来。</p><p>在源项目下挨个手动克隆。</p><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/riscv/</span>riscv-gnu-toolchaingit clone https:<span class="hljs-regexp">//</span>hub.fastgit.org<span class="hljs-regexp">/riscv/</span>riscv-gcc.git</code></pre></li></ol><h2 id="3、编译篇"><a href="#3、编译篇" class="headerlink" title="3、编译篇"></a>3、编译篇</h2><h3 id="1、Newlib"><a href="#1、Newlib" class="headerlink" title="1、Newlib"></a>1、Newlib</h3><ul><li><p>建立一个安装路径：makdir /opt/riscv</p></li><li><p>配置环境变量：export PATH=$PATH:/opt/riscv/bin(建议写到~/.bashrc上，永久有效</p><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--prefix=/opt/riscv</span>make</code></pre></li></ul><h3 id="2、Linux"><a href="#2、Linux" class="headerlink" title="2、Linux"></a>2、Linux</h3><ul><li>跟上面相同的步骤，不过最好换一个干净的文件夹。</li></ul><ul><li><p>默认是安装RV64GC(64-bit), 即使在32-bit的构建环境中。</p><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--prefix=/opt/riscv</span>make linux</code></pre></li></ul><ul><li><p>Alternatively：（构建32-bit RV32GC)</p><pre><code class="hljs routeros">./configure <span class="hljs-attribute">--prefix</span>=/opt/riscv <span class="hljs-attribute">--with-arch</span>=rv32gc <span class="hljs-attribute">--with-abi</span>=ilp32dmake linux</code></pre></li><li><p>支持的架构有：rv32i、rv64i</p></li><li>标准扩展： (a)tomics, (m)ultiplication and division, (f)loat, (d)ouble, or (g)eneral for MAFD</li><li>支持的ABIs: ilp32 (32-bit soft-float), ilp32d (32-bit hard-float), ilp32f (32-bit with single-precision in registers and double in memory, niche use only), lp64 lp64f lp64d (same but with 64-bit long and pointers).</li></ul><h3 id="3、Linux-multilib"><a href="#3、Linux-multilib" class="headerlink" title="3、Linux multilib"></a>3、Linux multilib</h3><ul><li><p>同时支持32-bit和64-bit的Linux。</p><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--prefix=/opt/riscv</span> <span class="hljs-params">--enable-multilib</span>make linux</code></pre><blockquote><p>编译出来的工具带有前缀：<code>riscv64-unknown-linux-gnu-</code>, 但是能编译32位和64位程序。</p></blockquote></li></ul><h2 id="4、编译结果"><a href="#4、编译结果" class="headerlink" title="4、编译结果"></a>4、编译结果</h2><blockquote><p>经过漫长的等待，我终于编译Linux 64bit版本。</p></blockquote><p><img src="http://image.beenli.cn/img/20200801/kPGRS3PNVC3f.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><img src="http://image.beenli.cn/img/20200801/BoO9SyR2SFa9.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://blog.csdn.net/weiqi7777/article/details/88045720?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param" rel="external nofollow noreferrer">riscv各种版本gcc工具链编译与安装</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hub.fastgit.org/riscv/riscv-gnu-toolchain&quot; re
      
    
    </summary>
    
    
      <category term="RISC-V" scheme="https://www.beenli.cn/categories/RISC-V/"/>
    
    
      <category term="toolchain" scheme="https://www.beenli.cn/tags/toolchain/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook</title>
    <link href="https://www.beenli.cn/posts/2641cf45/"/>
    <id>https://www.beenli.cn/posts/2641cf45/</id>
    <published>2020-07-23T07:13:27.000Z</published>
    <updated>2020-08-05T09:56:56.288Z</updated>
    
    <content type="html"><![CDATA[<center>jupyter notebook</center><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><ul><li>安装python</li><li>安装pip</li><li>（安装ipython）</li><li>安装jupyter notebook(pip install jupyter notebook)</li></ul><h3 id="2、jupyter命令"><a href="#2、jupyter命令" class="headerlink" title="2、jupyter命令"></a>2、jupyter命令</h3><ul><li><p>查看已经安装的核</p><pre><code class="hljs taggerscript">jupyter kernelspec list Available kernels:  py38       C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\w</span>anli<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\j</span>upyter<span class="hljs-symbol">\k</span>ernels<span class="hljs-symbol">\p</span>y38  python3    C:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\j</span>upyter<span class="hljs-symbol">\k</span>ernels<span class="hljs-symbol">\p</span>ython3</code></pre></li><li><p>移除已经安装的核</p><pre><code class="hljs routeros">jupyter kernelspec <span class="hljs-builtin-name">remove</span> [kernelname]</code></pre></li><li><p>安装核</p><pre><code class="hljs brainfuck"><span class="hljs-comment">python</span> <span class="hljs-literal">-</span><span class="hljs-comment">m</span> <span class="hljs-comment">ipykernel</span> <span class="hljs-comment">install</span> <span class="hljs-title">[</span>--<span class="hljs-comment">user</span><span class="hljs-title">]</span> --<span class="hljs-comment">name</span> <span class="hljs-title">[</span><span class="hljs-comment">kernelname</span><span class="hljs-title">]</span></code></pre></li></ul><h3 id="3、conda创建虚拟环境"><a href="#3、conda创建虚拟环境" class="headerlink" title="3、conda创建虚拟环境"></a>3、conda创建虚拟环境</h3><ul><li><p>查看已经有的环境</p><pre><code class="hljs taggerscript">$ conda env list# conda environments:#base                  *  D:<span class="hljs-symbol">\A</span>PP<span class="hljs-symbol">\m</span>inicondapy38                     D:<span class="hljs-symbol">\A</span>PP<span class="hljs-symbol">\m</span>iniconda<span class="hljs-symbol">\e</span>nvs<span class="hljs-symbol">\p</span>y38</code></pre></li><li><p>安装新的环境</p><pre><code class="hljs routeros">conda create -n py36 <span class="hljs-attribute">python</span>=3.6</code></pre></li><li><p>激活环境/推出环境</p><pre><code class="hljs maxima">conda <span class="hljs-built_in">activate</span> envnameconda <span class="hljs-built_in">deactivate</span></code></pre></li></ul><h3 id="4、遇到的问题"><a href="#4、遇到的问题" class="headerlink" title="4、遇到的问题"></a>4、遇到的问题</h3><ol><li><p>jupyter ImportError: DLL load failed: 找不到指定的程序。(kernel error)</p><ul><li><p>where jupyter</p><p>我发现我有两个jupyter, 两个python</p></li><li><p>试过了网上好多办法都不管用(大多叫你添加环境变量)</p></li><li><p>最终我把其中一个jupyter(有问题的)卸载了，用另外一个就好了。</p></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;jupyter notebook&lt;/center&gt;&lt;h3 id=&quot;1、安装&quot;&gt;&lt;a href=&quot;#1、安装&quot; class=&quot;headerlink&quot; title=&quot;1、安装&quot;&gt;&lt;/a&gt;1、安装&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;安装python&lt;/li&gt;&lt;li&gt;安装pip&lt;/
      
    
    </summary>
    
    
      <category term="Software" scheme="https://www.beenli.cn/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>超前进位加法器</title>
    <link href="https://www.beenli.cn/posts/1aa82b80/"/>
    <id>https://www.beenli.cn/posts/1aa82b80/</id>
    <published>2020-04-28T09:31:08.000Z</published>
    <updated>2020-04-28T12:23:42.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、1bit全加器"><a href="#1、1bit全加器" class="headerlink" title="1、1bit全加器"></a>1、1bit全加器</h2><script type="math/tex;mode=display">S = A\oplus B \oplus C_{in}</script><script type="math/tex;mode=display">C_{out} = AB + (A \oplus B)C_{in}</script><p><img src="http://image.beenli.cn/img/20200428/N0IQvruhWdNO.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h2 id="2、4bit行波加法器"><a href="#2、4bit行波加法器" class="headerlink" title="2、4bit行波加法器"></a>2、4bit行波加法器</h2><p><img src="http://image.beenli.cn/img/20200428/MPLTV6H2PHyh.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到要得到最后的进位要经过9个门的延时。</p></blockquote><h2 id="3、4bit超前进位加法器"><a href="#3、4bit超前进位加法器" class="headerlink" title="3、4bit超前进位加法器"></a>3、4bit超前进位加法器</h2><script type="math/tex;mode=display">进位产生信号:g_i = A_iB_i</script><script type="math/tex;mode=display">进位传输信号:p_i = A_i\oplus B_i</script><script type="math/tex;mode=display">则：S_i = p_i \oplus c_i</script><script type="math/tex;mode=display">C_{i+1} = p_ic_i + g_i\quad(c_o = c_{in})</script><p class="note note-primary">判断进位的步骤:</p><ol><li>如果 $g_i$=1 (其他不用看肯定会进位)</li><li>如果 $g_i$=0；看传输信号$p_i$。</li><li>如果 $p_i$=0; 那不用看，已经否决了进位</li><li>如果 $p_i$=1; 那么用同样的方法看下一位是否有进位</li></ol><p></p><p class="note note-primary">判断结果的步骤: 只需把传输信号与进位信号异或。</p><p><img src="http://image.beenli.cn/img/20200428/Lih1DmjLOgFB.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>化简得到：</p><script type="math/tex;mode=display">c_1 = g_0 + p_oc_0(3个门延时)</script><script type="math/tex;mode=display">c_2 = g_1 + g_0p_1 + p_1p_0c_0(3个门延时)</script><script type="math/tex;mode=display">c_3 = g_2 + p_2g_1 + p_2p_1g_0 + p_2p_1p_0c_0(3个延时)</script><script type="math/tex;mode=display">c_4 = g_3 + p_3g_2 + p_3p_2g_1 + p_3p_2p_1g_0 + p_3p_2p_1p_0c_0</script><blockquote><p>👇下面是经过综合器优化门个数后的图。可以明显看到虽然门个数减少但是延时变长。</p></blockquote><p><img src="http://image.beenli.cn/img/20200428/abseSUENAM06.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h2 id="4、超前进位加法器级联"><a href="#4、超前进位加法器级联" class="headerlink" title="4、超前进位加法器级联"></a>4、超前进位加法器级联</h2><script type="math/tex;mode=display">pp = p[0] \& p[1] \& p[2] \& p[3](传输信号)</script><script type="math/tex;mode=display">gg = c_4(进位信号)</script><p><code>pp</code>： 代表相加结果为1111的时候。那么低一级要是有进位，传到我这一级，会产生想上一级的进位。</p><pre><code class="hljs verilog"><span class="hljs-comment">// Author: Wan Li</span><span class="hljs-comment">// time: 2020-04-28</span><span class="hljs-comment">// function: 把4个超前进位组成16位的</span><span class="hljs-comment">// ---------------------------------------------------</span><span class="hljs-comment">/* `include "adder4.v" */</span><span class="hljs-keyword">module</span> adder_16(a, b, c_in, sum, c_out);    <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, b;    <span class="hljs-keyword">input</span> c_in;    <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum;    <span class="hljs-keyword">output</span> c_out;    <span class="hljs-keyword">wire</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] p, g, c;    <span class="hljs-keyword">assign</span> c[<span class="hljs-number">0</span>] = c_in;    add4_head add1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),   <span class="hljs-variable">.b</span>(b[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),   <span class="hljs-variable">.ci</span>(c[<span class="hljs-number">0</span>]), <span class="hljs-variable">.s</span>(sum[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.pp</span>(p[<span class="hljs-number">0</span>]), <span class="hljs-variable">.gg</span>(g[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">assign</span> c[<span class="hljs-number">1</span>] = g[<span class="hljs-number">0</span>] | (p[<span class="hljs-number">0</span>] &amp; c[<span class="hljs-number">0</span>]);    add4_head add2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>]),   <span class="hljs-variable">.b</span>(b[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>]),   <span class="hljs-variable">.ci</span>(c[<span class="hljs-number">1</span>]), <span class="hljs-variable">.s</span>(sum[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>]), <span class="hljs-variable">.pp</span>(p[<span class="hljs-number">1</span>]), <span class="hljs-variable">.gg</span>(g[<span class="hljs-number">1</span>]));    <span class="hljs-keyword">assign</span> c[<span class="hljs-number">2</span>] = g[<span class="hljs-number">1</span>] | (p[<span class="hljs-number">1</span>] &amp; c[<span class="hljs-number">1</span>]);    add4_head add3(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>]),  <span class="hljs-variable">.b</span>(b[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>]),  <span class="hljs-variable">.ci</span>(c[<span class="hljs-number">2</span>]), <span class="hljs-variable">.s</span>(sum[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>]), <span class="hljs-variable">.pp</span>(p[<span class="hljs-number">2</span>]), <span class="hljs-variable">.gg</span>(g[<span class="hljs-number">2</span>]));    <span class="hljs-keyword">assign</span> c[<span class="hljs-number">3</span>] = g[<span class="hljs-number">2</span>] | (p[<span class="hljs-number">2</span>] &amp; c[<span class="hljs-number">2</span>]);    add4_head add4(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>]), <span class="hljs-variable">.ci</span>(c[<span class="hljs-number">3</span>]), <span class="hljs-variable">.s</span>(sum[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>]), <span class="hljs-variable">.pp</span>(p[<span class="hljs-number">3</span>]), <span class="hljs-variable">.gg</span>(g[<span class="hljs-number">3</span>]));    <span class="hljs-keyword">assign</span> c_out = g[<span class="hljs-number">3</span>] | (p[<span class="hljs-number">3</span>] &amp; c[<span class="hljs-number">3</span>]);<span class="hljs-keyword">endmodule</span></code></pre><p><img src="http://image.beenli.cn/img/20200428/REkvohU89K88.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、1bit全加器&quot;&gt;&lt;a href=&quot;#1、1bit全加器&quot; class=&quot;headerlink&quot; title=&quot;1、1bit全加器&quot;&gt;&lt;/a&gt;1、1bit全加器&lt;/h2&gt;&lt;script type=&quot;math/tex;mode=display&quot;&gt;S = A\op
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="https://www.beenli.cn/categories/Digital-IC/"/>
    
      <category term="verilog" scheme="https://www.beenli.cn/categories/Digital-IC/verilog/"/>
    
    
      <category term="verilog" scheme="https://www.beenli.cn/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>Git for novice</title>
    <link href="https://www.beenli.cn/posts/f05478c5/"/>
    <id>https://www.beenli.cn/posts/f05478c5/</id>
    <published>2020-04-27T10:09:18.000Z</published>
    <updated>2020-08-05T09:57:24.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Git-and-GitHub"><a href="#1、Git-and-GitHub" class="headerlink" title="1、Git and GitHub"></a>1、Git and GitHub</h2><p><code>Github</code> 可以看成是一个基于Git的系统，它提供了仓库的可视化。是一个<code>远程托管仓库</code>。如果是public，其他人可以随意查看，修改。如果是private只有你自己可以查看了。如果为了安全，可以团队自己搭建一个git服务器。</p><p><code>Git</code>大家都已经很熟悉了，分布式版本控制系统(Distributed version control system)</p><h2 id="2、Why-do-we-use-git"><a href="#2、Why-do-we-use-git" class="headerlink" title="2、Why do we use git"></a>2、Why do we use git</h2><ol><li>可以更好地在GitHub上开发，分享啊。</li><li>多人协同开发。</li><li>版本控制，可以任意回滚到之前某个版本。</li></ol><h2 id="3、How-do-we-use-git"><a href="#3、How-do-we-use-git" class="headerlink" title="3、How do we use git"></a>3、How do we use git</h2><p><img src="http://image.beenli.cn/img/20200428/AdQsxqK9vslE.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><blockquote><p>在GitHub上看到一个不错的项目，想要研究，学习为目的。</p></blockquote><ol><li><p>先fork一份到自己的GitHub上。</p></li><li><p>clone到本地</p><p>-o 指定远程仓库的名字，否则默认为<code>origin</code></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [-b &lt;指定分支名&gt;]&lt;远程仓库地址&gt; [-o booyah]  默认是克隆所有分支。</code></pre></li><li><p>进行自己的开发。修改文件后</p><p>此时git status可以看到：修改过的文件红色标处。<code>Untracked files</code><img src="http://image.beenli.cn/img/20200427/3yURcSj2qBqU.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><pre><code class="hljs bash">git add ./[filename]// 把修改过的文件添加到暂存区。</code></pre><p><img src="http://image.beenli.cn/img/20200427/ri8cAxnmujYg.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>此时文件变成绿色。即已经添加到了暂存区。</p></li><li><p>提交</p><pre><code class="hljs bash">git commit -m <span class="hljs-string">"添加文件的说明"</span>// 提交</code></pre><p>提交完成了，工作目录应该显示是空的。</p></li><li><p>推送到远程仓库</p><pre><code class="hljs bash">git pull origin [branch name] // 推送到指定仓库的指定分支上。</code></pre><p><img src="http://image.beenli.cn/img/20200427/aTKLfLxC1XUc.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><blockquote><p>自己新建一个仓库。做项目开发。</p></blockquote><ol><li><p>初始化一个本地仓库</p><pre><code class="hljs bash">git init xxx// 新建一个名为xxx的仓库</code></pre></li><li><p>进入仓库，然后就可以开发了。</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  xxx // 此目录就是工程根目录。</code></pre></li><li><p>如果要上传到GitHub上。即远端git服务器</p><ul><li><p>首先在GitHub上新建一个仓库。</p></li><li><p>本地仓库与远程仓库建立联系。</p><pre><code class="hljs axapta">git remote add origin &lt;<span class="hljs-keyword">server</span>&gt;<span class="hljs-comment">// 与GitHub仓库建立联系. origin 可以换成任意名字。</span></code></pre><p><img src="http://image.beenli.cn/img/20200427/9id7SRqNtn2j.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到我通过origin pull不上去。因为我连接的是remote_name。</p></blockquote></li><li><p>push到远程服务器上</p><pre><code class="hljs bash">git push origin master // 推送到远程服务器上</code></pre></li></ul><p>如果是克隆远程仓库的话，那么可以跳过remote（因为本地master已经和远程master联系上了)。直接推送到远程服务器。</p></li></ol><h2 id="4、common-commands1"><a href="#4、common-commands1" class="headerlink" title="4、common commands1"></a>4、common commands<a href="#link"><sup>1</sup></a></h2><h3 id="1、branch（分支"><a href="#1、branch（分支" class="headerlink" title="1、branch（分支)"></a>1、branch（分支)</h3><h4 id="1、新建分支"><a href="#1、新建分支" class="headerlink" title="1、新建分支"></a>1、新建分支</h4><pre><code class="hljs bash">git checkout -b xxx// 新建分支并切换到xxxgit branch xxx// 只是新建一个分支，仍留在本地。（新建的分支复刻目分支)</code></pre><blockquote><p>git branch [-b branchName commitId] 从指定分支和commit号上开始新的分支</p></blockquote><h4 id="2、分支切换"><a href="#2、分支切换" class="headerlink" title="2、分支切换"></a>2、分支切换</h4><pre><code class="hljs bash">git branch [-a]//查看分支git checkout xxx//切换到xxx分支</code></pre><blockquote><p>git branch 参数-a: 查看所有分支，包括远端的分支。 -v 查看分支指向的commit。 —remote查看远程分支</p></blockquote><h4 id="3、合并分支"><a href="#3、合并分支" class="headerlink" title="3、合并分支"></a>3、合并分支</h4><ol><li><p>先把你次要分支提交完全。</p></li><li><p>切换到你要合并其他分支的主分支上</p></li><li><p>合并</p><pre><code class="hljs bash">git merge <span class="hljs-built_in">test</span>// 在主分支上合并<span class="hljs-built_in">test</span>分支</code></pre><p><img src="http://image.beenli.cn/img/20200427/GXOtI8DdGor8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><blockquote><p>可以看到已经合并了test1分支。现在它们指向同一个commit。</p><p>如果遇到冲突，手动判断哪一个修改留下。</p></blockquote><h4 id="4、删除分支"><a href="#4、删除分支" class="headerlink" title="4、删除分支"></a>4、删除分支</h4><pre><code class="hljs bash">git branch -d [branch name]git push origin --delete [branch name]  // 删除远程分支$ git push origin --delete testingTo github.com:BeenLi/learn_git.git - [deleted]         testing</code></pre><h4 id="5、远程分支"><a href="#5、远程分支" class="headerlink" title="5、远程分支"></a>5、远程分支</h4><pre><code class="hljs bash">$ git ls-remote// 查看远程分支From git@github.com:BeenLi/learn_git.git6fc7758ee27a73196a81391efd803dc19541eb88        HEAD6fc7758ee27a73196a81391efd803dc19541eb88        refs/heads/master807b956e7a57eef2f148dc7cb5b14ae3992955e6        refs/heads/testing807b956e7a57eef2f148dc7cb5b14ae3992955e6        refs/pull/1/head998239f25772ea809310d9f92c9e96a67c158b82        refs/pull/1/merge$ git remote show// 查看远程仓库名字remote_name</code></pre><blockquote><p>“origin” 是当你运行 git clone 时默认的远程仓库名字</p></blockquote><h4 id="6、跟踪分支"><a href="#6、跟踪分支" class="headerlink" title="6、跟踪分支"></a>6、跟踪分支</h4><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span>[<span class="hljs-keyword">branch] </span>[remotename]/[<span class="hljs-keyword">branch]</span><span class="hljs-keyword"></span><span class="hljs-keyword">git </span>checkout --track origin/serverfix// 快捷命令当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>--set-upstream-to origin/remoteBranchName localBranchName 修改远程分支<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>--unset-upstream// 撤销跟踪远程分支</code></pre><p><img src="http://image.beenli.cn/img/20200428/4tSisNi0opQ7.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到 设置了分支test3 跟踪 远端的master分支。现在分支与master分支相同。</p><p>现在，本地分支 test 会自动从 remote_name/master 拉取。</p></blockquote><pre><code class="hljs angelscript">$ git branch -vv  master <span class="hljs-number">2</span>b2be16 修改文件，制造合并冲突  test1  <span class="hljs-number">2</span>b2be16 修改文件，制造合并冲突  test2  <span class="hljs-number">420f</span>721 第二次本地提交  testing e051a6f [remote_name/testing: ahead <span class="hljs-number">1</span>] 测试追踪分支情况* test3  <span class="hljs-number">4f</span>db7bd [remote_name/master] 测试本地提交可以看到test3 是master的跟踪分支。testing分支领先<span class="hljs-number">1</span>。表示有本地有一个commit没有push到服务器上。</code></pre><h4 id="7、分支拉取"><a href="#7、分支拉取" class="headerlink" title="7、分支拉取"></a>7、分支拉取</h4><pre><code class="hljs bash">git pull  == git fetch + git mergegit fetch 不会修改当前工作区的文件。它只会获取数据然后让你自己合并。</code></pre><h4 id="8、上传分支"><a href="#8、上传分支" class="headerlink" title="8、上传分支"></a>8、上传分支</h4><pre><code class="hljs bash">git push origin localbranch:remotebranch如果添加了远程分支就直接push了。</code></pre><h3 id="2、reset-撤销"><a href="#2、reset-撤销" class="headerlink" title="2、reset (撤销)"></a>2、reset (撤销)</h3><p><a href="#link">参考🔗</a></p><p><img src="http://image.beenli.cn/img/20200428/CUvCyfwWR8h9.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><h4 id="1、reset-—hard"><a href="#1、reset-—hard" class="headerlink" title="1、reset —hard"></a>1、reset —hard</h4><p>reset —hard：重置stage区和工作目录(会在重置 <strong>HEAD</strong> 和<strong>branch</strong>的同时，重置stage区和工作目录里的内容)</p><p>即回到上一次commit的位置。，全部清空。</p><h4 id="2、reset-—soft"><a href="#2、reset-—soft" class="headerlink" title="2、reset —soft"></a>2、reset —soft</h4><p>reset —soft：保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区</p><p>即你之前commit的文件，退回到<code>stage</code>。需要重新提交。</p><h4 id="3、reset-—mixed"><a href="#3、reset-—mixed" class="headerlink" title="3、reset [—mixed]"></a>3、reset [—mixed]</h4><p>reset: 保留工作目录，并清空暂存区</p><p>也就是你要重新add，然后commit。</p><div id="link"></div><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://blog.csdn.net/qq_15037231/article/details/79137753" rel="external nofollow noreferrer">分支用法</a></p><p>[2] <a href="https://www.jianshu.com/p/c2ec5f06cf1a" rel="external nofollow noreferrer">reset用法</a></p><p>[3] <a href="https://www.runoob.com/manual/git-guide/" rel="external nofollow noreferrer">简明教程</a></p><p>[4] <a href="https://baijiahao.baidu.com/s?id=1664197276209808372&amp;wfr=spider&amp;for=pc" rel="external nofollow noreferrer">动态过程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Git-and-GitHub&quot;&gt;&lt;a href=&quot;#1、Git-and-GitHub&quot; class=&quot;headerlink&quot; title=&quot;1、Git and GitHub&quot;&gt;&lt;/a&gt;1、Git and GitHub&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Github&lt;/
      
    
    </summary>
    
    
      <category term="Software" scheme="https://www.beenli.cn/categories/Software/"/>
    
      <category term="Git" scheme="https://www.beenli.cn/categories/Software/Git/"/>
    
    
      <category term="git" scheme="https://www.beenli.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——树</title>
    <link href="https://www.beenli.cn/posts/f796a091/"/>
    <id>https://www.beenli.cn/posts/f796a091/</id>
    <published>2020-04-09T05:43:31.000Z</published>
    <updated>2020-04-28T10:02:48.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、树的相关术语"><a href="#1、树的相关术语" class="headerlink" title="1、树的相关术语"></a>1、树的相关术语</h2><ol><li><p><strong>度</strong>：一个结点的子结点数目。树的度指度数最大的那个结点的度</p><script type="math/tex;mode=display">TD = max_{i=1...n}D(i)\quad D(i)表示第i个结点的度</script></li><li><p><strong>叶结点，分支结点</strong></p><p>度为0的结点——<code>叶结点</code>；度大于0的结点——<code>分支结点</code></p></li><li><p><strong>结点的层数</strong></p><p>(1) root(T)——层数为0</p><p>(2)其余结点层数为前驱结点层数 + 1</p></li><li><p><strong>路径</strong></p><script type="math/tex;mode=display">V_m——>V_{m+1}——>...——>V_{m+k} \quad1 <= k <= T最大层数</script><p>同时满足$V_{i+1} $是$V_i$ （m &lt;=i&lt;=m+k-1)的子结点,则称结点序列为$V_m$ 到 $V_{m+1}$ 的路径。该路径经历的边数<code>k</code>称为<code>路径长度</code></p></li><li><p><strong>子孙结点、祖先结点</strong></p><p>一棵树中若存在结点$V_m$ 到$V_n$的路径，则称为$V_n$是$V_m$的<code>子孙结点</code>,为$V_n$是$V_m$的<code>祖先结点</code>。</p></li><li><p><strong>树的高度</strong></p><p>树中结点的最大层数。</p></li></ol><h2 id="2、二叉树引理"><a href="#2、二叉树引理" class="headerlink" title="2、二叉树引理"></a>2、二叉树引理</h2><ol><li><p><strong>设T为n个结点构成的二叉树，其中叶子节点个数为n~0~，度为2的结点个数为n~2~,则有:</strong></p><script type="math/tex;mode=display">n_0 = n_2 +1</script><p>证明：</p><script type="math/tex;mode=display">设总的边数为e,度为1的结点树n_1\\</script><script type="math/tex;mode=display">则:n = n_0 + n_1 + n_2\\</script><script type="math/tex;mode=display">e = n - 1(除了根没有父节点没算在内)\\</script><script type="math/tex;mode=display">e = 2n_2 + n_1\\</script><script type="math/tex;mode=display">则有：2n_2 + n_1 = n_0 + n_1 + n_2 - 1\\</script></li></ol><ol><li><p><code>满二叉树</code>和<code>完全二叉树</code></p><p>满二叉树：每一层都充满了结点，一颗非空高度为k的满二叉树，有$2^{k+1}+1$个结点。</p><p>完全二叉树：只有最后一层不满，其余层全是满的。且最后一层从最左边开始填充。</p><p><img src="http://image.beenli.cn/img/20200410/HISXRvqtBFGy.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li><li><p><strong>若将n个结点的完全二叉树按<code>层次顺序</code>从1开始编号，则对编号为i(1 &lt;= i &lt;= n)的结点</strong>有：</p><ol><li>若 i $\neq$ = 1,则编号为i的结点父节点编号为$\left \lfloor i/2 \right \rfloor$</li><li>若 2i $\leq$ n, 则编号为i的结点左孩子编号为2i,否则无左孩子</li><li>若 2i+1 $\leq$ n, 则编号为i的右孩子编号为2i + 1,否者无有孩子。</li><li><code>推论</code>：一棵具有n个结点的完全二叉树，分支结点个数为$\left \lfloor n/2 \right \rfloor$。(最后一个结点n的父节点为$\left \lfloor n/2 \right \rfloor$)</li></ol><p><img src="http://image.beenli.cn/img/20200410/5LKoRUbNYOH0.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li><li><p>具有n个结点的完全二叉树高度为$\left \lfloor log_2n \right \rfloor$</p><p>证明：</p><script type="math/tex;mode=display">设高度为k</script></li></ol><script type="math/tex;mode=display">二叉树结点个数介于高度为k-1和高度为k的满二叉树结点之间。\\</script><script type="math/tex;mode=display">2^k-1< n \leq 2^{k+1}-1\\</script><script type="math/tex;mode=display">所有log_2n-1<k\leq log_2n\\</script><script type="math/tex;mode=display">k取整数：k =\left \lfloor log_2n \right \rfloor</script><h2 id="3、二叉树递归遍历"><a href="#3、二叉树递归遍历" class="headerlink" title="3、二叉树递归遍历"></a>3、二叉树递归遍历</h2><ol><li><p>先根遍历(Preorder Traversal)</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Preorder</span><span class="hljs-params">(t)</span></span>IF t = NULL Then return.<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(data(t)</span></span>).<span class="hljs-comment">// 直接打印出根，然后往左找</span><span class="hljs-function"><span class="hljs-title">Preorder</span><span class="hljs-params">(left(t)</span></span>)<span class="hljs-function"><span class="hljs-title">Preorder</span><span class="hljs-params">(right(t)</span></span>)</code></pre></li><li><p>中根遍历(Inorder Traversal)</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Inorder</span><span class="hljs-params">( t )</span></span>IF t = NULL Then return.<span class="hljs-function"><span class="hljs-title">INorder</span><span class="hljs-params">(left(t)</span></span>)<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(data(t)</span></span>)<span class="hljs-function"><span class="hljs-title">INorder</span><span class="hljs-params">(right(t)</span></span>)</code></pre></li><li><p>后根遍历(Postorder Traversal)</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Postorder</span><span class="hljs-params">( t )</span></span>IF t = NULL Then return.<span class="hljs-function"><span class="hljs-title">Postorder</span><span class="hljs-params">(left(t)</span></span>)<span class="hljs-function"><span class="hljs-title">Postorder</span><span class="hljs-params">(right(t)</span></span>)<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(data(t)</span></span>)</code></pre></li></ol><h2 id="4、二叉树非递归遍历"><a href="#4、二叉树非递归遍历" class="headerlink" title="4、二叉树非递归遍历"></a>4、二叉树非递归遍历</h2><h3 id="1、先根遍历"><a href="#1、先根遍历" class="headerlink" title="1、先根遍历"></a>1、先根遍历</h3><p>策略：</p><ol><li>一直往左走，只要不为空就访问，访问完进栈。当为空时弹栈，访问右子树。</li><li>进栈的是访问结点的右子树。</li></ol><pre><code class="hljs c">create(S);p = root(t) <span class="hljs-comment">// 创建一个辅助栈,辅助指针p指向根t。</span><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 一直循环，直到栈为空</span>{<span class="hljs-keyword">while</span>(p)<span class="hljs-comment">// 当p不为空，访问它，把它压栈或者它右子树压栈</span>{<span class="hljs-built_in">process</span>(p.data);S.push(p) <span class="hljs-keyword">or</span> S.push(p.right);p = p.left;}<span class="hljs-keyword">if</span>(S.empty()) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 循环出口。</span>p = S.pop();<span class="hljs-comment">// 出栈</span>p = p.right;<span class="hljs-comment">// 如果是压的右子树，这一步省略</span>}</code></pre><h3 id="2、中根遍历"><a href="#2、中根遍历" class="headerlink" title="2、中根遍历"></a>2、中根遍历</h3><p>策略：一直往走，中途结点全部压入栈。直到左子树为空，出栈访问，把右子树压栈。然后继续。</p><pre><code class="hljs c">creat(S);p=root(T);<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){ <span class="hljs-keyword">while</span>(p)    {        S.push(p);        p = p.left;    }    <span class="hljs-keyword">if</span>(S.empty()) <span class="hljs-keyword">return</span>;    p = S.pop();    <span class="hljs-built_in">process</span>(p);<span class="hljs-comment">// 处理出栈的最左边结点</span>    p = p.right;<span class="hljs-comment">// 续上开头，现在p.right相当于root</span>}</code></pre><h3 id="3、二叉树的形态"><a href="#3、二叉树的形态" class="headerlink" title="3、二叉树的形态"></a>3、二叉树的形态</h3><p>中根和先根算法进出栈的顺序是一样的。<code>进栈序列</code>：<code>先根序列</code>;<code>出栈序列</code>:<code>中根序列</code></p><p>假设先根序列为1…n时，有多少种中跟序列就有多少种二叉树形态。(中根+先根唯一确定一棵树)</p><p>即n个数有多少种出栈方式:</p><script type="math/tex;mode=display">Catalan(n) = \frac{1}{n+1}C_{2n}^{n}</script><h3 id="4、后根遍历"><a href="#4、后根遍历" class="headerlink" title="4、后根遍历"></a>4、后根遍历</h3><p>策略：</p><ol><li><p>一直往左走，压栈。如果遇到右子树为空或者右子树已经遍历过了就出栈访问它。否者就访问右子树。开始新的遍历。</p><pre><code class="hljs gauss"><span class="hljs-keyword">Create</span>(S); p = <span class="hljs-built_in">root</span>(T);pre=<span class="hljs-built_in">NULL</span><span class="hljs-comment">//pre存储p之前访问过的结点。</span>  <span class="hljs-keyword">while</span>(true)  {      <span class="hljs-keyword">while</span>(p)      {          S.push(p);          p = p.left;      }      <span class="hljs-keyword">if</span>(S.empty) <span class="hljs-keyword">return</span>;      p = <span class="hljs-built_in">peak</span>(S);      <span class="hljs-keyword">if</span>(p.right == <span class="hljs-built_in">NULL</span> or p.right == pre)      {          S.pop();          <span class="hljs-built_in">process</span>(p.data);          pre = p;<span class="hljs-comment">//始终记录上一次访问过的结点</span>          p = <span class="hljs-built_in">NULL</span>;<span class="hljs-comment">//为了下一个循环中去父节点的右结点。</span>      }      <span class="hljs-keyword">else</span> p = p.right;  }</code></pre><p><img src="http://image.beenli.cn/img/20200410/3NxPuxxmqoTP.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li><li><p>允许多次进出栈。栈元素为二元组（结点，标号i)</p><p>i = 1 ：没有访问结点的任何子树。准备遍历其左子树</p><p>i = 2 ：遍历完左子树，准备遍历右子树</p><p>i = 3：遍历完右子树</p><p>初始化：（root(T), 1)压入栈。弹栈，判断出栈元素标号：</p><p>i = 1, 则将(p, 2) 压栈，准备遍历左子树。把（left(p), 1)压栈</p><p>i = 2, 则将(p, 3)压栈，准备遍历右子树，即把（right(p),1)压栈</p><p>i = 3, 访问结点p</p><pre><code class="hljs reasonml">create(S);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>push((root(T),<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>isempty<span class="hljs-literal">()</span>){(p,i) = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>pop<span class="hljs-literal">()</span>;    <span class="hljs-keyword">if</span>(p)<span class="hljs-comment">// 防止空指针</span>    {        <span class="hljs-keyword">if</span>(i<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)        {            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>push((p,<span class="hljs-number">2</span>));            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>push((p.left, <span class="hljs-number">1</span>));        }        <span class="hljs-keyword">if</span>(i<span class="hljs-operator"> == </span><span class="hljs-number">2</span>)        {            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>push((p,<span class="hljs-number">3</span>));            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>push((p.right,<span class="hljs-number">1</span>));        }        <span class="hljs-keyword">else</span>        {            process(p.data)        }    }}</code></pre></li></ol><h3 id="5、层次遍历"><a href="#5、层次遍历" class="headerlink" title="5、层次遍历"></a>5、层次遍历</h3><pre><code class="hljs c">create(Q);<span class="hljs-keyword">if</span>(root(T)) Q.enqueue(T);<span class="hljs-comment">//先将头结点入队</span><span class="hljs-keyword">while</span>(!Q.empty){    p = Q.dequeue();    <span class="hljs-built_in">process</span>(p.data);<span class="hljs-comment">//取头结点访问</span>    <span class="hljs-keyword">if</span>(p.left) Q.enqueue(p.left); <span class="hljs-comment">//如果左节点不空，加入(先进先出)</span>    <span class="hljs-keyword">if</span>(p.right) Q.enqueue(p.right);}</code></pre><blockquote><p>由中根遍历 + （层次/先根/后根）唯一确定一棵树</p></blockquote><h2 id="5、二叉树相关应用"><a href="#5、二叉树相关应用" class="headerlink" title="5、二叉树相关应用"></a>5、二叉树相关应用</h2><h3 id="1、搜索给定结点的父节点"><a href="#1、搜索给定结点的父节点" class="headerlink" title="1、搜索给定结点的父节点"></a>1、搜索给定结点的父节点</h3><pre><code class="hljs c">Father(t,p.q)<span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> <span class="hljs-keyword">or</span> p==t) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span>(t.left ==p <span class="hljs-keyword">or</span> t.right == p) <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// return Father(t.left, p) || Fathre(t.right, p)</span>q = Father(t.left,p);<span class="hljs-keyword">if</span>(q) <span class="hljs-keyword">return</span> q;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Father(t.right, p)</code></pre><h3 id="2、释放二叉树"><a href="#2、释放二叉树" class="headerlink" title="2、释放二叉树"></a>2、释放二叉树</h3><pre><code class="hljs lisp">Del(<span class="hljs-name">p</span>)if(<span class="hljs-name">p</span> == NULL) return<span class="hljs-comment">;</span>Del(<span class="hljs-name">p</span>.left)<span class="hljs-comment">;</span>Del(<span class="hljs-name">p</span>.right)<span class="hljs-comment">;</span>free(<span class="hljs-name">p</span>)<span class="hljs-comment">;// 后续遍历删除，从后往前删。</span></code></pre><h3 id="3、删除一颗小树"><a href="#3、删除一颗小树" class="headerlink" title="3、删除一颗小树"></a>3、删除一颗小树</h3><blockquote><p>删除给定结点以及其左右子树<br></p><pre><code class="hljs c">DILR(t,p)<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 为空</span><span class="hljs-keyword">if</span>(p == t){Del(p);    t = <span class="hljs-literal">NULL</span><span class="hljs-comment">//删除整棵树 t还有定义，可以再赋值。</span>}q = Father(t,p);<span class="hljs-keyword">if</span>(q.left == p) q.left = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//修改原来指向p的指针为空</span><span class="hljs-keyword">if</span>(q.right == p) q.right == <span class="hljs-literal">NULL</span>;Del(p);</code></pre><p></p></blockquote><h3 id="4、创建二叉树"><a href="#4、创建二叉树" class="headerlink" title="4、创建二叉树"></a>4、创建二叉树</h3><p>由于先根序列不能体现左右子树为空的情况，所有用<code>#</code>表示空子结点。则可以唯一表示一课树。</p><p><img src="http://image.beenli.cn/img/20200410/XEtAcvEkUge8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><pre><code class="hljs c">递归算法（CreateBinTree)(简称为CBT)输入：包含空指针的先根序列输出：根指针t算法CBT(.t)p = getchar();<span class="hljs-keyword">if</span>(p == <span class="hljs-string">"\n"</span> || p == <span class="hljs-string">"#"</span>) {    t = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 指针置为空。即#代表空指针</span> <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// 递归出口</span>}t = create(p);t-&gt;left = CBT(.t);t-&gt;right = CBT(.t);<span class="hljs-comment">// 建立左右子树</span><span class="hljs-keyword">return</span> t;<span class="hljs-function">Treeptr <span class="hljs-title">createbigtree</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">char</span> p;Treeptr t;p = getchar();<span class="hljs-keyword">if</span>(p == <span class="hljs-string">'\n'</span> || p == <span class="hljs-string">'#'</span>) {    t = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> t;}t = createtree(p);t-&gt;left = createbigtree();t-&gt;right = createbigtree();<span class="hljs-keyword">return</span> t;}</code></pre><h3 id="5、复制一颗二叉树"><a href="#5、复制一颗二叉树" class="headerlink" title="5、复制一颗二叉树"></a>5、复制一颗二叉树</h3><pre><code class="hljs xl">Treeptr copybigtree(Treeptr sample){    <span class="hljs-keyword">if</span>(sample) return NULL;<span class="hljs-comment">// 递归出口</span>    T<span class="hljs-function"><span class="hljs-title">reeptr</span> t = createtree(sample-&gt;</span><span class="hljs-keyword">data</span>);<span class="hljs-comment">// 复制根</span>    <span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = copybigtree(sample-&gt;</span>left);<span class="hljs-comment">// 复制左子树</span>    <span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = copybigtree(sample-&gt;</span>right);      <span class="hljs-comment">// 复制右子树</span>    return t;}</code></pre><h3 id="6、后序遍历求结点个数"><a href="#6、后序遍历求结点个数" class="headerlink" title="6、后序遍历求结点个数"></a>6、后序遍历求结点个数</h3><pre><code class="hljs c">算法 Count(t.n)<span class="hljs-keyword">if</span> t=^  then (n &lt;-- <span class="hljs-number">0.</span><span class="hljs-keyword">return</span>.)Count(left(t).nl).COunt(right(t).nr).n &lt;-- nl+nr+<span class="hljs-number">1.</span>|        <span class="hljs-comment">/* 利用后续遍历计算二叉树结点数 */</span><span class="hljs-keyword">int</span> Countnode(Treeptr p){    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> Countnode(p-&gt;left) + Countnode(p-&gt;right) + <span class="hljs-number">1</span>;}</code></pre><h3 id="7、计算二叉树的高度"><a href="#7、计算二叉树的高度" class="headerlink" title="7、计算二叉树的高度"></a>7、计算二叉树的高度</h3><pre><code class="hljs c">算法 depth(t.h)<span class="hljs-keyword">if</span> t=^ then(d &lt;-- <span class="hljs-number">-1.</span> <span class="hljs-keyword">return</span>.)<span class="hljs-keyword">else</span>(depth(left(t).d1).depth(right(t).d2).<span class="hljs-keyword">if</span>(d1&gt;d2) then d &lt;-- d1+<span class="hljs-number">1.</span><span class="hljs-keyword">else</span> d &lt;-- d2+<span class="hljs-number">1.</span>)|<span class="hljs-keyword">int</span> depthtree(Treeptr p){    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">int</span> ld = depthtree(p-&gt;left);    <span class="hljs-keyword">int</span> rd = depthtree(p-&gt;right);    <span class="hljs-keyword">return</span> ld&gt;rd ? ld+<span class="hljs-number">1</span>:rd +<span class="hljs-number">1</span>;}</code></pre><h3 id="8、二叉树首尾结点"><a href="#8、二叉树首尾结点" class="headerlink" title="8、二叉树首尾结点"></a>8、二叉树首尾结点</h3><blockquote><p>先, 中, 后（<code>不使用递归，不适应栈</code>）<br><img src="http://image.beenli.cn/img/20200411/3HBrfI6nMVNC.jpg?imageslim" srcset="/img/loading.gif" alt="先根序列第一个结点"></p></blockquote><p><img src="http://image.beenli.cn/img/20200411/XypySE1MIhfi.jpg?imageslim" srcset="/img/loading.gif" alt="后根序列第一个结点"></p><pre><code class="hljs c"><span class="hljs-comment">/**************** 中根序列 ********************/</span>---------------------第一个结点(最左边的结点)<span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) then <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;p = t;<span class="hljs-keyword">while</span>(p-&gt;left) p = p-&gt;left;<span class="hljs-keyword">return</span> p;----------------------最后一个结点（最右边的结点）<span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) then <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;p = t;<span class="hljs-keyword">while</span>(p-&gt;right) p = p-&gt;right;<span class="hljs-keyword">return</span> p;    <span class="hljs-comment">/***************** 先根序列 **********************/</span>-----------------------第一个结点（即根）<span class="hljs-keyword">return</span> t;-----------------------最后一个结点(往右找第一个叶结点，找不到往左再重复上一步操作)<span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) then <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;p = t;<span class="hljs-keyword">while</span>(p){    <span class="hljs-keyword">if</span>(p-&gt;right) p = p-&gt;right;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;left) p = p-&gt;left;<span class="hljs-comment">//不能往右就往左一步</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p<span class="hljs-comment">// 无路可走就是他了</span>}<span class="hljs-comment">/******************* 后根序列 ***********************/</span>-------------------------第一个结点(往左找第一个叶结点，找不到往左一步再重复上一步)<span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) then <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;p = t;<span class="hljs-keyword">while</span>(p){    <span class="hljs-keyword">if</span>(p-&gt;left) p = p-&gt;left;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;right) p = p-&gt;right;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、树的相关术语&quot;&gt;&lt;a href=&quot;#1、树的相关术语&quot; class=&quot;headerlink&quot; title=&quot;1、树的相关术语&quot;&gt;&lt;/a&gt;1、树的相关术语&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;度&lt;/strong&gt;：一个结点的子结点数目。树的度指度数最大
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Data Structure" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Data-Structure/"/>
    
    
      <category term="C" scheme="https://www.beenli.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Tasks and Functions</title>
    <link href="https://www.beenli.cn/posts/71407778/"/>
    <id>https://www.beenli.cn/posts/71407778/</id>
    <published>2020-04-08T14:20:43.000Z</published>
    <updated>2020-04-25T16:07:54.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tasks-and-Functions"><a href="#Tasks-and-Functions" class="headerlink" title="Tasks and Functions"></a><center>Tasks and Functions</center></h1><h2 id="1、What-are-they-good-for"><a href="#1、What-are-they-good-for" class="headerlink" title="1、What are they good for"></a>1、What are they good for</h2><blockquote><p>Tasks and functions provide the ability to execute common procedures from several different places in a description. They also provide a means of breaking up large procedures into smaller ones to make it easier to read and debug the source descriptions.</p></blockquote><p>从std 1364-2005的这段描述中，我们可以总结出以下用处:</p><ol><li>减少重复工作，代码复用。</li><li>把大的过程拆解成几个小的任务和函数，更加易读和找bug</li></ol><h2 id="2、Distinctions-between-tasks-and-functions"><a href="#2、Distinctions-between-tasks-and-functions" class="headerlink" title="2、Distinctions between tasks and functions"></a>2、Distinctions between tasks and functions</h2><ol><li><p>A function shall execute in one simulation time unit; a task can contain time-controlling statements.</p><p>函数应该瞬间返回结果，不能有延时；而任务可以带有延时控制语句。</p></li><li><p>A function cannot enable a task; a task can enable other tasks and functions.</p><p>函数不能调用任务；但是任务可以调用其他任务或者函数。</p></li><li><p>A function shall have at least one input type argument and shall not have an output or inout type argument; a task can have zero or more arguments of any type.</p><p>函数应该至少有一个<code>输入参数</code>并且不能有输出或者输入输出参数。</p><p>任务可以有零个或者任意个任何种类的参数。</p></li><li><p>A function shall return a single value; a task shall not return a value.</p><p>函数应该返回一个单一的值；任务不能返回值(只能通过把处理放在参数上带回)</p><hr><p class="note note-primary">The purpose of a function is to respond to an input value by returning a single value. A task can support multiple goals and can calculate multiple result values. However, only the output or inout type arguments pass result values back from the invocation of a task. A function is used as an operand in an expression; the value of that operand is the value returned by the function.</p><ul><li><p>函数的目的：对于输入给出一个返回结果</p></li><li><p>任务支持多个结果，但是只有<code>输出</code>或者<code>输入输出</code>参数能够传递这种结果</p></li><li><p>函数可以在表达式中用作一个操作数。（其值就是函数返回的结果。是不是很像C)</p></li></ul></li><li><p>例如：</p><pre><code class="hljs verilog">switch_bytes(old_word, new_word);<span class="hljs-comment">//task会把运算结果放在new_word上</span>new_word = switch_bytes(old_word);<span class="hljs-comment">//function会直接把结果返回。</span></code></pre></li></ol><div class="table-container"><table><thead><tr><th>比较点</th><th>tasks</th><th>functions</th></tr></thead><tbody><tr><td><strong><em>输入输出</em></strong></td><td>任意多输入输出(input,output,inout)</td><td>至少一个输入不能有输出</td></tr><tr><td>触发事件控制</td><td>可以包含延时控制语句(#), 只能面向仿真，不能综合</td><td>不能出现always, # 等语句，函数应该在一个时间单元内返回值</td></tr><tr><td><strong><em>返回值</em></strong></td><td>通过输出端口传递</td><td>通过函数名返回(only one)</td></tr><tr><td><strong><em>中段</em></strong></td><td>可以由disable中断</td><td>不能</td></tr><tr><td>语句</td><td></td><td></td></tr><tr><td><strong><em>调用其他</em></strong></td><td>可以调用task和function</td><td>只能调用function，不能调用task</td></tr><tr><td><strong><em>其他说明</em></strong></td><td>task调用可以作为完整的语句出现</td><td>function调用只能作为赋值语句右边的operand</td></tr></tbody></table></div><h2 id="3、-Tasks-and-task-enabling"><a href="#3、-Tasks-and-task-enabling" class="headerlink" title="3、 Tasks and task enabling"></a>3、 Tasks and task enabling</h2><blockquote><p>A task shall be enabled from a statement that defines the argument values to be passed to the task and the variables that receive the results. Control shall be passed back to the enabling process after the task has completed. Thus, if a task has timing controls inside it, then the time of enabling a task can be different from the time at which the control is returned. A task can enable other tasks, which in turn can enable still other tasks—with no limit on the number of tasks enabled. Regardless of how many tasks have been enabled,control shall not return until all enabled tasks have completed.</p></blockquote><ol><li>调用task应该给出<code>传进参数的值</code>，和<code>接受结果的变量</code>。</li><li>task如果有延时控制，那么task被调用时刻和控制返回时刻可以不同。</li><li>task内可以再调用task，直到所有的task完成才会返回控制到顶层调用处。</li></ol><h3 id="3-1、task-declaration-syntaxes"><a href="#3-1、task-declaration-syntaxes" class="headerlink" title="3.1、task declaration syntaxes"></a>3.1、task declaration syntaxes</h3><pre><code class="hljs verilog">task_declaration ::= (From A<span class="hljs-variable">.2</span><span class="hljs-variable">.7</span>)<span class="hljs-keyword">task</span> [ <span class="hljs-keyword">automatic</span> ] task_identifier ; { task_item_declaration } statement_or_null <span class="hljs-keyword">endtask</span> task_declaration ::= (From A<span class="hljs-variable">.2</span><span class="hljs-variable">.7</span>)<span class="hljs-keyword">task</span> [ <span class="hljs-keyword">automatic</span> ] task_identifier ( [ task_port_list ] ) ;                 { block_item_declaration }                 statement_or_null                 <span class="hljs-keyword">endtask</span></code></pre><blockquote><p>Tasks without the optional keyword automatic are static tasks, with all declared items being statically allocated. These items shall be shared across all uses of the task executing concurrently. All items declared inside automatic tasks are allocated dynamically for each invocation Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through use of their hierarchical name.（automatic的坑后面再填)</p></blockquote><h3 id="3-2、Task-enabling-and-argument-passing"><a href="#3-2、Task-enabling-and-argument-passing" class="headerlink" title="3.2、Task enabling and argument passing"></a>3.2、Task enabling and argument passing</h3><pre><code class="hljs angelscript">task_enable ::= (From A<span class="hljs-number">.6</span><span class="hljs-number">.9</span>)hierarchical_task_identifier [ ( expression { , expression } ) ] ;</code></pre><ol><li>If the argument is declared as an output or an inout, then the expression shall be restricted to an expression that is valid on the left-hand side of a procedural assignment.(输出参数：能位于<code>过程赋值语句</code>左边的有效表达式。<code>不能是wire</code>)</li></ol><ul><li>reg, integer, real, realtime, and time variables</li><li>Memory references</li><li>Concatenations of reg, integer, and time variables</li><li>Concatenations of memory references</li><li>Bit-selects and part-selects of reg, integer, and time variables</li></ul><ol><li><p>All arguments to the task shall be passed by value rather than by reference</p><p>任务参数的是<code>值传递</code>不是引用(指针)</p></li><li><p>If an argument in the task is declared as an input, then the corresponding expression can be any expression.The order of evaluation of the expressions in the argument list is undefined.</p><p>如果参数被定义为input，那么调用语句与之相应位置的表达式没有限制，表达式求值过程是没有被定义的。（求值顺序没有先后）</p></li></ol><pre><code class="hljs verilog"><span class="hljs-keyword">task</span>  my_task;     <span class="hljs-keyword">input</span>  a, b;     <span class="hljs-keyword">inout</span>  c;     <span class="hljs-keyword">output</span>  d, e;     <span class="hljs-keyword">begin</span>    . . .   <span class="hljs-comment">// statements that perform the work of the task</span>    . . .    c = foo1;   <span class="hljs-comment">// the assignments that initialize result regs</span>    d = foo2;    e = foo3;    <span class="hljs-keyword">end</span><span class="hljs-keyword">endtask</span></code></pre><pre><code class="hljs verilog"><span class="hljs-keyword">task</span>  my_task ( <span class="hljs-keyword">input</span>  a, b,  <span class="hljs-keyword">inout</span>  c,  <span class="hljs-keyword">output</span>  d, e);     <span class="hljs-keyword">begin</span>    . . .   <span class="hljs-comment">// statements that perform the work of the task</span>    . . .    c = foo1;  <span class="hljs-comment">// the assignments that initialize result regs</span>    d = foo2;    e = foo3;    <span class="hljs-keyword">end</span><span class="hljs-keyword">endtask</span></code></pre><p>一种是参数列表在函数名后定义。一种是在task里面定义。</p><blockquote><p>my_task (v, w, x, y, z); //调用语句</p></blockquote><p>The task-enabling arguments ( v , w , x , y , and z ) correspond to the arguments ( a , b , c , d , and e ) defined by the task.</p><p>当函数调用时:</p><blockquote><p>a = v;<br>b = w;<br>c = x;</p></blockquote><p>When the task completes, the following assignments to return the computed values to the<br>calling process are performed:(当函数结束后，下面的赋值返回对应的结果)</p><blockquote><p>x = c;<br>y = d;<br>z = e;</p></blockquote><p class="note note-primary">task enable statement中参数位置要和task definition 对应。不管你是哪种方法定义task</p><h3 id="3-3、Task-memory-usage-and-concurrent-face-with-head-bandage-（可以跳过）"><a href="#3-3、Task-memory-usage-and-concurrent-face-with-head-bandage-（可以跳过）" class="headerlink" title="3.3、Task memory usage and concurrent :face_with_head_bandage:（可以跳过）"></a>3.3、Task memory usage and concurrent :face_with_head_bandage:（可以跳过）</h3><p>A task may be enabled more than once concurrently. All variables of an automatic task shall be replicated on each concurrent task invocation to store state specific to that invocation.All variables of a static task shall be static in that there shall be a single variable corresponding to each declared local variable in a module instance, regardless of the number of concurrent activations of the task. However, static tasks in different instances of a module shall have separate storage from each other.</p><hr><h2 id="4、Disabling-of-named-blocks-and-tasks"><a href="#4、Disabling-of-named-blocks-and-tasks" class="headerlink" title="4、Disabling of named blocks and tasks"></a>4、Disabling of named blocks and tasks</h2><p>The <code>disable statement</code> provides the ability to terminate the activity associated with concurrently active procedures, while maintaining the structured nature of Verilog HDL procedural descriptions.（disable 语句可以终止正在运行的过程）</p><ol><li><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>  : block_name    rega = regb;    <span class="hljs-keyword">disable</span>  block_name;    regc = rega; <span class="hljs-comment">// this assignment will never execute</span><span class="hljs-keyword">end</span></code></pre></li><li><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>  : block_name    ...    <span class="hljs-keyword">if</span>  (a == <span class="hljs-number">0</span>)    <span class="hljs-keyword">disable</span>  block_name;    ...<span class="hljs-keyword">end</span> <span class="hljs-comment">// end of named block</span><span class="hljs-comment">// continue with code following named block</span></code></pre></li><li><pre><code class="hljs verilog"><span class="hljs-keyword">task</span>  proc_a;    <span class="hljs-keyword">begin</span>    ...    ...    <span class="hljs-keyword">if</span>  (a == <span class="hljs-number">0</span>)        <span class="hljs-keyword">disable</span>  proc_a; <span class="hljs-comment">// return if true(控制权交回调用语句)</span>    ...    ...    <span class="hljs-keyword">end</span><span class="hljs-keyword">endtask</span></code></pre></li><li><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span> : <span class="hljs-keyword">break</span>    <span class="hljs-keyword">for</span>  (i = <span class="hljs-number">0</span>; i &lt; n; i = i+<span class="hljs-number">1</span>)  <span class="hljs-keyword">begin</span>  : <span class="hljs-keyword">continue</span>        @ clk            <span class="hljs-keyword">if</span>  (a == <span class="hljs-number">0</span>) <span class="hljs-comment">// "continue" loop</span>                <span class="hljs-keyword">disable</span>  <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//(相当于c里面的break)</span>            statements            statements         @ clk            <span class="hljs-keyword">if</span>  (a == b) <span class="hljs-comment">// "break" from loop</span>                <span class="hljs-keyword">disable</span>  <span class="hljs-keyword">break</span>;<span class="hljs-comment">// (相当于c里面的break)</span>            statements            statements    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></li><li><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span><span class="hljs-keyword">begin</span>  : event_expr        @ ev1;        <span class="hljs-keyword">repeat</span>  (<span class="hljs-number">3</span>)  @ trig;        # d action (areg, breg);<span class="hljs-comment">//(只有当ev1出现，trig出现3次才触发)</span><span class="hljs-keyword">end</span>    @ reset  <span class="hljs-keyword">disable</span>  event_expr;<span class="hljs-comment">//(同上面并行进行)</span><span class="hljs-keyword">join</span></code></pre></li><li><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> <span class="hljs-keyword">begin</span> : monostable# <span class="hljs-number">250</span> q = <span class="hljs-number">0</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>   @ retrig  <span class="hljs-keyword">begin</span><span class="hljs-comment">//（只要retrig变化间隔小于250，那么q就一直为1)</span>    <span class="hljs-keyword">disable</span>  monostable;    q = <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span></code></pre></li></ol><h2 id="5、Functions-and-function-calling"><a href="#5、Functions-and-function-calling" class="headerlink" title="5、Functions and function calling"></a>5、Functions and function calling</h2><h3 id="5-1、Function-declarations"><a href="#5-1、Function-declarations" class="headerlink" title="5.1、Function declarations"></a>5.1、Function declarations</h3><pre><code class="hljs verilog">function_declaration ::= (From A<span class="hljs-variable">.2</span><span class="hljs-variable">.6</span>)            <span class="hljs-keyword">function</span> [ <span class="hljs-keyword">automatic</span> ] [ function_range_or_type ]             function_identifier ;             function_item_declaration { function_item_declaration }             function_statement             <span class="hljs-keyword">endfunction</span>                         | <span class="hljs-keyword">function</span> [ <span class="hljs-keyword">automatic</span> ] [ function_range_or_type ]             function_identifier ( function_port_list ) ;             { block_item_declaration }             function_statement             <span class="hljs-keyword">endfunction</span></code></pre><pre><code class="hljs verilog"><span class="hljs-keyword">function</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] getbyte; <span class="hljs-comment">// (如果没有给[range]那么默认为scalar)</span>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] address;     <span class="hljs-keyword">begin</span>    <span class="hljs-comment">// code to extract low-order byte from addressed word</span>    . . .    getbyte =  result <span class="hljs-number">_</span>expression;    <span class="hljs-keyword">end</span><span class="hljs-keyword">endfunction</span></code></pre><pre><code class="hljs verilog"><span class="hljs-keyword">function</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] getbyte ( <span class="hljs-keyword">input</span>  [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] address);     <span class="hljs-keyword">begin</span>    <span class="hljs-comment">// code to extract low-order byte from addressed word</span>    . . .    getbyte =  result <span class="hljs-number">_</span>expression;    <span class="hljs-keyword">end</span><span class="hljs-keyword">endfunction</span></code></pre><h3 id="5-2、Returning-a-value-from-a-function"><a href="#5-2、Returning-a-value-from-a-function" class="headerlink" title="5.2、Returning a value from a function"></a>5.2、Returning a value from a function</h3><p>The function definition shall implicitly declare a variable, internal to the function, with the same name as the function. This variable either defaults to a 1-bit reg or is the same type as the type specified in the function declaration. The function definition initializes the return value from the function by assigning the function result to the internal variable with the same name as the function.</p><p>函数定义就隐含了一个变量（即函数名）</p><p>函数通过给这个隐含变量赋值返回值。</p><h3 id="5-3、Calling-a-function"><a href="#5-3、Calling-a-function" class="headerlink" title="5.3、Calling a function"></a>5.3、Calling a function</h3><pre><code class="hljs verilog">function_call ::= (From A<span class="hljs-variable">.8</span><span class="hljs-variable">.2</span>)        hierarchical_function_identifier{ attribute_instance } ( expression { , expression } )</code></pre><pre><code class="hljs verilog">word = control ? {getbyte(msbyte), getbyte(lsbyte)}:<span class="hljs-number">0</span>;(把两次函数调用的结果拼接起来)</code></pre><h3 id="5-4、Function-rules"><a href="#5-4、Function-rules" class="headerlink" title="5.4、Function rules"></a>5.4、Function rules</h3><ol><li><p>A function shall not have any nonblocking assignments or procedural continuous assignments.</p><p>函数不能有<code>非阻塞赋值</code>或者<code>过程连续赋值</code>（在一个时间单位内完成）</p></li><li><p>A function shall not have any event triggers.</p><p>函数不能有任何<code>时间触发</code></p></li></ol><pre><code class="hljs verilog"><span class="hljs-keyword">module</span>  tryfact;<span class="hljs-comment">// define the function</span><span class="hljs-keyword">function</span> <span class="hljs-keyword">automatic</span>   <span class="hljs-keyword">integer</span>  factorial;<span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] operand;<span class="hljs-keyword">integer</span>  i;<span class="hljs-keyword">if</span>  (operand &gt;= <span class="hljs-number">2</span>) factorial = factorial (operand - <span class="hljs-number">1</span>) * operand;<span class="hljs-keyword">else</span>factorial = <span class="hljs-number">1</span>;<span class="hljs-keyword">endfunction</span><span class="hljs-comment">// test the function</span><span class="hljs-keyword">integer</span>  result;<span class="hljs-keyword">integer</span>  n;<span class="hljs-keyword">initial</span>   <span class="hljs-keyword">begin</span><span class="hljs-keyword">for</span>  (n = <span class="hljs-number">0</span>; n &lt;= <span class="hljs-number">7</span>; n = n+<span class="hljs-number">1</span>)  <span class="hljs-keyword">begin</span>result = factorial(n);<span class="hljs-built_in">$display</span> (<span class="hljs-string">"%0d factorial=%0d"</span>, n, result);</code></pre><h3 id="5-5、-Use-of-constant-functions-face-with-head-bandage-（可以跳过）"><a href="#5-5、-Use-of-constant-functions-face-with-head-bandage-（可以跳过）" class="headerlink" title="5.5、 Use of constant functions:face_with_head_bandage:（可以跳过）"></a>5.5、 Use of constant functions<span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f915.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f915.png?v8">🤕</span>（可以跳过）</h3><p>Constant function calls are used to support the building of complex calculations of values at elaboration time</p><p>常量函数调用用于支持在精化阶段构建复杂的值计算</p><p><span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8">🙂</span>o_o ….待填坑。</p><h2 id="Renference"><a href="#Renference" class="headerlink" title="Renference"></a>Renference</h2><p>[IEEE Std 1364™-2005下载🔗]：链接：<a href="https://pan.baidu.com/s/1ryz4IAuQzNPnGifUJ8oAGw" rel="external nofollow noreferrer">https://pan.baidu.com/s/1ryz4IAuQzNPnGifUJ8oAGw</a><br>提取码：2qvb</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tasks-and-Functions&quot;&gt;&lt;a href=&quot;#Tasks-and-Functions&quot; class=&quot;headerlink&quot; title=&quot;Tasks and Functions&quot;&gt;&lt;/a&gt;&lt;center&gt;Tasks and Functions&lt;/
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="https://www.beenli.cn/categories/Digital-IC/"/>
    
      <category term="verilog" scheme="https://www.beenli.cn/categories/Digital-IC/verilog/"/>
    
    
      <category term="syntax" scheme="https://www.beenli.cn/tags/syntax/"/>
    
  </entry>
  
  <entry>
    <title>git hooks自动部署hexo</title>
    <link href="https://www.beenli.cn/posts/fb29ac9a/"/>
    <id>https://www.beenli.cn/posts/fb29ac9a/</id>
    <published>2020-04-08T01:17:29.000Z</published>
    <updated>2020-08-05T09:57:43.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-hooks-自动部署hexo"><a href="#git-hooks-自动部署hexo" class="headerlink" title="git hooks 自动部署hexo"></a><center>git hooks 自动部署hexo</center></h2><h2 id="1、原理大致如下"><a href="#1、原理大致如下" class="headerlink" title="1、原理大致如下"></a>1、原理大致如下</h2><p><img src="http://image.beenli.cn/img/20200408/OX4sMTrK26wD.png?imageslim" srcset="/img/loading.gif" alt="git hooks"></p><h2 id="2、实施过程"><a href="#2、实施过程" class="headerlink" title="2、实施过程"></a>2、实施过程</h2><ol><li><p>在服务器上搭建一个git服务器<a href="#link"><sup>1</sup></a></p><ol><li><p><code>adduser git</code>(创建一个用户)</p></li><li><p>可以给创建的用户设置密钥<code>passwd git</code></p></li><li><p>赋予git用户sudo权限</p><pre><code class="hljs bash">chmod 740 /etc/sudoers</code></pre></li></ol></li></ol><p>vim /etc/sudoer<br></p><pre><code class="hljs stata">      `给git用户添加命令权限如下`          保存后退出，修改回文件权限`chmod 440 /etc/sudoers`            ![<span class="hljs-keyword">mark</span>](http:<span class="hljs-comment">//image.beenli.cn/img/20200408/cSLiyuqjcxOU.jpg?imageslim)</span>2. 初始化git仓库   ```bash   <span class="hljs-keyword">su</span> git<span class="hljs-comment">//切换至git用户</span>   <span class="hljs-keyword">mkdir</span> blog.git<span class="hljs-comment">//创建仓库文件夹</span>   <span class="hljs-keyword">cd</span> blog.git<span class="hljs-comment">//进入文件夹</span>   git init --bare<span class="hljs-comment">//使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区</span></code></pre><p></p><ol><li><p>创建网站目录</p><pre><code class="hljs bash">sudo mkdir /var/www/blog//创建网站根目录sudo chown -R git.git /var/www/blog//把blog目录以及子目录属组改为git(这一步很重要，否者后续提交没有权限)</code></pre></li><li><p>配置密钥[详情见:ssh协议](<a href="https://www.beenli.cn/posts/782a8ece/">https://www.beenli.cn/posts/782a8ece/</a></p><pre><code class="hljs bash">mkdir .ssh//创建.ssh目录(默认你在git用户的~目录下)<span class="hljs-built_in">cd</span> .sshtouch authorized_keys//把你本地生成的公钥拷贝到此文件夹种</code></pre></li><li><p>配置<code>hooks</code>(git 用户下)<a href="#link"><sup>2</sup></a></p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/blog.git/hooks//切换到hooks目录touch post-receive //创建post-receive文件chmod +x post-receive //赋予其可执行权限</code></pre><blockquote><p>The <code>post-receive</code> hook runs after the entire process is completed and can be used to update other services or notify users. It takes the same stdin data as the <code>pre-receive</code> hook. Examples include emailing a list, notifying a continuous integration server, or updating a ticket-tracking system – you can even parse the commit messages to see if any tickets need to be opened, modified, or closed. This script can’t stop the push process, but the client doesn’t disconnect until it has completed, so be careful if you try to do anything that may take a long time.</p></blockquote><p>复制该段代码到刚刚创建的post-receive文件</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"post-receive hook is running..."</span>GIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/var/www/blogrm -rf <span class="hljs-variable">${TMP_GIT_CLONE}</span>git <span class="hljs-built_in">clone</span> <span class="hljs-variable">$GIT_REPO</span> <span class="hljs-variable">$TMP_GIT_CLONE</span>rm -rf <span class="hljs-variable">${PUBLIC_WWW}</span>/*cp -rf <span class="hljs-variable">${TMP_GIT_CLONE}</span>/* <span class="hljs-variable">${PUBLIC_WWW}</span></code></pre><p>在执行<code>cp</code>（复制)命令的时候，<code>.git</code> 作为隐藏目录不会被拷贝到 Web 根目录下，也就避免了将整个仓库历史暴露在 Web 服务中。</p></li><li><p>最后配置hexo的<code>_config.yml</code></p><pre><code class="hljs bash">deploy:    <span class="hljs-built_in">type</span>: git    repository: git@VPS IP:/~/blog.git  <span class="hljs-comment"># 默认22端口</span>    branch: master</code></pre></li></ol><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="link"></div><p>[1] <a href="https://tding.top/archives/12a4e7e6.html" rel="external nofollow noreferrer">Hexo 博客部署到 VPS</a></p><p>[2] <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="external nofollow noreferrer">git hooks</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-hooks-自动部署hexo&quot;&gt;&lt;a href=&quot;#git-hooks-自动部署hexo&quot; class=&quot;headerlink&quot; title=&quot;git hooks 自动部署hexo&quot;&gt;&lt;/a&gt;&lt;center&gt;git hooks 自动部署hexo&lt;/cent
      
    
    </summary>
    
    
      <category term="Software" scheme="https://www.beenli.cn/categories/Software/"/>
    
      <category term="Git" scheme="https://www.beenli.cn/categories/Software/Git/"/>
    
    
      <category term="git" scheme="https://www.beenli.cn/tags/git/"/>
    
      <category term="Hexo" scheme="https://www.beenli.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="https://www.beenli.cn/posts/782a8ece/"/>
    <id>https://www.beenli.cn/posts/782a8ece/</id>
    <published>2020-04-07T16:25:51.000Z</published>
    <updated>2020-04-25T16:12:52.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH-Protocol"><a href="#SSH-Protocol" class="headerlink" title="SSH Protocol"></a><center>SSH Protocol</center></h2><blockquote><p><strong>Secure Shell</strong> (<strong>SSH</strong>) is a <a href="https://en.wikipedia.org/wiki/Cryptography" rel="external nofollow noreferrer">cryptographic</a> <a href="https://en.wikipedia.org/wiki/Network_protocol" rel="external nofollow noreferrer">network protocol</a> for operating network services securely over an unsecured network.<a href="https://en.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1" rel="external nofollow noreferrer">[1]</a> Typical applications include remote <a href="https://en.wikipedia.org/wiki/Command-line_interface" rel="external nofollow noreferrer">command-line</a>, <a href="https://en.wikipedia.org/wiki/Login" rel="external nofollow noreferrer">login</a>, and remote command execution, but any <a href="https://en.wikipedia.org/wiki/Network_service" rel="external nofollow noreferrer">network service</a> can be secured with SSH.</p></blockquote><p>摘自维基百科。主要为远程登录建立安全的通道。</p><h3 id="1、简要的工作原理"><a href="#1、简要的工作原理" class="headerlink" title="1、简要的工作原理"></a>1、简要的工作原理</h3><p><code>ssh</code>有两种工作方式</p><ol><li><p>基于口令验证</p><p>只要知道帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但缺点是：不能保证你正在连接的服务器就是你想连接的服务器。以下是登录验证流程：</p><p><img src="http://image.beenli.cn/img/20200408/sdKikYkDIiNa.jpg?imageslim" srcset="/img/loading.gif" alt="口令验证"></p></li><li><p>基于密钥验证</p><p><img src="http://image.beenli.cn/img/20200408/XLDkiwcJXaOS.jpg?imageslim" srcset="/img/loading.gif" alt="密钥验证"></p></li></ol><h3 id="2、操作过程-本地win10-服务器centos"><a href="#2、操作过程-本地win10-服务器centos" class="headerlink" title="2、操作过程(本地win10+服务器centos)"></a>2、操作过程(本地win10+服务器centos)</h3><ol><li><p>本地生成密钥对</p><pre><code class="hljs bash"><span class="hljs-string">"Git Bash Hear"</span>ssh-keygen -t rsa</code></pre><p><img src="http://image.beenli.cn/img/20200408/v40J7WztY0xm.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>可以设置密码，也可以为空（既然为了免密那就设置为空吧，不然没意义了）</p><p>文件路径可选。默认放在<code>~/.ssh/</code></p></li><li><p>上传公钥到服务器上<a href="#link"><sup>1</sup></a></p><p>有两种办法：</p><ol><li><p>自行把刚刚上传的公钥上传到服务器指定用户<code>.ssh/</code>目录下的<code>authorized_keys</code>下。（认证密钥可以有很多把，多个localhost可以各自上传自己的🔒到服务器上。也可以所有人公用一把锁。）</p></li><li><p><code>ssh-copy-id -i [./y.pub] username@vps ip(-i指定路径，默认是在.ssh下)</code></p><p>这一步也是要认证密码的。不然什么人都可以上锁就乱套。</p></li></ol></li><li><p>免密登录服务器</p><pre><code class="hljs bash">ssh -i[dir] username@vps ip(-i指定密钥所在，默认在.ssh/下)</code></pre><p class="note note-success">如果之前产生密钥对时设置了密码，这里还是要输入一遍哪个密码的。如果为空就可以直接免密进入了</p></li><li><p>脚本文件加速登录<a href="#link"><sup>2</sup></a></p><ol><li><p>随便选择个文件夹，写一个config文件</p></li><li><pre><code class="lang-bash">Host vps                              # 一个便于你区别这是哪台机器的名字    HostName 47.95.247.18                   User git                          # 登录主机的用户名称    Port 22                                          IdentityFile ~/.ssh/id_rsa        # 密钥所在的文件位置</code></pre></li><li><p><code>ssh -F [config file] vps</code>(指定配置文件位置)就可以直接登录你设置的那台主机</p></li></ol></li></ol><hr><h5 id="可能遇到的问题3"><a href="#可能遇到的问题3" class="headerlink" title="可能遇到的问题3"></a>可能遇到的问题<a href="#link"><sup>3</sup></a></h5><ol><li><p>Authentication refused: bad ownership or modes for directory /root/.ssh</p><blockquote><p>ls -l /root/.ssh</p><p>发现改目录的所有者不是root。只用改成root即可</p><p>chown -R root.root /root/.ssh</p></blockquote></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="link"></div><p>[1] <a href="https://blog.csdn.net/jeikerxiao/article/details/84105529" rel="external nofollow noreferrer">SSH 三步解决免密登录</a></p><p>[2] <a href="https://blog.csdn.net/ky1in93/article/details/83093981" rel="external nofollow noreferrer">ssh配置config快速登录</a></p><p>[3] <a href="https://www.howtogeek.com/168156/fixing-authentication-refused-bad-ownership-or-modes-for-directory/" rel="external nofollow noreferrer">解决权限问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSH-Protocol&quot;&gt;&lt;a href=&quot;#SSH-Protocol&quot; class=&quot;headerlink&quot; title=&quot;SSH Protocol&quot;&gt;&lt;/a&gt;&lt;center&gt;SSH Protocol&lt;/center&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Computer Network" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Computer-Network/"/>
    
    
      <category term="协议" scheme="https://www.beenli.cn/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-熟悉实验环境(1)</title>
    <link href="https://www.beenli.cn/posts/9cf5ff72/"/>
    <id>https://www.beenli.cn/posts/9cf5ff72/</id>
    <published>2020-04-07T05:07:15.000Z</published>
    <updated>2020-04-28T10:35:50.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="熟悉实验环境"><a href="#熟悉实验环境" class="headerlink" title="熟悉实验环境"></a><center>熟悉实验环境</center></h2><h3 id="1、x86模拟器Bochs1"><a href="#1、x86模拟器Bochs1" class="headerlink" title="1、x86模拟器Bochs1"></a>1、x86模拟器<a href="http://bochs.sourceforge.net/" rel="external nofollow noreferrer">Bochs</a><a href="#link"><sup>1</sup></a></h3><p class="note note-info">Bochs is a highly portable open source IA-32 (x86) PC emulator written in C++, that runs on most popular platforms. It includes emulation of the Intel x86 CPU, common I/O devices, and a custom BIOS. Bochs can be compiled to emulate many different x86 CPUs, from early 386 to the most recent x86-64 Intel and AMD processors which may even not reached the market yet.</p><p>可以看到<code>Boch</code>可以模拟<code>intel x86 CPU</code></p><p>在它模拟出的环境中可以运行 Linux、DOS 和各种版本的 Windows 等多种操作系统</p><h3 id="2、操作系统Ubuntu"><a href="#2、操作系统Ubuntu" class="headerlink" title="2、操作系统Ubuntu"></a>2、操作系统<a href="https://ubuntu.com/" rel="external nofollow noreferrer">Ubuntu</a></h3><p>因为有些实验内容涉及到在自己改进的 <code>Linux 0.11</code>下，运行自己编的应用程序。被改进的功能都是高 版本 Linux 内核已经具有的，在其上确认自己编写的应用程序无误后，再用之测试自己改进的 Linux 0.11，可以更有信心些。</p><h3 id="3、实验压缩包hit-oslab"><a href="#3、实验压缩包hit-oslab" class="headerlink" title="3、实验压缩包hit-oslab"></a>3、实验压缩包<a href="https://github.com/hoverwinter/HIT-OSLab" rel="external nofollow noreferrer">hit-oslab</a></h3><p>文件结构:</p><pre><code class="hljs bash">...└── bocks|   ├── BIOS-bochs-latest|       ├── bochs-dbg|   ├── bochs-gdb|   ├── bochsrc.bxrc|   ├── bochsrc-gdb.bxrc|       └── vgabios.bin|└── hdc|   └── umounted└── Linux-0.11|└── boot|├── kernel|├── fs|├── lib|├── init|├── mm|├── tools|├── include|├── tags|└── Makefile├── dbg-asm├── dbg-c├── gdb├── gdb-cmd.txt├── run├── rungdb└── mount-hdc</code></pre><ol><li><p>Image文件</p><p>我们在宿主操作系统也就是ubuntu上对Linux 0.11进行开发，修改和编译。</p><p>之后在Linux-0.11目录会生成一个<code>Image</code>的文件。（编译后的目标文件）</p><p><br></p><p>该文件包含引导和所以内核的二进制代码。</p><p class="note note-primary">oslab 采用 bochs 模拟器加载这个 Image 文件，模拟执行 Linux 0.11，这样省却了重新启动计算机的麻烦。</p></li><li><p>bochs目录</p><p>bochs目录是与bochs相关的执行文件、数据文件和配置文件</p></li><li><p>run 脚本</p><p><code>run</code> 是 运行bochs的脚本命令</p><p>运行后bochs会自动在他的</p><p>虚拟软驱——linux-0.11/Image</p><p>虚拟硬盘——hdc-0.11.img</p><p class="note note-primary">在 0.11 下访问文件系统，访问的就是 hdc-0.11.img 文件内虚拟的文件系统。<br>退出bochs之前现存盘，运行sync命令</p></li><li><p>hdc-0.11.img 文件</p><p>文件的格式是 Minix 文件系统的镜像。Linux 所有版本都支持这种格式的文件系统</p><p>所以可以在宿主系统上挂载该文件系统。达到宿主系统和Linux 0.11之间文件交换的效果</p><p>其中包含的文件有：</p><ul><li>Bash shell；</li><li>一些基本的 Linux 命令、工具，比如 cp、rm、mv、tar；</li><li>vi 编辑器；</li><li>gcc 1.4 编译器，可用来编译标准 C 程序；</li><li>as86 和 ld86；</li><li>Linux 0.11 的源代码，可在 0.11 下编译，然后覆盖现有的二进制内核。</li></ul></li><li><p>编译</p><blockquote><p>make all(make 命令会自动跳过未被修改的文件 )</p><p>如果重新编译没有效果可以试试删除中间文件: make clean &amp;&amp; make all</p></blockquote></li><li><p>运行</p><p><code>./run</code></p></li></ol><h3 id="4、调试"><a href="#4、调试" class="headerlink" title="4、调试"></a>4、调试</h3><ol><li><p>汇编级调试</p><p><code>./dbg-asm</code></p></li><li><p>C语言调试</p><ol><li><p><code>./dbg-c</code></p></li><li><p><code>./rungdb</code>(新开一个窗口)</p><blockquote><p>注意：启动的顺序不能交换，否则 gdb 无法连接。</p></blockquote></li></ol></li></ol><h3 id="5、文件交换"><a href="#5、文件交换" class="headerlink" title="5、文件交换"></a>5、文件交换</h3><pre><code class="hljs bash"><span class="hljs-comment"># 启动挂载脚本</span>$ <span class="hljs-built_in">cd</span> ~/oslab$ sudo ./mount-hdc<span class="hljs-comment"># 进入文件系统</span>$ <span class="hljs-built_in">cd</span> ./mount-hdc/<span class="hljs-comment"># 读写完毕，卸载文件系统</span>$ <span class="hljs-built_in">cd</span> ~/oslab$ sudo umount hdc</code></pre><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><div id="link"></div><p>[1] <a href="https://mooc.study.163.com/course/1000002004?tid=2402971010#/info" rel="external nofollow noreferrer">哈尔滨工业大学.操作系统</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;熟悉实验环境&quot;&gt;&lt;a href=&quot;#熟悉实验环境&quot; class=&quot;headerlink&quot; title=&quot;熟悉实验环境&quot;&gt;&lt;/a&gt;&lt;center&gt;熟悉实验环境&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;1、x86模拟器Bochs1&quot;&gt;&lt;a href=&quot;#1、x86模
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="OS" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/OS/"/>
    
    
      <category term="网易云网课" scheme="https://www.beenli.cn/tags/%E7%BD%91%E6%98%93%E4%BA%91%E7%BD%91%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.beenli.cn/posts/d0edc1ed/"/>
    <id>https://www.beenli.cn/posts/d0edc1ed/</id>
    <published>2020-04-07T04:03:20.000Z</published>
    <updated>2020-04-25T15:55:02.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><center>Linux常用命令</center></h2><ol><li><p>建立软链接<a href="https://man.linuxde.net/ln:link" rel="external nofollow noreferrer">ln</a></p><pre><code class="hljs bash">ln -s [源文件] [链接文件] (创建软链接)</code></pre><p>例如：在<code>~/oslab/</code>下有一个可执行文件<code>gdb</code><br>你只能用<code>./gdb</code>去执行它。<br>但是你可以把它链接到<code>$PATH</code>下，这样你可以在任意路径都可以执行</p><pre><code class="hljs bash">ln -s ~/oslab/gdb /usr/<span class="hljs-built_in">local</span>/bin/gdb</code></pre><p class="note note-info">ln -snf ~/oslab/xxx /usr/local/bin/gdb(修改)</p><hr></li><li><p>移动文件<a href="https://man.linuxde.net/mv" rel="external nofollow noreferrer">mv</a></p><pre><code class="hljs bash">mv [<span class="hljs-built_in">source</span>] [target]</code></pre><p>例如：</p><ol><li>​ <code>mv ~/oslab/oslab/* ~/oslab/</code> (把<code>~/oslab/oslab/</code>下的文件全部 复制到<code>~/oslab/</code>)</li><li><code>mv a.txt b.tax</code> 把文件名a.txt改为b.txt</li></ol><hr></li><li><p>设置权限<a href="https://man.linuxde.net/chmod" rel="external nofollow noreferrer">chmod</a>；<a href="https://man.linuxde.net/chown" rel="external nofollow noreferrer">chown</a></p><p><code>r</code> 读取权限，数字代号为<code>4</code>;<br><code>w</code> 写入权限，数字代号为<code>2</code>；<br><code>x</code> 执行或切换权限，数字代号为<code>1</code>；<br><code>-</code> 不具任何权限，数字代号为<code>0</code>；</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">7</th><th style="text-align:center">rwx</th></tr></thead><tbody><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>rw-</strong></td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>r-x</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center"><strong>r—</strong></td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>-wx</strong></td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>-w-</strong></td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>—x</strong></td></tr><tr><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>—-</strong></td></tr></tbody></table></div><pre><code class="hljs bash">chmod u+x,g+w f0　　 //为文件f0设置自己可以执行，组员可以写入的权限chmod u=rwx,g=rw,o=r f0   //为文件f0设置自己可以读写执行，同组可以读写。其他人可以读chmod 764 f0  // 效果同上chmod a+x f0  // 所有人都可以执行chown -R liu /usr/meng  //将目录/usr/meng及其下面的所有文件、子目录的文件属主改成 liu：</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;&lt;center&gt;Linux常用命令&lt;/center&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;建立软链接&lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.beenli.cn/categories/Linux/"/>
    
    
      <category term="Basic Use" scheme="https://www.beenli.cn/tags/Basic-Use/"/>
    
  </entry>
  
  <entry>
    <title>VIM-Plug</title>
    <link href="https://www.beenli.cn/posts/b71407e8/"/>
    <id>https://www.beenli.cn/posts/b71407e8/</id>
    <published>2020-04-06T09:11:58.000Z</published>
    <updated>2020-08-05T09:56:24.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VIM-Plugs"><a href="#VIM-Plugs" class="headerlink" title="VIM-Plugs"></a><center>VIM-Plugs</center></h2><h5 id="1、vim-plug-插件管理器"><a href="#1、vim-plug-插件管理器" class="headerlink" title="1、vim-plug: 插件管理器"></a>1、<a href="https://github.com/junegunn/vim-plug" rel="external nofollow noreferrer">vim-plug</a>: 插件管理器</h5><pre><code class="hljs CQL">call plug#begin('D:/App/vim/vim81/vimfiles/plugs')//插件安装目录(可以随意定)" Shorthand notation for pluginPlug 'foo/bar'                   //插件下载地址，GitHub可以简写call plug#end()// 函数结束标志</code></pre><blockquote><p>command</p></blockquote><ol><li>:PlugInstall // 安装插件</li><li>:PlugClean // 清理invalid插件</li><li>:PlugUpgrade // 升级插件</li><li>:PlugDiff // 查看现有插件与下载地址处插件不同，即检测更新细节</li><li>:PlugStatus // 查看插件加载情况</li><li>:PlugSnapshot // 生成用于恢复当前插件快照的脚本</li></ol><blockquote><p>feature</p></blockquote><pre><code class="hljs typescript">Plug <span class="hljs-string">'zhuzhzh/verilog_emacsauto.vim'</span>, {<span class="hljs-string">'for'</span>: [<span class="hljs-string">'verilog'</span>, <span class="hljs-string">'systemverilog'</span>] }<span class="hljs-comment">// 当且仅当打开的文件为Verilog或者systemVerilog时加载此插件</span>Plug <span class="hljs-string">'scrooloose/nerdtree'</span>, { <span class="hljs-string">'on'</span>: <span class="hljs-string">'NERDTreeToggle'</span> }<span class="hljs-comment">//当且仅当触发toggle命令时加载此插件</span></code></pre><hr><h5 id="2、lightline-彩色状态栏"><a href="#2、lightline-彩色状态栏" class="headerlink" title="2、lightline:彩色状态栏"></a>2、<a href="https://github.com/itchyny/lightline.vim" rel="external nofollow noreferrer">lightline</a>:彩色状态栏</h5><p><img src="http://image.beenli.cn/img/20200406/5NePjt0zYxFR.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><hr><h5 id="3、vim-colors-solarized-比较舒服的配色方案"><a href="#3、vim-colors-solarized-比较舒服的配色方案" class="headerlink" title="3、vim-colors-solarized:比较舒服的配色方案"></a>3、<a href="https://github.com/altercation/vim-colors-solarized" rel="external nofollow noreferrer">vim-colors-solarized</a>:比较舒服的配色方案</h5><p><img src="http://image.beenli.cn/img/20200406/daLnl7t2NSCK.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>此插件含有两种色调：dark；light</p><blockquote><p>call togglebg#map(“<f1>“) // 可以设置快捷键自行切换</f1></p></blockquote><hr><h5 id="4、youcompleteme：自动补全"><a href="#4、youcompleteme：自动补全" class="headerlink" title="4、youcompleteme：自动补全"></a>4、<a href="https://github.com/ycm-core/YouCompleteMe" rel="external nofollow noreferrer">youcompleteme</a>：自动补全</h5><hr><h5 id="5、vim-snippets-SirVer-ultisnips-代码片填充"><a href="#5、vim-snippets-SirVer-ultisnips-代码片填充" class="headerlink" title="5、vim-snippets+SirVer/ultisnips : 代码片填充"></a>5、<a href="https://github.com/honza/vim-snippets" rel="external nofollow noreferrer">vim-snippets</a>+<a href="https://github.com/SirVer/ultisnips" rel="external nofollow noreferrer">SirVer/ultisnips</a> : 代码片填充</h5><p>第一个插件提供好多语言的代码片文件。第二插件提供的填充引擎。</p><p>snippet有两种格式：</p><ul><li><code>snippets/*</code>: snippets using snipMate format</li><li><code>UltiSnips/*</code>: snippets using UltiSnips format</li></ul><p><img src="http://image.beenli.cn/img/20200406/lWeLOp6hU7Na.gif" srcset="/img/loading.gif" alt="mark"></p><pre><code class="hljs livescript">可以自己编写snippets文件{n}代表要填写的空白处。<span class="hljs-comment">/* placeholder*/</span>snippet test<span class="hljs-regexp">// Author: Wan Li</span><span class="hljs-regexp">//</span> time: `strftime(<span class="hljs-string">"%Y-%m-%d"</span>)`<span class="hljs-regexp">// function: ${1:/*写下测试的功能*/}</span><span class="hljs-regexp">//</span> ---------------------------------------------------<span class="hljs-string">\`timescale</span> <span class="hljs-number">1ns</span>/<span class="hljs-number">1ns</span><span class="hljs-string">\`include</span> <span class="hljs-string">"${2:/*包含的模块文件*/}"</span>    配置_vimrc文件<span class="hljs-keyword">let</span> g:UltiSnipsExpandTrigger=<span class="hljs-string">"&lt;c-j&gt;"</span><span class="hljs-regexp">//ctrl + j 触发</span><span class="hljs-regexp">let g:UltiSnipsJumpForwardTrigger="&lt;c-b&gt;"//</span>ctrl + b 跳到下一个需要填写的空处<span class="hljs-keyword">let</span> g:UltiSnipsJumpBackwardTrigger=<span class="hljs-string">"&lt;c-z&gt;"</span><span class="hljs-regexp">//ctrl + z 跳到上一个需要填写的空出</span></code></pre><hr><h5 id="6、nerdtree-可视化目录树"><a href="#6、nerdtree-可视化目录树" class="headerlink" title="6、nerdtree: 可视化目录树"></a>6、<a href="https://github.com/preservim/nerdtree" rel="external nofollow noreferrer">nerdtree</a>: 可视化目录树</h5><p><img src="http://image.beenli.cn/img/20200406/GAYHOnmiPSIj.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><img src="http://image.beenli.cn/img/20200406/zU1CDLe23EOh.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><img src="http://image.beenli.cn/img/20200406/36WBczsR3bS2.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><hr><h5 id="7、tabbar-整齐的标签窗口"><a href="#7、tabbar-整齐的标签窗口" class="headerlink" title="7、tabbar: 整齐的标签窗口"></a>7、<a href="https://github.com/majutsushi/tagbar" rel="external nofollow noreferrer">tabbar</a>: 整齐的标签窗口</h5><p><img src="http://image.beenli.cn/img/20200406/9PX5LoRQveLS.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><hr><h5 id="8、tpope-vim-commentary-快速注释"><a href="#8、tpope-vim-commentary-快速注释" class="headerlink" title="8、tpope/vim-commentary: 快速注释"></a>8、<a href="https://github.com/tpope/vim-commentary" rel="external nofollow noreferrer">tpope/vim-commentary</a>: 快速注释</h5><blockquote><p>gcc ：注释/取消注释一行</p><p>gc{motion}</p><p>gc : 注释selection块</p><p>7，17 Commentary</p></blockquote><hr><h5 id="9、vim-gutentags：借助universal-ctags-自动产生标签文件-taco"><a href="#9、vim-gutentags：借助universal-ctags-自动产生标签文件-taco" class="headerlink" title="9、vim-gutentags：借助universal ctags 自动产生标签文件:taco:"></a>9、<a href="https://github.com/ludovicchabant/vim-gutentags" rel="external nofollow noreferrer">vim-gutentags</a>：借助<a href="https://docs.ctags.io/en/latest/" rel="external nofollow noreferrer">universal ctags</a> 自动产生标签文件<span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f32e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f32e.png?v8">🌮</span></h5><p>有了这个标签文件，你又可以<code>&lt;C+]&gt;</code>跳转</p><hr><h5 id="10、vim-easy-align：自动对齐"><a href="#10、vim-easy-align：自动对齐" class="headerlink" title="10、vim-easy-align：自动对齐"></a>10、<a href="https://github.com/junegunn/vim-easy-align" rel="external nofollow noreferrer"><strong>vim-easy-align</strong></a>：自动对齐</h5><p>按官方配置来设置快捷键/ga触发</p><blockquote><p>“ Start interactive EasyAlign in visual mode (e.g. vipga)<br>xmap ga<plug>(EasyAlign)</plug></p><p>“ Start interactive EasyAlign for a motion/text object (e.g. gaip)<br>nmap ga<plug>(EasyAlign)</plug></p></blockquote><ul><li><code>1</code> Around the 1st occurrences of delimiters</li><li><code>2</code> Around the 2nd occurrences of delimiters</li><li>…</li><li><code>*</code> Around all occurrences of delimiters</li><li><code>**</code> Left-right alternating alignment around all delimiters</li><li><code>-</code> Around the last occurrences of delimiters (<code>-1</code>)</li><li><code>-2</code> Around the second to last occurrences of delimiters</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Key</th><th style="text-align:center">Description/Use cases</th></tr></thead><tbody><tr><td style="text-align:center">``</td><td style="text-align:center">General alignment around whitespaces</td></tr><tr><td style="text-align:center"><code>=</code></td><td style="text-align:center">Operators containing equals sign (<code>=</code>, <code>==,</code> <code>!=</code>, <code>+=</code>, <code>&amp;&amp;=</code>, …)</td></tr><tr><td style="text-align:center"><code>:</code></td><td style="text-align:center">Suitable for formatting JSON or YAML</td></tr><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center">Multi-line method chaining</td></tr><tr><td style="text-align:center"><code>,</code></td><td style="text-align:center">Multi-line method arguments</td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">LaTeX tables (matches <code>&amp;</code> and <code>\\</code>)</td></tr><tr><td style="text-align:center"><code>#</code></td><td style="text-align:center">Ruby/Python comments</td></tr><tr><td style="text-align:center"><code>"</code></td><td style="text-align:center">Vim comments</td></tr><tr><td style="text-align:center">``</td><td style="text-align:center">Table markdown</td></tr></tbody></table></div><p><img src="http://image.beenli.cn/img/20200406/fubial5cDLym.gif" srcset="/img/loading.gif" alt="mark"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VIM-Plugs&quot;&gt;&lt;a href=&quot;#VIM-Plugs&quot; class=&quot;headerlink&quot; title=&quot;VIM-Plugs&quot;&gt;&lt;/a&gt;&lt;center&gt;VIM-Plugs&lt;/center&gt;&lt;/h2&gt;&lt;h5 id=&quot;1、vim-plug-插件管理器&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Software" scheme="https://www.beenli.cn/categories/Software/"/>
    
      <category term="VIM" scheme="https://www.beenli.cn/categories/Software/VIM/"/>
    
    
      <category term="Plugs" scheme="https://www.beenli.cn/tags/Plugs/"/>
    
  </entry>
  
  <entry>
    <title>Gate-and-switch-level modeling</title>
    <link href="https://www.beenli.cn/posts/aff089ac/"/>
    <id>https://www.beenli.cn/posts/aff089ac/</id>
    <published>2020-04-05T01:54:38.000Z</published>
    <updated>2020-04-28T09:38:08.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gate-and-switch-level-modeling"><a href="#Gate-and-switch-level-modeling" class="headerlink" title="Gate-and-switch-level modeling"></a><center>Gate-and-switch-level modeling</center></h1><h2 id="1、verilog-std-1364-20051"><a href="#1、verilog-std-1364-20051" class="headerlink" title="1、verilog-std-1364-20051"></a>1、verilog-std-1364-2005<a href="#link"><sup>1</sup></a></h2><blockquote><p>There are <code>14 logic gates</code> and <code>12 switches</code> predefined in the Verilog HDL to provide the gate- and switch-level modeling facility. Modeling with logic gates and switches has the following advantages:</p></blockquote><p>— Gates provide a much closer one-to-one <code>mapping</code> between the actual circuit and the model.<br>— There is no <code>continuous assignment</code> equivalent to the <code>bidirectional transfer gate</code>.</p><p>Verilog1364-2005标准规定了26个基本原件，其中14个门级原件，12个开关级原件。</p><p>对于这些原件不需要定义直接调用。</p><h2 id="2、门级建模2"><a href="#2、门级建模2" class="headerlink" title="2、门级建模2"></a>2、门级建模<a href="#link"><sup>2</sup></a></h2><p><img src="http://image.beenli.cn/global/20200405/86dMFOGFTOna.png?imageslim" srcset="/img/loading.gif" alt="内置门级元件"></p><ol><li><p>多输入门：</p><pre><code class="hljs verilog">n_input_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal { , input_terminal } ) <span class="hljs-keyword">and</span> A1(out1, in1, in2);<span class="hljs-keyword">or</span>  O1(outa, inb, inc, ind);<span class="hljs-keyword">xor</span> X1(outx, inx, iny, inz, inw);</code></pre></li><li><p>多输出门调用:</p><pre><code class="hljs verilog">n_output_gate_instance ::= [ name_of_gate_instance ] ( output_terminal { , output_terminal } , input_terminal ) <span class="hljs-keyword">buf</span> BUF_1(bufout1, bufout2, bufout3, bufin);<span class="hljs-keyword">not</span> NOT_1(out1, out2, in);</code></pre></li><li><p>三态门调用:</p><pre><code class="hljs verilog">enable_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , enable_terminal )<span class="hljs-keyword">bufif1</span> BF1(data_bus, data, enable);</code></pre></li><li><p>二个电阻</p><p>The instance declaration of a pullup or a pulldown source shall begin with one of the following keywords: <code>pullup</code> , <code>pulldown</code></p><pre><code class="hljs verilog">pull_gate_instance ::= [ name_of_gate_instance ] ( output_terminal )  <span class="hljs-keyword">pullup</span>   (<span class="hljs-keyword">strong1</span>)  p1 (neta), p2 (netb);In <span class="hljs-keyword">this</span> example, the  p1  <span class="hljs-keyword">instance</span> drives  neta  <span class="hljs-keyword">and</span> the  p2  <span class="hljs-keyword">instance</span> drives netb  <span class="hljs-keyword">with</span> <span class="hljs-keyword">strong</span> strength.</code></pre></li><li><p>注意: 门级原件的端口列表都固定好了，可以不用定义中间连接信号类型(wire)</p><hr></li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code class="hljs verilog"><span class="hljs-comment">// 门级建模实现最小项表达式</span><span class="hljs-comment">// F(a, b, c) = m1 + m2 + m3 + m6 + m7 = (!a)c + b</span><span class="hljs-keyword">module</span> zuixiaoxiang(out, a, b, c);    <span class="hljs-keyword">input</span> a, b, c;    <span class="hljs-keyword">output</span> out;    <span class="hljs-keyword">wire</span> s1, s2;    <span class="hljs-keyword">not</span> U1(s1, a);    <span class="hljs-keyword">and</span> U2(s2, s1, c);    <span class="hljs-keyword">or</span> U3(out, s2, b);<span class="hljs-keyword">endmodule</span></code></pre><p><img src="http://image.beenli.cn/global/20200405/ADk6SPgKBGVt.jpg?imageslim" srcset="/img/loading.gif" alt="门级"></p><h2 id="3、开关级建模"><a href="#3、开关级建模" class="headerlink" title="3、开关级建模"></a>3、开关级建模</h2><ol><li>MOS switches</li></ol><div class="table-container"><table><thead><tr><th><strong>cmos</strong></th><th><strong>pmos</strong></th><th><strong>nmos</strong></th></tr></thead><tbody><tr><td><strong>rcmos</strong></td><td><strong>rnmos</strong></td><td><strong>rpmos</strong></td></tr></tbody></table></div><blockquote><p>rmos : 代表晶体管导通时源漏有较高的阻抗(<code>impedance</code>)</p></blockquote><pre><code class="hljs verilog">The following example declares a <span class="hljs-keyword">pmos</span> switch:<span class="hljs-keyword">pmos</span>  p1 (out, data, control);The <span class="hljs-keyword">output</span> is  out , the data <span class="hljs-keyword">input</span> is  data , <span class="hljs-keyword">and</span> the control <span class="hljs-keyword">input</span> is control<span class="hljs-variable">.The</span> <span class="hljs-keyword">instance</span> name is  p1 .</code></pre><ol><li>Bidirectional pass switches(双向开关)</li></ol><div class="table-container"><table><thead><tr><th><strong>tran</strong></th><th><strong>tranif1</strong></th><th><strong>tranif0</strong></th></tr></thead><tbody><tr><td><strong>rtran</strong></td><td><strong>rtranif1</strong></td><td><strong>rtranif0</strong></td></tr></tbody></table></div><blockquote><p>The bidirectional pass switches shall not delay signals propagating through them. When tranif0, tranif1,rtranif0, or rtranif1 devices are turned off, they shall block signals; and when they are turned on, they shall pass signals. The tran and rtran devices cannot be turned off, and they shall always pass signals.(双向开关没有传播延时)</p></blockquote><pre><code class="hljs verilog">The following example declares an <span class="hljs-keyword">instance</span> of <span class="hljs-keyword">tranif1</span>:<span class="hljs-keyword">tranif1</span>  t1 (inout1,inout2,control);The bidirectional terminals are  inout1  <span class="hljs-keyword">and</span>  inout2 . The control <span class="hljs-keyword">input</span> is  control . The <span class="hljs-keyword">instance</span> name is t1 .</code></pre><hr><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><pre><code class="hljs verilog"><span class="hljs-comment">// 2输入与门</span><span class="hljs-comment">// time:2020-04-05</span><span class="hljs-keyword">module</span> and2_1(out, a, b);    <span class="hljs-keyword">input</span> a,b;    <span class="hljs-keyword">output</span> out;    <span class="hljs-keyword">wire</span> s1, s2;    <span class="hljs-keyword">supply0</span> Gnd;    <span class="hljs-keyword">supply1</span> Vdd;    <span class="hljs-keyword">pmos</span> U1(s1, Vdd, a);    <span class="hljs-keyword">pmos</span> U2(s1, Vdd, b);    <span class="hljs-keyword">nmos</span> U3(s1, s2, a);    <span class="hljs-keyword">nmos</span> U4(s2, Gnd, b);    <span class="hljs-keyword">pmos</span> U5(out, Vdd, s1);    <span class="hljs-keyword">nmos</span> U6(out, Gnd, s1);<span class="hljs-keyword">endmodule</span></code></pre><p><img src="http://image.beenli.cn/img/20200405/UWkPoOqPACnO.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>quarter II 综合不了，没办法直接看viewer。只能把书上的图扒来了。</p><hr><h4 id="终于找到了一款RTL级，gate级，开关级debugger和viewer的软件"><a href="#终于找到了一款RTL级，gate级，开关级debugger和viewer的软件" class="headerlink" title="终于找到了一款RTL级，gate级，开关级debugger和viewer的软件"></a>终于找到了一款RTL级，gate级，开关级debugger和viewer的软件</h4><p><a href="http://www.concept.de/SpiceVision.html" rel="external nofollow noreferrer">trainsistor-level debugger and viewer</a></p><p>但是目前下载不了，得找客服联系。不知有人有用过这款软件没有。有的话请你一定告诉我。</p><h2 id="Renference"><a href="#Renference" class="headerlink" title="Renference"></a>Renference</h2><div id="link"></div><p>[1] <a href="https://standards.ieee.org/standard/1364-2005.html" rel="external nofollow noreferrer">verilog-std-1364-2005</a></p><p>[2] <a href="">蔡觉平.2015.Verilog HDL 数字集成电路高级程序设计 31P</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gate-and-switch-level-modeling&quot;&gt;&lt;a href=&quot;#Gate-and-switch-level-modeling&quot; class=&quot;headerlink&quot; title=&quot;Gate-and-switch-level modeling&quot;&gt;
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="https://www.beenli.cn/categories/Digital-IC/"/>
    
      <category term="verilog" scheme="https://www.beenli.cn/categories/Digital-IC/verilog/"/>
    
    
      <category term="verilog" scheme="https://www.beenli.cn/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>图床+评论</title>
    <link href="https://www.beenli.cn/posts/7928fb24/"/>
    <id>https://www.beenli.cn/posts/7928fb24/</id>
    <published>2020-04-04T10:11:31.000Z</published>
    <updated>2020-04-25T15:15:06.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图床-评论"><a href="#图床-评论" class="headerlink" title="图床+评论"></a><center>图床+评论</center></h2><h2 id="1、什么是图床"><a href="#1、什么是图床" class="headerlink" title="1、什么是图床"></a>1、什么是图床</h2><blockquote><p>图床一般是指储存图片的服务器；就跟百度网盘差不多。只不过它是专门存储图片的。</p><p>有的也可以存储文件。有很多免费的图床。会赠送10G存储空间</p></blockquote><h2 id="2、为什么要用图床"><a href="#2、为什么要用图床" class="headerlink" title="2、为什么要用图床"></a>2、为什么要用图床</h2><ol><li>用图床很方便。服务器会生成一个外链。在互联网任何地方都能访问到</li><li>用图床访问速度很快。服务商会使用cdn加速</li><li>用图床可以节省本地空间。</li></ol><h2 id="3、七牛云图床的使用"><a href="#3、七牛云图床的使用" class="headerlink" title="3、七牛云图床的使用"></a>3、<a href="https://www.qiniu.com" rel="external nofollow noreferrer">七牛云</a>图床的使用</h2><ol><li>注册一个账号（需要身份认证）</li><li>创建一个存储空间</li></ol><center><img src="http://image.beenli.cn/img/20200404/vzoF3Gv83OLc.jpg?imageslim" srcset="/img/loading.gif" alt="mark" style="zoom:50%"></center><ol><li><p>注意空间名称是唯一。</p><p><code>访问控制</code>：选择私有：别人无法访问。如果是写博客或者公众号还是选择公开吧！</p><p>这样外链别人是可以看得到的。</p></li></ol><center><img src="http://image.beenli.cn/img/20200404/powS6CQubT69.jpg?imageslim" srcset="/img/loading.gif" alt="mark" style="zoom:50%"></center><ol><li>绑定备案的<code>域名</code></li></ol><p><img src="http://image.beenli.cn/img/20200404/YHkGJVGQk87W.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>​ 可以看到：如果不绑定自己的域名；系统30天后回收回。那么你之前的外链都失效了</p><p>​ 所以最好绑定自己的域名才上线。</p><ol><li><p>如果你只想试试，那么到这里你就可以结束了。开始体验图床。</p><p><img src="http://image.beenli.cn/img/20200404/uo7Np1Vojilw.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li><li><hr><p>上传完文件，然后返回。你就可以点击<code>操作</code>—-&gt;<code>更多</code>——-&gt;<code>复制外链</code></p><p>这时候你就可以直接从浏览器输入这个外链访问到你刚刚上传的文件。</p></li><li><p>这里推荐一个Windows平台<a href="http://mpic.lzhaofu.cn/" rel="external nofollow noreferrer">图床神器</a>；大概长这样。登陆上你之前注册的七牛云账号就可以使用了。</p><p><img src="http://image.beenli.cn/img/20200404/TdnAh5RKQ2V8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><h4 id="用图床上传图片遇到的坑："><a href="#用图床上传图片遇到的坑：" class="headerlink" title="用图床上传图片遇到的坑："></a>用图床上传图片遇到的坑：</h4><ol><li><p>由于七牛云默认生成的外链的是http的，有些浏览器会阻塞这种不安全资源。</p><p>我只好去修改协议。</p></li><li><p>这时遇到第二个坑。要使用https协议，你绑定的域名必须有证书。</p><p>我在网上到处找，买的证书太贵，划不来。免费的证书授权又太慢。</p><p>最后终于找到了一款免费证书ssl发放机构。<a href="https://freessl.cn/" rel="external nofollow noreferrer">freessl</a></p><p>其间要下载一个软件（keymanager)最后生成证书的过程很快几分钟就搞定。</p></li></ol><h2 id="4、Valine评论系统"><a href="#4、Valine评论系统" class="headerlink" title="4、Valine评论系统"></a>4、<a href="https://valine.js.org/" rel="external nofollow noreferrer">Valine</a>评论系统</h2><ol><li><p>hexo的很多主题都内嵌了这个系统，你只需要去<a href="https://www.leancloud.cn/" rel="external nofollow noreferrer">cleancloud</a>注册个账号获取id和key填入配置文件里面就能用</p></li><li><p>如果你想要邮件通知或者后台评论管理可以用这个插件<a href="https://github.com/panjunwen/Valine-Admin" rel="external nofollow noreferrer">Valine-Admin</a></p></li><li><p>项目部署的一定要注意smtp_pass是授权码或者QQ独立密码，不是登陆密码。</p></li><li><p>部署完成效果如下。</p><p><img src="http://image.beenli.cn/img/20200404/2DWW9TYEy7ih.png?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><p>​ <img src="http://image.beenli.cn/img/20200405/5DmMjJTBqhQS.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图床-评论&quot;&gt;&lt;a href=&quot;#图床-评论&quot; class=&quot;headerlink&quot; title=&quot;图床+评论&quot;&gt;&lt;/a&gt;&lt;center&gt;图床+评论&lt;/center&gt;&lt;/h2&gt;&lt;h2 id=&quot;1、什么是图床&quot;&gt;&lt;a href=&quot;#1、什么是图床&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="Software skills" scheme="https://www.beenli.cn/categories/Software-skills/"/>
    
    
      <category term="Hexo" scheme="https://www.beenli.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>testbench(1)</title>
    <link href="https://www.beenli.cn/posts/26241a85/"/>
    <id>https://www.beenli.cn/posts/26241a85/</id>
    <published>2020-04-04T02:38:11.000Z</published>
    <updated>2020-04-25T15:18:18.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Testbench-1"><a href="#Testbench-1" class="headerlink" title="Testbench(1)"></a><center>Testbench(1)</center></h2><h3 id="1、testbench的结构"><a href="#1、testbench的结构" class="headerlink" title="1、testbench的结构"></a>1、testbench的结构</h3><p><img src="https://image.beenli.cn/img/20200404/5eSun5gqIQrU.png?imageslim" srcset="/img/loading.gif" alt="testbench"></p><ol><li><p>testbench没有<code>输入输出</code>接口</p></li><li><p>测试模块只负责对<code>待测试系统接口</code>提供<code>激励信号</code>;并监控<code>输出</code></p></li><li><p>testbench代码<code>不需要可综合</code>，即不被实现成电路</p></li><li><p>产生适当的激励并达到<code>覆盖率</code>要求</p><hr></li></ol><h3 id="2、测试激励的描述方式"><a href="#2、测试激励的描述方式" class="headerlink" title="2、测试激励的描述方式"></a>2、测试激励的描述方式</h3><ol><li><p><strong>信号的初始化</strong></p><pre><code class="hljs verilog">第一种: <span class="hljs-keyword">initial</span> 初始化<span class="hljs-keyword">initial</span> a = <span class="hljs-number">0</span>;第二种: 定义信号时初始化<span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">4'b1010</span>;</code></pre></li><li><p><strong>延迟控制</strong></p><ol><li><p>延迟语句</p><ul><li><p>外部时间控制</p><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> #<span class="hljs-number">5</span> a = b;(等待<span class="hljs-number">5</span>tick后计算右端的值并赋值给左边👈)等价于:<span class="hljs-keyword">initial</span><span class="hljs-keyword">begin</span>    #<span class="hljs-number">5</span>;    a=b;<span class="hljs-keyword">end</span></code></pre></li><li><p>内部时间控制</p><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> a = #<span class="hljs-number">5</span> b;(先计算右端的值，等待<span class="hljs-number">5</span>tick后再把值赋给左边👈)等价于<span class="hljs-keyword">initial</span><span class="hljs-keyword">begin</span>temp = b;#<span class="hljs-number">5</span>;a = temp;<span class="hljs-keyword">end</span></code></pre><blockquote><p>验证程序如下：</p></blockquote><p><img src="http://image.beenli.cn/img/20200405/Ds3tBF8spFY8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><img src="http://image.beenli.cn/img/20200405/zS4s5qx25VhP.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>可以清楚地看到：</p><p>​ 第一种延时语句，在0-5tick之间只要b变化了,那么第五tick</p><p>时刻a被赋予的值就是b第五时刻的值。</p><p>​ 而第二种延时语句：b的值在0时刻已经定好了，不管</p><p>b在这期间怎么变化，a最终得到的是b在0时刻的值。</p></li></ul></li><li><p>事件语句</p><blockquote><p><strong>@(&lt;事件表达式&gt;);</strong></p><p><strong>@(&lt;事件表达式&gt;)行为语句;</strong></p></blockquote><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span><span class="hljs-keyword">begin</span># <span class="hljs-number">10</span>@(<span class="hljs-keyword">posedge</span> en) in = ~in; <span class="hljs-comment">//en的👆上升沿到来时,in取反</span><span class="hljs-keyword">end</span></code></pre><p>事件语句<code>@</code>必须等指定事件到来才执行</p></li><li><p>等待语句</p><blockquote><p><strong>wait(&lt;条件表达式&gt;) 行为语句</strong></p></blockquote><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>#<span class="hljs-number">5</span> cnt=cnt+<span class="hljs-number">1'b1</span>;<span class="hljs-keyword">initial</span><span class="hljs-keyword">wait</span>(cnt == <span class="hljs-number">4'b1111</span>) <span class="hljs-built_in">$display</span>(<span class="hljs-built_in">$time</span>,,,<span class="hljs-string">"cnt = %b"</span>, cnt);<span class="hljs-keyword">end</span></code></pre><p>等待语句只有条件为真时才执行。</p><p><img src="http://image.beenli.cn/global/20200404/xTxXL9tRH35N.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到第0时刻cnt = 0</p><p>第5时刻cnt = 1</p><p>以此类推；直到第75时刻 cnt = 15</p><p>再过10tick 就终止仿真了。总过时常85tick</p></blockquote></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Testbench-1&quot;&gt;&lt;a href=&quot;#Testbench-1&quot; class=&quot;headerlink&quot; title=&quot;Testbench(1)&quot;&gt;&lt;/a&gt;&lt;center&gt;Testbench(1)&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;1、testbenc
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="https://www.beenli.cn/categories/Digital-IC/"/>
    
      <category term="verilog" scheme="https://www.beenli.cn/categories/Digital-IC/verilog/"/>
    
    
      <category term="testbench" scheme="https://www.beenli.cn/tags/testbench/"/>
    
  </entry>
  
  <entry>
    <title>单链表翻转</title>
    <link href="https://www.beenli.cn/posts/39c22857/"/>
    <id>https://www.beenli.cn/posts/39c22857/</id>
    <published>2020-03-31T15:51:58.000Z</published>
    <updated>2020-04-25T15:23:37.806Z</updated>
    
    <content type="html"><![CDATA[<h5 id="单链表翻转"><a href="#单链表翻转" class="headerlink" title="单链表翻转"></a><center>单链表翻转</center></h5><h6 id="解法一、拆卸-拼接"><a href="#解法一、拆卸-拼接" class="headerlink" title="解法一、拆卸+拼接"></a><code>解法一</code>、拆卸+拼接</h6><pre><code class="hljs c"><span class="hljs-function">struct ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(struct ListNode* head)</span></span>{    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNOde</span> *<span class="hljs-title">newHead</span> = <span class="hljs-title">NUll</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> = <span class="hljs-title">NULL</span>;</span>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>) {        <span class="hljs-comment">//1. 对之前的链表做头删</span>        node = head; <span class="hljs-comment">// node始终指向head的前驱</span>        head = head-&gt;next;        <span class="hljs-comment">//2. 对新链表做头插</span>        node-&gt;next = newHead;        newHead = node;    }    <span class="hljs-keyword">return</span> newHead;}</code></pre><a id="more"></a><p><img src="/assets/photoes/reverse_linked_list.jpg" srcset="/img/loading.gif" style="zoom:80%"></p><hr><h6 id="解法二、三指针法"><a href="#解法二、三指针法" class="headerlink" title="解法二、三指针法"></a><code>解法二</code>、三指针法</h6><pre><code class="hljs c"><span class="hljs-function">struct ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(struct ListNode* head)</span> </span>{<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 如果为NULL，那么后指针越界。</span><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;}<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p0</span> = <span class="hljs-title">NULL</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p1</span> = <span class="hljs-title">head</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p2</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">NULL</span>) {p1-&gt;next = p0;p0 = p1; p1 = p2;<span class="hljs-keyword">if</span> (p2 != <span class="hljs-literal">NULL</span>) {p2 = p2-&gt;next;}}<span class="hljs-keyword">return</span> p0;}</code></pre><p><img src="/assets/photoes/three_pointer.jpg" srcset="/img/loading.gif" style="zoom:80%"></p><blockquote><p><a href="https://blog.csdn.net/qq_42351880/article/details/88637387" rel="external nofollow noreferrer">参考博客</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;单链表翻转&quot;&gt;&lt;a href=&quot;#单链表翻转&quot; class=&quot;headerlink&quot; title=&quot;单链表翻转&quot;&gt;&lt;/a&gt;&lt;center&gt;单链表翻转&lt;/center&gt;&lt;/h5&gt;&lt;h6 id=&quot;解法一、拆卸-拼接&quot;&gt;&lt;a href=&quot;#解法一、拆卸-拼接&quot; class=&quot;headerlink&quot; title=&quot;解法一、拆卸+拼接&quot;&gt;&lt;/a&gt;&lt;code&gt;解法一&lt;/code&gt;、拆卸+拼接&lt;/h6&gt;&lt;pre&gt;&lt;code class=&quot;hljs c&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;struct ListNode *&lt;span class=&quot;hljs-title&quot;&gt;reverseList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(struct ListNode* head)&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ListNOde&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;newHead&lt;/span&gt; = &lt;span class=&quot;hljs-title&quot;&gt;NUll&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ListNode&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;node&lt;/span&gt; = &lt;span class=&quot;hljs-title&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (head != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;) {
        &lt;span class=&quot;hljs-comment&quot;&gt;//1. 对之前的链表做头删&lt;/span&gt;
        node = head; &lt;span class=&quot;hljs-comment&quot;&gt;// node始终指向head的前驱&lt;/span&gt;
        head = head-&amp;gt;next;

        &lt;span class=&quot;hljs-comment&quot;&gt;//2. 对新链表做头插&lt;/span&gt;
        node-&amp;gt;next = newHead;
        newHead = node;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; newHead;
}&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Data Structure" scheme="https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Data-Structure/"/>
    
    
      <category term="C" scheme="https://www.beenli.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>iverilog</title>
    <link href="https://www.beenli.cn/posts/bc753b52/"/>
    <id>https://www.beenli.cn/posts/bc753b52/</id>
    <published>2020-03-31T11:57:08.000Z</published>
    <updated>2020-04-28T09:39:08.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim-iverilog-gtkwave"><a href="#vim-iverilog-gtkwave" class="headerlink" title="vim + iverilog + gtkwave "></a><center>vim + iverilog + gtkwave</center></h2><h3 id="1、What-is-Icarus-Verilog"><a href="#1、What-is-Icarus-Verilog" class="headerlink" title="1、What is Icarus Verilog"></a>1、What is Icarus Verilog</h3><blockquote><p><em>Icarus Verilog</em> is a <strong>Verilog simulation and synthesis</strong> tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called <em>vvp assembly</em>. This intermediate form is executed by the <code>vvp</code>command. For synthesis, the compiler generates netlists in the desired format.<a href="#refer-anchor"><sup>1</sup></a></p></blockquote><p>​ 从官网的描述我们可以看到: 它是一个<code>仿真器</code>和<code>综合器</code>。</p><p>​ 有趣的是：开发者是一名软件工程师</p><p>​ a software engineer specializing in device drivers and embedded systems</p><h3 id="2、Why-we-choose-Icarus-Verilog"><a href="#2、Why-we-choose-Icarus-Verilog" class="headerlink" title="2、Why we choose Icarus Verilog"></a>2、Why we choose Icarus Verilog</h3><ol><li>软件非常小，没有图形界面。跑跑小的程序足够了</li><li>软件扩展性特别好。我现在还没有去探索。<a href="http://iverilog.icarus.com/page/plug-ins" rel="external nofollow noreferrer">详情见</a></li><li>软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的</li></ol><h3 id="3、How-to-use-it"><a href="#3、How-to-use-it" class="headerlink" title="3、How to  use it"></a>3、How to use it</h3><ol><li><p>像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码</p><p><img src="vim_iverilog.jpg" srcset="/img/loading.gif" alt="Verilog"></p></li><li><p>然后在编辑器里一键运行脚本，或者在终端运行。</p><blockquote><p>终端主要记住几个命令即可: (<a href="">后面很会详细说明</a>)</p></blockquote><pre><code class="hljs c">iverilog -o filename filename.v   <span class="hljs-comment">// 编译源文件 【-o 指定生成的文件名称】</span>vvp filename<span class="hljs-comment">// 仿真testbench</span>gtkwave filename.vcd<span class="hljs-comment">// 查看仿真的波形图</span></code></pre></li></ol><h3 id="4、Instance-case"><a href="#4、Instance-case" class="headerlink" title="4、Instance case"></a>4、Instance case</h3><ol><li><blockquote><p>编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)</p></blockquote><pre><code class="hljs verilog"><span class="hljs-comment">// 模8计数器。存储为count8.v</span><span class="hljs-keyword">module</span> count8(clk, rst_n, cnt);    <span class="hljs-keyword">input</span> clk, rst_n;    <span class="hljs-keyword">output</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cnt;    <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cnt;    <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n)    <span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!rst_n)    cnt &lt;= <span class="hljs-number">4'b0000</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">3</span>])    cnt &lt;=<span class="hljs-number">4'b0000</span>;<span class="hljs-keyword">else</span>    cnt &lt;= cnt + <span class="hljs-number">1'b1</span>;    <span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></li><li><blockquote><p>编译一下</p></blockquote><pre><code class="hljs bash">iverilog  -o counter8 counter8.v</code></pre><p>​ <img src="synthesize.png" srcset="/img/loading.gif" alt="image-20200403162524369"></p><p>​ 可以看到已经编译成功，生成了<code>count8</code>文件。即上述命令-o后面指定的。</p></li><li><blockquote><p>如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。</p></blockquote><p><img src="RTLviewer.png" srcset="/img/loading.gif" alt="image-20200403163232250"></p></li><li><blockquote><p>编写测试代码</p></blockquote><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">include</span> "count8.v"</span><span class="hljs-meta">`<span class="hljs-meta-keyword">timescale</span> 1ns/1ns</span><span class="hljs-keyword">module</span> count8_tb;    <span class="hljs-comment">// 数据结构声明</span>    <span class="hljs-keyword">reg</span> clk;    <span class="hljs-keyword">reg</span> rst_n;    <span class="hljs-keyword">wire</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cnt;    <span class="hljs-comment">// 实例化待测试模块</span>    count8 U1(clk, rst_n, cnt);    <span class="hljs-comment">// 测试激励信号</span>    <span class="hljs-keyword">always</span>#<span class="hljs-number">50</span> clk = ~ clk;    <span class="hljs-keyword">initial</span>    <span class="hljs-keyword">begin</span>clk = <span class="hljs-number">1'b0</span>;rst_n = <span class="hljs-number">1'b0</span>;#<span class="hljs-number">20</span> rst_n = <span class="hljs-number">1'b0</span>;#<span class="hljs-number">200</span> rst_n = <span class="hljs-number">1'b1</span>;    <span class="hljs-keyword">end</span>    <span class="hljs-comment">// 输出响应</span>    <span class="hljs-keyword">initial</span>    <span class="hljs-keyword">begin</span><span class="hljs-keyword">wait</span>(cnt == <span class="hljs-number">4'b1000</span>)<span class="hljs-built_in">$display</span>(<span class="hljs-built_in">$time</span>,,,<span class="hljs-string">"cnt = %b"</span>, cnt);    <span class="hljs-built_in">$dumpfile</span>(<span class="hljs-string">"count8_tb.vcd"</span>); <span class="hljs-comment">// 很关键，把仿真的数据存储到文件,待会波形图要用</span>    <span class="hljs-built_in">$dumpvars</span>(<span class="hljs-number">0</span>, count8_tb); <span class="hljs-comment">// 设置要观察的变量</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></li><li><blockquote><p>编译，仿真，生成波形图</p></blockquote><pre><code class="hljs bash">iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd</code></pre><p><img src="simulate.png" srcset="/img/loading.gif" alt="image-20200403170800780"></p><p>注意:</p><ol><li><p>由于仿真程序没有设定停止时间。程序会一直执行。</p></li><li><p>如果你想自动停止（可以在testbench上加上<code># 500$stop</code>,那么程序仿真500个tick就停止)</p></li><li><p>如果你没有加停止指令。只能手动停止<code>ctrl+c</code>然后你可以打印当前仿真的时间。如果不够</p><p>你可以继续仿真。如果可以了就<code>finish</code></p></li><li><p>最后用<code>gtkwave</code> 查看你刚刚仿真生成的<code>count8_tb.vcd</code>文件。</p></li></ol><p><img src="gtkwave.png" srcset="/img/loading.gif" alt="image-20200403171326769"></p></li><li><blockquote><p>如果你喜欢用<code>modelsim</code>也可以。</p></blockquote><p>也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。</p><p><a href="https://wenku.baidu.com/view/cd93f34ecf84b9d528ea7a95.html" rel="external nofollow noreferrer">具体教程见</a></p><p><img src="modelsim.png" srcset="/img/loading.gif" alt="image-20200403171721915"></p></li></ol><div id="refer-anchor"></div><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p>[1] <a href="http://iverilog.icarus.com/" rel="external nofollow noreferrer">iverilog</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim-iverilog-gtkwave&quot;&gt;&lt;a href=&quot;#vim-iverilog-gtkwave&quot; class=&quot;headerlink&quot; title=&quot;vim + iverilog + gtkwave &quot;&gt;&lt;/a&gt;&lt;center&gt;vim + iverilo
      
    
    </summary>
    
    
      <category term="Digital IC" scheme="https://www.beenli.cn/categories/Digital-IC/"/>
    
      <category term="开发工具" scheme="https://www.beenli.cn/categories/Digital-IC/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="verilog" scheme="https://www.beenli.cn/tags/verilog/"/>
    
  </entry>
  
</feed>
