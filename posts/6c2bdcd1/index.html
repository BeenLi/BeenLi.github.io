
  <script type="text/javascript">
    (function () {
      var dayStr = '2020/04/04';
      if (/^\d{1,2}\/\d{1,2}$/.test(dayStr)) {
        dayStr = new Date().getFullYear() + '/' + dayStr;
      }
      if (!/^\d{4}\/\d{1,2}\/\d{1,2}$/.test(dayStr)) {
        return ;
      }
      var day = new Date(dayStr);
      var now = new Date();
      var isMemorialDay = now.getFullYear() === day.getFullYear() && now.getMonth() === day.getMonth() && now.getDate() === day.getDate();
      if (isMemorialDay) {
        if (document.all) {
          window.style = 'html {     -webkit-filter: grayscale(100%); /* webkit */     -moz-filter: grayscale(100%); /* firefox */     -ms-filter: grayscale(100%); /* ie9 */     -o-filter: grayscale(100%); /* opera */     filter: grayscale(100%);     filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray; /* ie9- */   }';
          document.createStyleSheet('javascript:style');
        } else {
          var style = document.createElement('style');
          style.type = 'text/css';
          style.innerHTML = 'html {     -webkit-filter: grayscale(100%); /* webkit */     -moz-filter: grayscale(100%); /* firefox */     -ms-filter: grayscale(100%); /* ie9 */     -o-filter: grayscale(100%); /* opera */     filter: grayscale(100%);     filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray; /* ie9- */   }';
          document.getElementsByTagName('HEAD').item(0).appendChild(style);
        }
      }
    })();
  </script>
  <!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="http://image.beenli.cn/img/20200429/F7MQvrUt2Q4K.png?imageslim"><link rel="icon" type="image/png" href="http://image.beenli.cn/img/20200429/F7MQvrUt2Q4K.png?imageslim"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="A senior in JLU majoring in EE/CS. I am interested in Domain-specific accelerator based on RISC-V."><meta name="author" content="Wan Li"><meta name="keywords" content="digital IC, ASIC, Linux, Vim, python, 电子狗, 程序猿"><title>Unprivileged Spec(1)--RV32I - WanLi&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1791347_g19vm5ywni.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"www.beenli.cn",root:"/",version:"1.8.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!0,baidu:"e003c704a60a6fe8b1437118b71fea30",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null},tajs:null}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="WanLi's blog" type="application/atom+xml">
</head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>WanLi's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:" rel="external nofollow noreferrer">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(http://image.beenli.cn/img/20200426/ytR82GE0j1B5.jpg?imageslim) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Unprivileged Spec(1)--RV32I"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-09-30 09:01" pubdate>Wednesday, September 30th 2020, 9:01 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 49 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Unprivileged Spec(1)--RV32I</h1><p class="note note-info">本文最后更新于：Wednesday, September 30th 2020, 8:18 pm</p><div class="markdown-body"><center>RV32I Base Integer Instruction Set</center><h1 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1 Preface"></a>1 Preface</h1><blockquote><ul><li>RV32I是为了足够成为编译器目标并能支持现代操作系统环境而设计的一个基本整数指令集。它也为了减少硬件实现的最小需求而设计。RV32I包含40个独立的指令，尽管一些简单的实现可能用单一的系统硬件指令（a single <a href="#system">SYSTEM hardware instruction</a>)代替ECALL/EBREAK指令，它总是捕获异常(always traps)并且可能将FENCE指令实现为NOP，以减少指令数到38个。RV32I能够模拟几乎任何的ISA扩展（除了A扩展，它需要额外硬件支持原子操作(atomicity）</li></ul><ul><li>在实践中，包含机器模式特权架构的硬件实现将需要9个CSR指令。</li></ul><ul><li>基本整数指令集的子集也许对于教学目的很有用(pedagogical purposes), 但是基础已经被定义，对实现其子集的真正的硬件除了忽略非对齐内存访问并把所有的SYSTEM instruction视为单一的异常(single trap)，我们不应该有什么其它的动机。</li></ul><hr><p>关于RV32I的大多注释也适用于RV64I base。</p></blockquote><h1 id="2-Programmer’s-Model"><a href="#2-Programmer’s-Model" class="headerlink" title="2 Programmer’s Model"></a>2 Programmer’s Model</h1><blockquote><p>对于RV32I非特权状态一共有32个寄存器(都是32位宽，i.e. ,XLEN=32)：<code>x0~x31</code>;x0被硬编码到0。另外31个寄存器保存的值可以被解释为：Ⅰ、布尔值的集合，Ⅱ、补码的有符号二进制整数，Ⅲ、无符号二进制整数</p><p>有一个额外的非特权寄存器，<code>pc</code>(program counter)：保存当前指令的地址</p></blockquote><ul><li>在Base Integer ISA中，没有指定的栈指针或者子例程返回地址链接寄存器(link register)；指令编码允许任何寄存器被用于这个目的；但是，标准软件调用惯例(calling convention)使用寄存器<code>x1</code>保存调用的返回地址，<code>x5</code>作为备用链接寄存器。标准调用例程使用<code>x2</code>作为栈指针(stack pointer)</li><li>硬件可以使用<code>x1</code>或<code>x2</code>来加速函数调用和返回(因为可以尽早解码)；<a href="#jal">详情见<code>JAL</code>和<code>JALR</code>指令</a></li><li>可选的压缩16-bit指令格式基于这样的假设设计的：<code>x1</code>：返回地址寄存器；<code>x2</code>:栈指针。使用其他约定的软件将正常运行，但可能有较大的代码大小。</li></ul><hr><p><strong><font color="red">notes：</font></strong></p><ul><li>可用架构寄存器(available architectural registers)的数量能够对<code>代码大小</code>，<code>性能</code>，<code>能耗</code>产生重大影响。尽管16个寄存器对于运行编译代码的整数ISA来说是足够的，但是在长度为16位使用3-address格式的指令中编码拥有16个寄存器完整的ISA是不可能的。(⭐PS:16个寄存器，address至少4位，三地址就12位，那么只剩下4位区分不同的指令了,即最多16条不同的指令)。</li><li>尽管2-address是可能的。但它增加指令条数并且降低效率。我们想要避免立即数指令的大小来简化硬件实现，一旦32-bit的指令大小被采用，支持32个整数寄存器就很显而易见了。一个更大数量的整数寄存器也有助于提高高性能代码的性能，可广泛使用<code>循环展开</code>（loop unrolling)、<code>软件流水线</code>(software pipelining)和<code>缓存平铺</code>(cache tiling)。❓</li><li>基于上面这些原因，我们为基础ISA选择了一个常规大小（conventional size)——32个整数寄存器。动态寄存器使用趋向于被一些经常访问的寄存器主宰，并且<code>regfile</code>(寄存器堆)的实现可被优化以减少频繁访问寄存器的访问能量(access energy)。</li><li>可选的16位压缩指令格式绝大部分只使用8个寄存器，因此能提供稠密的指令编码(dense instruction encoding),但是如果想要的话，额外的指令集扩展能支持更大的寄存器空间(要么扁平的要么分层次的)。</li></ul><h1 id="3-Base-Instruction-Formats"><a href="#3-Base-Instruction-Formats" class="headerlink" title="3 Base Instruction Formats"></a>3 Base Instruction Formats</h1><blockquote><p>有4种核心的指令格式：R/I/S/U。指令长度都是32位，并且必须在内存中以4字节为边界对齐。指令地址非对齐的异常，常常是由于分支的发生(taken branch)或者非条件跳转的目标地址不是4字节对齐。</p></blockquote><ul><li><p>对于解码一个保留指令的行为是没有规定的(unspecified)</p></li><li><p>RISC-V ISA保持源寄存器(<code>rs1</code>和<code>rs2</code>)和目标寄存器(<code>rd</code>)的位置在所有指令格式中相同以简化解码。除了使用在CSR指令中的5bit的立即数，立即数总是<code>sign-extended</code>，通常是打包到指令中最左边的可用位，这样分配以减少硬件的复杂程度。特别是，对于所有立即数的符号位总是在最高位(也就是Ins[31])来加速符号扩展电路。</p><p><img src="https://image.beenli.cn/img/20200930/F4vpswvD8a17.jpg?imageslim" srcset="/img/loading.gif" alt="mark"><br><strong><i></i></strong></p><center><strong><i>imm[x]指的是当前位在扩展成32位立即数中的位置</i></strong></center><p></p><ul><li>实际应用中，大部分立即数要么很小，要么需要所有的位数(XLEN bits)。我们选择非对称立即数分割：常规指令中立即数占12bits;特殊的 load-upper-immediate 指令中立即数占20bits。这样做是为了给常规指令更多的opcode空间。</li></ul></li></ul><h1 id="4-Immediate-Encoding"><a href="#4-Immediate-Encoding" class="headerlink" title="4 Immediate Encoding"></a>4 Immediate Encoding</h1><blockquote><p>指令格式还有两个变种(variants)：B/J，它们基于立即数的处理衍生出来。</p></blockquote><p><img src="https://image.beenli.cn/img/20200930/NR78wxr6Nbb8.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>S和B仅有的区别：在B格式中12bit立即数域乘以2用于编码分支偏移。而不是像传统做法那样，将指令编码中的所有立即数位用硬件左移一位,中间的位数(imm[10:1])和符号位保留在固定位置，而S格式中的最低位(inst[7])在B格式中编码一个高阶位。</li><li>U和J的仅有区别：U要向左移12位；而J只用移动1位。在U和J指令立即数中指令的位置尽量跟其他格式的指令或者它们互相重叠。</li></ul><p><img src="https://image.beenli.cn/img/20200930/CoSeYfK4wdG4.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h1 id="5-Computational"><a href="#5-Computational" class="headerlink" title="5 Computational "></a>5 <a name="compute">Computational</a></h1><blockquote><p>大多数的<code>整数算术指令</code>(Integer computational instruction)对保存在整数寄存器中的<code>XLEN</code>位的值进行操作。整数计算指令要么被编码为使用I格式的寄存器-立即数操作；要么使用R格式的寄存器-寄存器操作。对于这两种类型指令的目的寄存器都是<code>rd</code>。没有整型计算指令会导致算术异常</p></blockquote><ul><li><p>基本指令集不包括对整数算术运算上做<code>溢出检查</code>(overflow checks)支持的特殊指令集。因为许多溢出检查能够更便宜地(cheaply)使用RISC-V分支来实现</p></li><li><p>对<code>无符号加法</code>的溢出检查仅仅需要在加法指令后加上一条额外的分支指令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add t0,t1,t2<br>blut t0, t1, overflow<br></code></pre></td></tr></tbody></table></figure></li><li><p>对于有符号加法：如果一个操作数的符号已知，溢出检查仅需要加法之后的一个分支（覆盖了带有立即数操作数的常见加法情形）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addi t0, t1, +imm<br>blt t0, t1, overflow<br></code></pre></td></tr></tbody></table></figure></li><li><p>对于常规的<code>有符号加法</code>，加法之后需要三条额外的指令。利用当且仅当另一个操作数为负时，该和应小于其中一个操作数的观察。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add t0, t1, t2<br>slti t3, t2, 0<br>slt t4, t0, t1<br>bne t3, t4, overflow<br></code></pre></td></tr></tbody></table></figure></li><li>在RV64I中，32位有符号的加法溢出可以通过比较ADD和ADDW操作的结果来进一步优化。(ADDW肯定不会溢出)</li></ul><h2 id="Register-Immediate"><a href="#Register-Immediate" class="headerlink" title="Register-Immediate"></a><a name="arith">Register-Immediate</a></h2><p><img src="https://image.beenli.cn/img/20200930/9lWr2QpMilov.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ol><li><p><code>ADDI</code>：将12位立即数符号扩展后与<code>rs1</code>中的值相加，算术溢出忽略，结果的低32位存到<code>rd</code>寄存器中。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* 两条指令等效 */<br>ADDI rd, rs1, 0<br>MV rd , rs1(汇编伪指令：将rs1中的值复制给rd)<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>SLTI</code>(set less than immediate): 当寄存器<code>rs1</code>中的值小于立即数（俩者都视为有符号数)，将寄存器<code>rd</code>置为1；否则置0。<code>SLTIU</code>: 功能一样，但是把比较的对象视为无符号数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* 两条指令等效 */<br>SLTIU rd, rs1, 1(当rs1等于0,rd为1,否则为0)<br>SEQZ rd, rs<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>ANDI, ORI, XORI</code>: 三个逻辑运算符，分别对rs1和立即数执行<code>按位</code>(bitwise)的与，或，异或运算。</p><h2><a href="#" class="headerlink"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* 两条指令等效 */<br>XORI rd, rs1, -1(-1的补码为全1)<br>NOT rd, rs(将rs各位取反赋值给rd)<br></code></pre></td></tr></tbody></table></figure></h2><p><img src="https://image.beenli.cn/img/20200930/ohbIXFmmows6.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></li></ol><blockquote><p><code>移位</code>被编码一种特殊的I类型指令格式。</p><ul><li>被移位的操作数为<code>rs1</code>；移位的位数被编码在立即数域的低五位上。</li><li>👉移类型被编码在第30位上；</li><li><code>SLLI</code>(shift left logical)：0被移动到低位</li><li><code>SRLI</code>: 0被移动到高位</li><li><code>SRAI</code>: (shift right arithmetic): 原符号位复制到空出的高位</li></ul></blockquote><hr><p><img src="https://image.beenli.cn/img/20200930/HH9oFeg4OyQC.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ol><li><code>LUI</code>(load upper immediate): 用于构建32位常数并使用U格式指令。把U-immediate的值放在目的寄存器的高20位，其它低位用0填充。</li><li><code>AUIPC</code>(add upper immediate to pc)：用于构建与pc相关的地址，并使用U格式指令。形成32位的偏移(高20位来自立即数，低12位用0填充)，把这个偏移加到AUIPC指令的地址上，然后把结果放到<code>rd</code>中。（rd = pc-4+im)<ul><li>AUIPC指令支持<code>双指令序列</code>(two-instruction sequences)访问相对PC的任意偏移(for both control-flow transfers and data accesses)</li><li>一个AUIPC和JALR中12位偏移的组合能够转换控制给任意32位的PC相对地址(PC-relative address)，而一个ALIPC加上一个常规load和store指令中的12位立即数偏移能供访问任意32位PC相对地址的数据地址(PC-relative data address)</li><li>当前PC值可以通过设置立即数为0获得，尽管JAL+4指令也能获得本地PC(JAL下一指令)，它可能在简单微架构中造成流水线崩溃，或者在更复杂的微架构中污染BTB(❓)</li></ul></li></ol><h2 id="Register-Register"><a href="#Register-Register" class="headerlink" title="Register-Register"></a>Register-Register</h2><blockquote><p>RV32I定义了几个R型算术运算。所有的运算都读取<code>rs1</code>,<code>rs2</code>寄存器的值作为源操作数，把结果写回<code>rd</code>寄存器。<code>funct7</code>和<code>funct3</code>域选择合适的运算。</p></blockquote><p><img src="https://image.beenli.cn/img/20200930/cdJ8aBabLVTk.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><a href="#arith">意义同👆。</a></p><h2 id="NOP-Instruction"><a href="#NOP-Instruction" class="headerlink" title="NOP Instruction"></a>NOP Instruction</h2><p><img src="https://image.beenli.cn/img/20200930/QOhQFMEFTYs1.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>NOP指令：不会改变任何架构上可见的状态。出来推进PC，增加任何适用的性能计数器。NOP被编码为`ADDI x0, x0, 0</li><li>NOPs可以被用来对齐代码段与重要的微架构地址边界。或者为内联代码修改(inline code modification)流出空间。尽管有许多可能的方法去编码NOP,我们使用了规范的NOP编码来允许微架构优化以及更易读的反汇编输出。其它的NOP编码可以用作指示指令(HINT instruction)</li><li>选择ADDI作为NOP编码是因为它在跨一系列系统执行时最可能占用最少的资源;除此之外，该指令仅读取一个寄存器。并且，一个ADDI功能单元在超标量设计中更容易可用，因为adds是最常见的运算</li><li>地址生成单元可以使用相同的硬件够执行ADDI，该硬件被用于base+offset地址计算，而register-register ADD，逻辑运算或移位运算操作需要额外的硬件。</li></ul><h1 id="6-Control-Transfer"><a href="#6-Control-Transfer" class="headerlink" title="6 Control Transfer"></a>6 Control Transfer</h1><blockquote><p>RV32I提供两种控制转义指令：<code>无条件跳转</code>，<code>条件分支</code></p><p>RV32I控制转义指令没有架构上可见的<code>延迟槽</code>(delay slot)</p></blockquote><h2 id="Unconditional-Jumps"><a href="#Unconditional-Jumps" class="headerlink" title="Unconditional Jumps"></a>Unconditional Jumps</h2><p><img src="https://image.beenli.cn/img/20200930/qCmY8sLbKGDK.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><code>JAL</code>(jump and link)指令使用<code>J-type</code>格式，J-immediate以两字节的倍数编码一个有符号偏移。(in multiple of 2 bytes；则该偏移要乘以2)。偏移符号扩展，然后加上当前指令的地址形成<code>跳转目标地址</code>(jump target address)。Jumps因此能够访问±1 MiB范围。JAL存储下一条指令的地址(pc+4)到<code>rd</code>；</p><p>标准软件调用约定使用x1作为返回地址寄存器，x5作为备用链接寄存器。</p><p><img src="https://image.beenli.cn/img/20200930/VUjOV9BMhinO.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><code>JALR</code>(jump and link register)：间接跳转指令：使用<code>I-type</code>，目标地址通过把符号扩展的12比特立即数加到rs1上，然后置结果的最低位为0获得；下一条指令的地址(pc+4)写到寄存器rd。如果结果不需要，可以把<code>x0</code>当作目的寄存器。</p><p>如果目标地址没有对齐四字节边界，jar和jarl指令将产生<code>指令地址非对齐</code>异常。</p><p>返回地址<code>预测栈</code>(prediction stack)是高性能取值单元的一个常见特点，要求准确检测用于过程调用和返回的指令是有效的。</p><ul><li>对于RISC-V,关于指令使用的线索通过寄存器号的使用被简单的编码。</li><li>JAL指令应该把返回地址压进返回地址栈(RAS)中，当且仅当<code>rd = x1/x5</code>；</li><li>JALR指令应该push/pop a RAS</li></ul><p><img src="https://image.beenli.cn/img/20200930/WC8l9YmmyroI.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><center>link is true when the register is either x1 or x5</center><h2 id="Conditional-Branches"><a href="#Conditional-Branches" class="headerlink" title="Conditional Branches"></a>Conditional Branches</h2><blockquote><p>所有分支指令使用<code>B-type</code>格式。</p><p>12比特的立即数用2字节的倍数编码有符号偏移</p><p>立即数符号扩展后与当前指令地址相加，可以访问的地址范围：<code>±4 KiB</code></p></blockquote><p><img src="https://image.beenli.cn/img/20200930/PR0CJpoojIFU.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><code>BEQ</code>:branch equal;&nbsp;&nbsp;<code>BNE</code>: branch not equal;&nbsp;&nbsp;<code>BLT</code>: branch less than;&nbsp;&nbsp;<code>BGE</code>: branch greater than;</p><ul><li>应该对软件进行优化，使顺序代码路径成为最常见的路径，并将较不经常使用的分支代码路径置于行外。软件还应该假设，至少在第一次遇到分支时，预测向后跳转的分支发生，向前跳转的分支不发生。动态预测器应该快速学习任何可预测的分支行为。</li><li>不像一些其它的架构，RISC-V中对于<code>非条件分支</code>应该总是使用<code>jump</code>(JAL with rd=x0)指令而不是条件总是满足的有条件分支指令</li><li>RISC-V跳转也是与pc相关的，并且比分支支持更大的偏置范围，而且不会污染条件分支预测表。</li></ul><h1 id="7-Load-and-Store-😳"><a href="#7-Load-and-Store-😳" class="headerlink" title="7 Load and Store(😳)"></a>7 Load and Store(😳)</h1><blockquote><p>RV32I是一个装载和存储架构：只有<code>load</code>和<code>store</code>指令能够访问内存，算术指令只能操作CPU寄存器。</p></blockquote><ul><li>RV32I提供了32-bit的地址空间，用字节编码。</li><li><code>EEI</code>定义了地址空间的那部分可以被哪些指令合法访问。(e.g.，一些地址可能只能被读，或仅支持按字访问)</li><li>目的寄存器为<code>x0</code>的装载指令将抛出异常，即使装载的值被丢弃也会造成其它的副作用。</li></ul><blockquote><p>In RISC-V，endianness is byte-address invariant</p></blockquote><ul><li><p>如果一个字节以某种顺序(at some endianness)存储到内存某个地址处，那么以字节大小从那个地址以任意的顺序(in any endianness)装载的结果是存储的值。</p></li><li><p>小端(little-endian): 多字节存储时把寄存器最低为字节写到内存字节地址的最低为，随后寄存器的其它字节以权重升序写入。（权重越大的字节占据的内存地址越大）</p></li></ul><hr><p><img src="https://image.beenli.cn/img/20200930/gJvyXMYKv7Ov.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>装载和存储指令用于在寄存器和内存中转换数据。</p><p>Loads: <code>I-type</code></p><p>Stores: <code>S-type</code></p><p>有效地址：立即数符号扩展加上基址寄存器<code>rs1</code></p><p>目的地址：Ⅰ、for load:从内存取值到<code>rd</code>;Ⅱ、for store：复制<code>rs2</code>的值到内存</p></blockquote><h1 id="8-Memory-Ordering"><a href="#8-Memory-Ordering" class="headerlink" title="8 Memory Ordering"></a>8 Memory Ordering</h1><p><img src="https://image.beenli.cn/img/20200930/8gVkNfBMa1IW.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li><p><code>FENCE</code>：用于排序被其它RISC-V线程，外部设备或者协处理器可见的设备I/O和存储器访问。</p></li><li><p>任何设备输入(I)，设备输出(O)，存储器读取(R),存储器写(W)的组合能够被排序成任何相同的组合。</p></li><li>通俗地说，没有其它线程或者外部设备能够在<code>fence</code>之前的指令集进行任何操作之前，观测到在<code>fence</code>后者的指令集合所做的任何操作。就像一个屏障一样，前面的操作只有先完成，后面的指令结果才能被其它处理器观察到。</li><li>memory-mapped I/O设备很典型地被没有cache的loads和store访问，它们使用I和O而不是R和W。</li><li>指令集扩展也可以描述新的I/O指令，使用fence指令中I和O位进行排序</li></ul><p><img src="https://image.beenli.cn/img/20200930/6dnc1SCYbwDA.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>fence mode域在ins[31:28]；当fm=0000时排序所有的内存操作。</li><li>可选的<code>FENCE.TSO</code>指令其fm=1000；predecessor=RW,并且successor=RW。TSO命令它的前面集合中的所有加载操作先于它的后继集合中的所有内存操作；它的前面集合中的所有存储操作(store operation)都要先于它的后继集合中的所有存储操作</li></ul><h1 id="9-Call-and-Breakpoints"><a href="#9-Call-and-Breakpoints" class="headerlink" title="9 Call and Breakpoints"></a>9 Call and Breakpoints</h1><blockquote><p><a name="system">SYSTEM instruction</a>：被用于访问需要特权访问的系统功能，使用<code>I-type</code>。</p><p>分为两大类：</p><ul><li>自动读-修改-写(read-modify-write)<code>控制状态寄存器</code>(CSRs)。</li><li>潜在的特权指令(potentially privileged instructions)</li></ul><p>系统指令被定义成运行稍简单的实现总是捕获异常给单一的<code>软件异常处理器</code>(software trap handle)；更加复杂的实现可能需要执行更多条系统指令</p></blockquote><p><img src="https://image.beenli.cn/img/20200930/Wf33chpE3JIQ.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>这两个指令会向<code>配套执行环境</code>(supporting execution environment)引起一个精确的<code>请求异常</code>(requested trap)。</p><h2 id="ECALL"><a href="#ECALL" class="headerlink" title="ECALL"></a>ECALL</h2><blockquote><p><code>ECALL</code>：向运行环境提出服务请求(service request)</p><p>EEl将定义服务请求的参数如何传递，但通常这些都是在整数寄存器中指定的位置</p></blockquote><h2 id="EBREAK"><a href="#EBREAK" class="headerlink" title="EBREAK"></a>EBREAK</h2><blockquote><p><code>EBREAK</code>：返回控制权给调试器环境(debugging environment)</p></blockquote><h1 id="10-Hint"><a href="#10-Hint" class="headerlink" title="10 Hint"></a>10 Hint</h1><blockquote><p>RV32I为<code>HINT</code>指令保留了大的编码空间，通常是用来和微架构沟通性能提示。HINTs被编码为<a href="#compute">整数计算指令</a>,其中<code>rd=x0</code>。因此，像nop指令一样，HINTs不会改变架构可见的状态，除了增加pc和任何适用的性能计数器。</p></blockquote><p><img src="https://image.beenli.cn/img/20200930/nVtEvPja9AXi.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/RISC-V/">RISC-V</a> <a class="hover-with-bg" href="/categories/RISC-V/spec/">spec</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/8cdff568/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">From 1000Hz clock to 1Hz--OneHertz</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/posts/7b1b9603/"><span class="hidden-mobile">IEEE Standard(1)--Conventions</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="vcomments"></div><script type="text/javascript">Fluid.utils.waitElementVisible("vcomments",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.4/Valine.min.js",(function(){new Valine({el:"#vcomments",app_id:"wL8cVEADdoKpEaDDPPnBR9sm-gzGzoHsz",app_key:"2oJflENqEmJ8ccfv0XLxRL8O",placeholder:"说点什么",path:window.location.pathname,avatar:"monsterid",meta:["nick","mail","link"],pageSize:"10",lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the <a href="https://valine.js.org" rel="nofollow noopener">comments powered by Valine.</a></noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂ICP备20001266号</a></span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e003c704a60a6fe8b1437118b71fea30";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>