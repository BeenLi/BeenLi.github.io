
  <script type="text/javascript">
    (function () {
      var dayStr = '2020/04/04';
      if (/^\d{1,2}\/\d{1,2}$/.test(dayStr)) {
        dayStr = new Date().getFullYear() + '/' + dayStr;
      }
      if (!/^\d{4}\/\d{1,2}\/\d{1,2}$/.test(dayStr)) {
        return ;
      }
      var day = new Date(dayStr);
      var now = new Date();
      var isMemorialDay = now.getFullYear() === day.getFullYear() && now.getMonth() === day.getMonth() && now.getDate() === day.getDate();
      if (isMemorialDay) {
        if (document.all) {
          window.style = 'html {     -webkit-filter: grayscale(100%); /* webkit */     -moz-filter: grayscale(100%); /* firefox */     -ms-filter: grayscale(100%); /* ie9 */     -o-filter: grayscale(100%); /* opera */     filter: grayscale(100%);     filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray; /* ie9- */   }';
          document.createStyleSheet('javascript:style');
        } else {
          var style = document.createElement('style');
          style.type = 'text/css';
          style.innerHTML = 'html {     -webkit-filter: grayscale(100%); /* webkit */     -moz-filter: grayscale(100%); /* firefox */     -ms-filter: grayscale(100%); /* ie9 */     -o-filter: grayscale(100%); /* opera */     filter: grayscale(100%);     filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray; /* ie9- */   }';
          document.getElementsByTagName('HEAD').item(0).appendChild(style);
        }
      }
    })();
  </script>
  <!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="http://image.beenli.cn/img/20200429/F7MQvrUt2Q4K.png?imageslim"><link rel="icon" type="image/png" href="http://image.beenli.cn/img/20200429/F7MQvrUt2Q4K.png?imageslim"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="A senior in JLU majoring in EE/CS. I am interested in Domain-specific accelerator based on RISC-V."><meta name="author" content="Wan Li"><meta name="keywords" content="digital IC, ASIC, Linux, Vim, python, 电子狗, 程序猿"><title>AMBA AHB spec(1)--bus scheme - WanLi&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1791347_g19vm5ywni.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"www.beenli.cn",root:"/",version:"1.8.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!0,baidu:"e003c704a60a6fe8b1437118b71fea30",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null},tajs:null}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="WanLi's blog" type="application/atom+xml">
</head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>WanLi's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:" rel="external nofollow noreferrer">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://image.beenli.cn/img/20201009/844N1sRMxUgd.jpg?imageslim) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="AMBA AHB spec(1)--bus scheme"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-10-09 18:25" pubdate>Friday, October 9th 2020, 6:25 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 97 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">AMBA AHB spec(1)--bus scheme</h1><p class="note note-info">本文最后更新于：Friday, October 9th 2020, 7:28 pm</p><div class="markdown-body"><blockquote><p>The blog is derived from the translation of <code>ARM IHI 0011A</code> AHB specification Copyright © 1999 ARM Limited</p><p>文档链接：<a href="https://pan.baidu.com/s/19fG2h8Jw4k29AjWfRBliFw" rel="external nofollow noreferrer">https://pan.baidu.com/s/19fG2h8Jw4k29AjWfRBliFw</a> 提取码：mmme</p></blockquote><h1 id="0-Overall-framwork"><a href="#0-Overall-framwork" class="headerlink" title="0 Overall framwork"></a>0 Overall framwork</h1><p><img src="https://image.beenli.cn/img/20201009/UXpaBaxtcInK.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h1 id="1-Bus-interconnection"><a href="#1-Bus-interconnection" class="headerlink" title="1 Bus interconnection"></a>1 Bus interconnection</h1><blockquote><p>AHB总线协议被设计成带有一个中心选择器(central multiplexor)的互连方案。</p><ul><li>主设备驱动地址和控制信号，信号指示它们想要执行的传输。</li><li>并且仲裁器决定哪个主设备能够把他们的信号路由给所有的从设备；</li><li>还需要一个中心译码器控制读数据(read data)和回应信号(response signal)多选器，它从涉及这次传输的从设备中选择合适的信号。</li></ul><p><img src="https://image.beenli.cn/img/20201009/fekjU3fX5vOK.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p></blockquote><h1 id="2-Overview-of-operation"><a href="#2-Overview-of-operation" class="headerlink" title="2 Overview of operation"></a>2 Overview of operation</h1><blockquote><p>在一次传输开始(commence)之前，master必须被授予访问总线(granted access to the bus)。这个过程由master向仲裁器发起一个请求信号开始(assert a request signal)。然后仲裁器指示何时将授予master总线使用权。</p><p>得到授予的master通过驱动地址和控制信号开始一次AHB transfer。这些信号提供了关于<code>地址</code>，<code>方向</code>，<code>传输宽度</code>和<code>这次传输是否是burst的一部分的指示信号(indiction)</code>。两种不同形式的burst transfer都被允许：</p><ul><li>递增的突发(incrementing burst)，它不包装在地址边界</li><li>包装的突发(wrapping burst)，包裹在特殊的地址边界</li></ul><p>写数据总线把数据从master搬运到slave；但读数据总线把数据从Slave搬运到master。</p><p>每次传输都包括如下两个部分：</p><ul><li>一个地址和控制周期(an address and control cycle)</li><li>一个或多个数据周期(one or more cycle for the data)</li></ul></blockquote><p>由于地址不能被扩展(extended)，所有所有的从设备必须在此期间取样地址。但是数据可以用<code>HREADY</code>信号扩展。当该信号为低时导致<code>等待状态</code>(wait states)被塞进这次传输里面；因此允许slave有额外的时间取提供或者采样数据。</p><p>在传输中，slave通过<code>response signal</code>传达状态信息，<code>HRESP[1:0]</code>：</p><ul><li><strong>OkAY</strong>：指示传输进展正常，当HREADY变高时，该信号指示传输成功完成(complete successfully)</li><li><strong>ERROR</strong>：指示传输❌发生，传输失败</li><li><strong>RETRY and SPLIT</strong>：两者都表示传输不能立刻完成，但是master应该继续尝试传输。</li></ul><p><font color="blue">notes:</font>在正常操作中，允许master在仲裁器授予其它master访问总线前完成一次burst的所有传输。但是，为了避免过多的(excessive)仲裁延迟，有可能仲裁器会打断一次burst，在这种情况下，master必须重新向仲裁器申请总线以完成burst中剩余的传输。</p><h1 id="3-Basic-transfer"><a href="#3-Basic-transfer" class="headerlink" title="3 Basic transfer"></a>3 Basic transfer</h1><h2 id="3-1-simple-without-wait"><a href="#3-1-simple-without-wait" class="headerlink" title="3.1 simple without wait"></a>3.1 simple without wait</h2><blockquote><p>一次AHB传输包含两个不同的部分(two distinct sections)：</p><ul><li>The address phase, which lasts only a single cycle</li><li>The data phase, which may require several cycles. This is achieved using the HREADY signal.</li></ul><p><img src="https://image.beenli.cn/img/20201009/ilQdeYFuyKhz.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><center><strong>👆没有等待状态的简单传输</strong></center><ul><li>master在<code>HCLK</code>上升沿把地址和控制信号驱动到bus上</li><li>slave在下一个上升沿采样地址和控制信号</li><li>在slave采样完成之后，它开始驱动合适的回应信号，然后response被master在三个上升沿采样。</li></ul></blockquote><hr><p><font color="blue">notes:</font> 事实上，任何传输的地址相与前一个传输的数据相发生在同一时期。正是因为这种重叠，它们构成了总线流水特性，为高性能操作提供契机，同时为slave对接收的数据做出反应提供了足够的时间。</p><h2 id="3-2-simple-with-wait"><a href="#3-2-simple-with-wait" class="headerlink" title="3.2 simple with wait"></a>3.2 <a name="extend">simple with wait</a></h2><p><img src="https://image.beenli.cn/img/20201009/LaEzji7jaCvB.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><font color="gree">notes:</font> Ⅰ、对于写操作，master需要在扩展周期一直保持稳定的数据；Ⅱ、对于读操作，slave不需要一直提供有效数据，直到传输将要完成。</p><h2 id="3-3-multiple-transfers"><a href="#3-3-multiple-transfers" class="headerlink" title="3.3 multiple transfers"></a>3.3 multiple transfers</h2><center><strong>扩展对下次传输的地址相的side-effect</strong></center><p><img src="https://image.beenli.cn/img/20201009/vaC3e2oTfz4L.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>地址A和地址C的传输没有等待状态</li><li>地址B的传输有一个等待状态</li><li>地址B传输中的数据phase扩展对地址C传输的地址phase扩展有影响。</li></ul><h1 id="4-Transfer-type"><a href="#4-Transfer-type" class="headerlink" title="4 Transfer type"></a>4 Transfer type</h1><blockquote><p>每一种传输都可以被归类为以下四种中的一种，用<code>HTRANS[1:0]</code>信号指示</p></blockquote><div class="table-container"><table><thead><tr><th>HTRANS[1:0]</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>00</td><td>IDLE</td><td>①没有数据传输请求。IDLE用在master获得授权，但不想开始数据传输时。②slave必须总是对这种传输提供一个没有等待状态的<code>OKAY</code>响应，并且该传输应该被slave忽略掉</td></tr><tr><td>01</td><td>BUSY</td><td>①该状态允许master在burst中间插入<code>IDLE</code>周期；该状态表明master正在继续一次burst；但是下一个传输不能立即发生。⭐当master使用该类型时，地址和控制信号一定反应(reflect)burst的下一次传输。②传输应该被slave忽视，slave一定总是提供零等待状态的<code>OKAY</code>回应，跟IDLE同样的方式</td></tr><tr><td>10</td><td>NONSEQ</td><td>①指示burst的第一次传输或者一个单次传输；地址和控制信号与上次传输没有关系。②总线上单一传输(single transfer)与burst传输中的第一个传输同样对待，因此传输类型为<code>NONSEQUENTIAL</code></td></tr><tr><td>11</td><td>SEQ</td><td>①busrt中除了第一次传输剩余的所有传输都是<code>SEQENTIAL</code>;并且地址与上次传输有关。控制信息与上次传输相同，地址信息=上次地址信息+数据大小(in byte)。②在wrapping中，<a href="#boundry">地址包裹在地址边界(warps at the address boundry)</a>，地址边界=beats的数量(4,8或者16)*<a href="#size">数据大小(in byte)</a></td></tr></tbody></table></div><p><img src="https://image.beenli.cn/img/20201009/k5ITwMzdBWxc.jpg?imageslim" srcset="/img/loading.gif" alt="mark"></p><h1 id="5-Burst-operation"><a href="#5-Burst-operation" class="headerlink" title="5 Burst operation"></a>5 Burst operation</h1><blockquote><p>4，8，16节拍的bursts在AHB协议中有定义，除此之外还有没有定义长度的bursts和单个的传输；递增和包裹的阵发传输都被支持：</p><ul><li>递增的阵发访问顺序的位置，突发中的每个传输的地址只是先前地址的一个增量。</li><li>对于封装阵发，如果传输的起始地址没有对齐阵发的总字节数(size * beats)，那么传输地址将包裹当达到边界时(trap when the boundary is reached)。例如，一个4-beat的包裹阵发以字(4-byte)访问将封装在16-byte的边界。因此如果传输的起始地址为Ox34，那么它由四次传输组成，每次地址为Ox34, Ox38, Ox3C, Ox30</li></ul></blockquote><p align="right"><strong>Table 4-1 Burst signal encoding</strong></p><div class="table-container"><table><thead><tr><th>HBURS[2:0]</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>000</td><td>SINGLE</td><td>Single transfer</td></tr><tr><td>001</td><td>INCR</td><td>没有指定长度的递增阵发</td></tr><tr><td>010</td><td>WRAP4</td><td>4-beat wrapping burst</td></tr><tr><td>011</td><td>INCR4</td><td>4-beat incrementing burst</td></tr><tr><td>100</td><td>WRAP8</td><td>8-beat wrapping burst</td></tr><tr><td>101</td><td>INCR8</td><td>8-beat incrementing burst</td></tr><tr><td>110</td><td>WRAP16</td><td>16-beat wrapping burst</td></tr><tr><td>111</td><td>INCR16</td><td>16-beat incrementing burst</td></tr></tbody></table></div><ul><li>阵发不能跨越1KB的地址边界(即A[9:0]=0)。因此对于master不要尝试开始一个固定长度递增阵发，让这个界限被跨越。</li><li>使用没有指定长度的阵发，并且只有一个长度为1的阵法来代替single transfers。</li><li>一个递增阵发可以是任何长度,但是上限被1KB设定</li></ul><p><font color="blue">notes:</font> ①阵发的大小是每个阵发节拍的数量，不是传送的字节数。一个burst传送的总的数据量=节拍数*每个节拍数据量(HSIZE[2:0])②：<a name="boundary">在一次burst中的所有传输必须对齐地址边界</a>，（边界等于传输的大小)；例如，字传输必须对齐字地址边界(A[1:0]=00字地址的地两位为0；即表示地址是4的倍数)，半字传输必须对齐半字地址边界( A[0] = 0(地址的最后一位为0;即表示地址是2的倍数))。</p><h2 id="5-1-early-termination"><a href="#5-1-early-termination" class="headerlink" title="5.1 early termination"></a>5.1 early termination</h2><blockquote><p>有很多情形，阵发不能完成；因此对于slave的设计中，充分利用阵发信息在阵发提前终止时采取正确的行动很重要。slave可以通过监视<code>HTRANS</code>信号确定阵发何时提前终止，确保阵发开始后的每一个传输都被贴上<code>SEQUENTIAL</code>或者<code>BUSY</code>标签。如果带有<code>NONSEQUENTIAL</code>或者<code>IDLE</code>的传输出现，那表明新的阵发开始并且之前的阵发一定被终止了。</p><p>如果master不能完成一个阵发，因为它失去了总线拥有权，那么它必须在它下次获得权限时合适地重新建立阵发。例如，如果一个master仅仅完成了4-beat阵发中的一个beat，那么它下次必须使用<code>undefined-length</code>阵发来完成剩余的三个阵发。</p></blockquote><h2 id="5-2-4-beat"><a href="#5-2-4-beat" class="headerlink" title="5.2 4-beat"></a>5.2 4-beat</h2><p><img src="https://image.beenli.cn/img/20201009/qnnwUkLNDIRe.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><img src="https://image.beenli.cn/img/20201009/XCK6FrNsexKT.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><font color="red">notes:</font> 因为是传送大小4-byte的4-beat阵发；①for warping：地址要封装在16-byte的边界内；因此地址为Ox3C的传输后紧跟的是地址为Ox30的传输。②：for increment: 它可以跨越16-byte边界。</p><hr><h2 id="5-3-8-beat"><a href="#5-3-8-beat" class="headerlink" title="5.3 8-beat"></a>5.3 8-beat</h2><p><img src="https://image.beenli.cn/img/20201009/Gdcib8auNtiX.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>可以看到地址边界为：8*4=32；那么整个地址空间被分割成很多包含32个字节的块；00-1F; 20-3F; 40-5F….；由于起始地址为OX34——&gt;被封装在<code>Ox20-3F</code>这块里面；</p></blockquote><p><img src="https://image.beenli.cn/img/20201009/IcKa2VOByjNm.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><hr><h2 id="5-4-xx-beat"><a href="#5-4-xx-beat" class="headerlink" title="5.4 xx-beat"></a>5.4 xx-beat</h2><center><strong>Undefined-length bursts</strong></center><p><img src="https://image.beenli.cn/img/20201009/pztUIO5T2M9B.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>两个半字传输从地址Ox20开始，地址每次增加2</li><li>三个字传输从地址Ox5C开始，地址传输增加4</li></ul><h1 id="6-Control-signals"><a href="#6-Control-signals" class="headerlink" title="6 Control signals"></a>6 Control signals</h1><blockquote><p>和传输类型和阵发类型一样，每次传输都有许多控制信号，这些信号提供了传输的额外信息。这些控制信号有着和地址总线完全相同的时序。但是，它们必须在整个阵发期间保持恒定.(remain constant)</p></blockquote><h2 id="6-1-Transfer-direction"><a href="#6-1-Transfer-direction" class="headerlink" title="6.1 Transfer direction"></a>6.1 Transfer direction</h2><blockquote><p>当<code>HWRITE</code>为高，信号指示一个写传送，并且master在写数据总线上广播数据(<code>HWDATA[31:0]</code>)。当其为低时，一个读传送将执行，slave必须在读数据总线上生成数据(<code>HRDATA[31:0]</code>)。</p></blockquote><h2 id="6-2-Transfer-size"><a href="#6-2-Transfer-size" class="headerlink" title="6.2 Transfer size"></a>6.2 <a name="size">Transfer size</a></h2><p><code>Hsize[2:0]</code>指示传送的大小。</p><p><img src="https://image.beenli.cn/img/20201009/PIOE3teyQpGn.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><blockquote><p>这个大小(transfer size)用于和<code>HBURST[2:0]</code>信号联结起来决定wrapping bursts的地址边界</p></blockquote><h2 id="6-3-Protection-control"><a href="#6-3-Protection-control" class="headerlink" title="6.3 Protection control"></a>6.3 Protection control</h2><blockquote><p>控制保护信号<code>HPROT[3:0]</code>，提供了关于总线访问的额外信息，主要是为了想要实现某种保护的模块使用。</p><p>这个信号指示这次传输为：</p><ul><li>取操作码\ 数据访问</li><li>特权模式访问\ 用户模式访问</li></ul><p>对于带有内存管理单元的master，这些信号还可以指示当前的访问是否可缓存(cacheable or bufferable)</p></blockquote><p><img src="https://image.beenli.cn/img/20201009/lB70hNmFcAKN.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><font color="blue">notes:</font> 并不是所有的master都有能力生成正确保护信息，因此推荐slave不要使用<code>HPROT</code>信号的信息，除非严格需要(strictly necessary)。</p><h1 id="7-Address-decoding❓"><a href="#7-Address-decoding❓" class="headerlink" title="7 Address decoding❓"></a>7 Address decoding❓</h1><blockquote><p>中心化的地址译码器(central address decoder)为总线上每一个slave提供一个选择信号，<code>HSELx</code>。选择信号是高阶地址信号的组合译码，简单地址译码方案鼓励使用来避免复杂译码逻辑，并且可以保证高速操作。</p><p>当<code>HREADY</code>信号为高时(指示当前传输完成)，slave一定仅采样地址，控制信号和<code>HSELx</code>。在特点情景下，<code>HSELx</code>信号可能在<code>HREADY</code>为低的时被声明(发出)，但是所选slave在当前传输完成时将会改变。</p><p>❓能够分配给单个slave的最小地址空间为<code>1kB</code>。所有的master都被设计成不允许执行跨越1KB边界的递增传输(incrementing transfers)，因此确保burst永远不会越过地址译码边界。</p><p>在系统设计不包含一个完全填充的内存映射的情况下，一个额外的默认slave应被实现，以提供一个响应时，任何不存在的地址位置被访问。如果<code>NONSEQUENTIAL</code>或者<code>SEQUENTIAL</code>传输尝试一个不存在的地址位置，那么默认的slave应该提供一个<code>ERROR</code>响应。<code>IDLE</code>或者<code>BUSY</code>传输尝试一个不存在的地址位置时，应该返回零等待状态的<code>OKAY</code>响应。默认slave的功能通常由decoder的一部分完成。</p></blockquote><p><img src="https://image.beenli.cn/img/20201009/XInRU3i6fHtN.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><h1 id="8-Slave-response"><a href="#8-Slave-response" class="headerlink" title="8 Slave response"></a>8 Slave response</h1><blockquote><p>在master开始一个传输后，slave随即判断传输改怎样进展，在AHB spec中没有[当传输开始后，master可以取消传输]的规定。</p><p>无论slave何时被访问，它一定提供一个response,指示传输的状态。<code>HREADY</code>信号用于扩展传输，它还和响应信号<code>HRESP[1:0]</code>组合提供传输状态。</p><p>slave可以用多种方法完成传输：</p><ol><li>立即完成</li><li>插入一个或多个等待状态匀出时间来完成</li><li>发送一个<code>error</code>信号告知传输失败</li><li>延迟传输的完成，但是允许master和slave让出总线，腾给其它传输使用。</li></ol></blockquote><h2 id="8-1-transfer-done"><a href="#8-1-transfer-done" class="headerlink" title="8.1 transfer done"></a>8.1 transfer done</h2><blockquote><p><a href="#extend"><code>HREADY</code>信号用于扩展AHB传输的数据部分。</a>当拉低该信号时表明传输被扩展，当拉高该信号表示传输完成</p><p><font color="red">note:</font> 为了计算访问总线的延迟时间，每个master必须有一个预先确定的等待状态的最大数目，它将在退出总线之前插入。我们推荐但不强制：每个slave不要插入超过16个wait states，以防任何单个访问🔒住总线过多的时钟周期。</p></blockquote><h2 id="8-2-transfer-response"><a href="#8-2-transfer-response" class="headerlink" title="8.2 transfer response"></a>8.2 transfer response</h2><blockquote><p>通常，slave使用<code>HREADY</code>信号来插入合适的数量的<code>wait states</code>，并在传输完成时置高<code>HREADY</code>，返回<code>OKAY</code>response，指示传输成功完成。</p><p><code>ERROR</code> response用于指示某种形式的传输失败。很典型的是保护错误，例如尝试写入只能读的存储区域。</p><p><code>SPLIT</code>和<code>RETRY</code>响应组合让slave能延迟传输的完成，但是释放总线给其它master用。这些响应组合通常仅仅被那些访问延迟长的master使用，充分利用这些响应码可以确保其它的master申请bus不会等待太长的时间。</p></blockquote><p><img src="https://image.beenli.cn/img/20201009/qakoEUczkIsS.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p><font color="red">note:</font> 当slave发现还不能立刻给出响应结果，需要插入几个等待周期时，它应该响应<code>OKAY</code></p><h2 id="8-3-Two-cycle-response"><a href="#8-3-Two-cycle-response" class="headerlink" title="8.3 Two-cycle response"></a>8.3 Two-cycle response</h2><blockquote><p>只有<code>OKAY</code>响应才可能出现在单周期中。<code>ERROR</code>，<code>SPLIT</code>和<code>RETRY</code>响应至少需要两个周期。为了用这些响应中的任何一个来完成传输，在倒数第二个周期，slave驱动<code>HRESP[1:0]</code>指示ERROR, RETRY or SPLIT，同时驱动HREADY低电平来扩展一个额外的周期。在最后一个周期<code>HREADY</code>驱动到高电平结束这次传输，但是<code>HRESP[1:0]</code>仍然保持不变指示ERROR, RETRY or SPLIT。</p><p>如果slave需要多于两个周期来提供ERROR, RETRY or SPLIT响应，那么额外的等待状态在传输的开始被插入。等待期间HREADY=0，响应设置为<code>OKAY</code></p><p>由于总线流水线的特性，需要两个周期的响应。这时slave开始发射 ERROR, SPLIT or RETRY中的任何一个响应，然后下一次传输的地址已经被广播到总线上。两周期的响应给master足够的时间取消地址，在下一次传输开始前驱动<code>HTRANS[1:0]</code>到IDLE。</p><p>对于SPLIT和RETRY响应，接下来的传输一定被取消，因为在当前传输完成前不能进行此传输。但是，对于ERROR响应，其中当前传输没有重复时，完成接下来传输的是可选的。</p></blockquote><h3 id="8-3-1-retry"><a href="#8-3-1-retry" class="headerlink" title="8.3.1 retry"></a>8.3.1 retry</h3><p><img src="https://image.beenli.cn/img/20201007/qIJ2WDNn39pv.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>master开始一个地址A的传输</li><li>在这次传输的响应收到前，它开始新的传输A+4</li><li>在地址A的slave不能立刻完成改次传输，因此它回复<code>RETRY</code>响应；这个响应告诉master地址A的传输不能完成，所以地址A+4的传输被取消并用IDLE传输替代。</li></ul><hr><h3 id="8-3-2-Error"><a href="#8-3-2-Error" class="headerlink" title="8.3.2 Error"></a>8.3.2 Error</h3><p><img src="https://image.beenli.cn/img/20201007/v0mXUKMwCtur.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>slave需要一个周期决定响应(此期间HRESP指示OKAY)</li><li>然后slave用两周期的ERROR响应终止该传输</li></ul><h2 id="8-4-Error-response"><a href="#8-4-Error-response" class="headerlink" title="8.4 Error response"></a>8.4 Error response</h2><blockquote><p>如果一个slave提供一个错误响应，然后master可以选择取消在突发的剩余传输。但是，这不是一个严格的要求，并且master继续在突发中传输剩余的数据也是可以接受的。</p></blockquote><h2 id="8-5-Split-and-retry"><a href="#8-5-Split-and-retry" class="headerlink" title="8.5 Split and retry"></a>8.5 Split and retry</h2><blockquote><p>分割和重试响应提供了一种机制，当slave不能立即为传输提供数据时，可以释放总线。这两种机制都允许在总线上的传输完成，因此允许高优先级的master访问总线。</p><p>两者的不同在于仲裁器分配总线的方法：</p><ul><li>对于retry：仲裁继续使用正常的优先级策略，因此只有更高优先级的master能获得总线</li><li>对于split：仲裁器调整优先策略，以至于任何申请的master都有机会获得，即使是那些低优先级的。<a name="split">为了完成SPLIT的传输，仲裁器必须被通知slave何时准备好了数据。</a></li></ul><p>SPLIT传输需要同时在仲裁器和slave上增加复杂度，但是它的优势在于它完全释放总线给其它masters, 与此相对的是retry，它只释放总线给优先级更高的master。</p><p>master应该用同样的方式对待SPLIT和RETRY。它应该继续申请总线，尝试传输直到它要么成功完成，要么它以ERROR响应提前终止了。</p></blockquote><h1 id="9-Data-buses"><a href="#9-Data-buses" class="headerlink" title="9 Data buses"></a>9 Data buses</h1><blockquote><p>为了AHB系统实现不需要使用<code>三态驱动器</code>(tristate drivers)，我们需要独立的读和写数据总线。最小的数据总线宽度被指定为32 bits，但是可以增加。</p></blockquote><h2 id="9-1-HWDATA-31-0"><a href="#9-1-HWDATA-31-0" class="headerlink" title="9.1 HWDATA[31:0]"></a>9.1 HWDATA[31:0]</h2><blockquote><p>写数据总线在写传输期间由master驱动。如果传输被扩展，master保持数据有效直到传输完成(由HREADY 变高指示)</p><p>对于比起总线宽度还窄的传输，比如在32位总线上传输16位，那么master只用驱动适当的<code>字节通道</code>（byte lanes)。slave负责为写进的数据选通正确的字节通道。👇表格说明哪个字节通道分别在大端和小端系统中被激活。如果需要，此信息可以扩展为更宽的数据总线实现。对于传输大小小于数据总线宽度的阵发传输，每一拍有不同的激活字节通道。</p><p>激活字节通道取决于系统是大端还是小端，但是AHB没有指定所需的端。因此，对于系统中的master和slave保持相同的端很重要。</p></blockquote><h2 id="9-2-HRDATA-31-0"><a href="#9-2-HRDATA-31-0" class="headerlink" title="9.2 HRDATA[31:0]"></a>9.2 HRDATA[31:0]</h2><blockquote><p>读数据总线在读传输中被对应的slave驱动。如果slave扩展传送，那么slave仅仅需要提供有效的数据在传输的最后一个周期，用HREADY=1指示</p><p>对于比总线宽度更窄的传输，slave仅仅需要在激活的字节通道上提供有效的数据。master负责从正确的字节道中选择数据</p><p>slave只要当传输带有OKAY响应完成时提供有效数据。 SPLIT, RETRY and ERROR responses不需要提供有效读数据。</p><p><img src="https://image.beenli.cn/img/20201007/utIIQ2a1FJji.png?imageslim" srcset="/img/loading.gif" alt="mark"></p></blockquote><h2 id="9-3-Endianness"><a href="#9-3-Endianness" class="headerlink" title="9.3 Endianness"></a>9.3 Endianness</h2><blockquote><p>为了让系统功能正确，所有模块使用同样的端很重要，并且所有的数据路由或者桥也用一样的。</p><p>动态端不支持，因为绝大多嵌入书系统，这将导致大量冗余的硅开销(silicon overhead that is redundant)</p><p>对于某块设计者，我们推荐只有那些可被用在许多地方的模块才应该设计成大小端，要么带有可配置的引脚(pin)或者内部控制位取选择端的大小。对于更多特定应用的模块，固定端为小端或者大端可以节省功耗，提高接口性能。</p></blockquote><h1 id="10-Arbitration"><a href="#10-Arbitration" class="headerlink" title="10 Arbitration"></a>10 Arbitration</h1><blockquote><p>仲裁机制被用来确保任何时候只有一个master访问总线。仲裁器通过观察一些不同的请求，判断当前请求中最高优先级的master来完成这一功能。仲裁也接受来自slave的请求，<a href="#split">请求完成SPLIT传输。</a></p><p>任何不能完成SPLIT传输的slave都不需要知道仲裁的过程，除非它们需要观测这样的事实——一连串的传输可能无法完成如果总线所有权改变了。</p></blockquote><h2 id="10-1-Signal-description"><a href="#10-1-Signal-description" class="headerlink" title="10.1 Signal description"></a>10.1 Signal description</h2><ul><li><strong>HBUSREQx </strong>：总线请求信号；每个master有单独的请求信号连接到仲裁器，最多有16个独立的master。</li><li><strong>HLOCKx </strong>：锁信号与请求信号被master同时发出；它指示我将要执行大量不可分割的传输，并且一旦带🔒传输的第一个传输开始，仲裁一定不要授权其它的master。该信号一定在它访问的地址之前至少一个周期发出，以免仲裁改变了授权信号。</li><li><strong>HGRANTx </strong>：授权信号由仲裁生成，指示当前申请总线的master中优先级最高的，考虑锁传输和SPLIT传输在内。</li><li><strong>HMASTER[3:0]</strong>：指示当前谁有权利使用总线。该信号还被用来当作地址控制多选器的控制信号。master的号码还被能够执行SPLIT传输的slaves使用，来向仲裁指示哪一个master能够完成SPLIT交易</li><li><strong>HMASTLOCK</strong>：仲裁器通过发出该信号指示当前传输是带🔒传输序列的一部分，其与地址和控制信号有相同的时序。</li><li><strong>HSPLIT[15:0] </strong>：能够处理split的slave使用16bit的<code>SPLIT Complete bus</code>来指示哪个master能够完成split交易。仲裁器需要这个信息来授权master去完成该次传输。</li></ul><h2 id="10-2-Requesting-bus-access"><a href="#10-2-Requesting-bus-access" class="headerlink" title="10.2 Requesting bus access"></a>10.2 Requesting bus access</h2><blockquote><p>master使用<code>HBUSREQx</code>信号来请求访问总线，并可能在任何周期发起请求。仲裁器将在时钟上升沿取样请求信号然后使用内部优先级算法决定哪个master将成为下一个有权利访问总线的。</p><p>正常来说仲裁器只会当阵发完成后才授权一个不同的master。但是，如果需要，仲裁器能提前终止一次阵发来让更高优先级的master访问。</p><p>如果master需要锁访问，那么它必须发送HCLOKx信号来向仲裁器指示：不该有其它的master被授权。</p><p>当有一个master被授权总线并正在执行一个固定长度长度的阵发，它没必要持续请求总线来完成阵发。仲裁器观察阵发的进程并使用<code>HBURST[2:0]</code>信号知道master请求了多少次传输。如果master希望在当前正在进行的burst之后再执行第二次burst，那么它应该在当前burst期间重新发出请求信号</p><p>如果一个master在阵发中途失去了总线访问权，那么它必须重新发出<code>HBUSREQx</code>请求来重新获得总线访问权。</p><p>对于没有定义长度的burst，master必须持续发出请求知道它开始了最后一次传输(until it has started the last transfer)。在没有定义长度阵发的末尾，仲裁器不能预测何时去改变仲裁。</p><p>当master不请求总线时，它可能被授予该总线。这种情况发生在没有master请求总线并且仲裁器授予访问权给一个默认的master。因此，如果master不需要访问总线，它应该驱动传输类型<code>HTRANS</code>指示当前传输为<code>IDLE</code>。</p></blockquote><h2 id="10-3-Granting-bus-access"><a href="#10-3-Granting-bus-access" class="headerlink" title="10.3 Granting bus access"></a>10.3 Granting bus access</h2><h3 id="10-3-1-granting-with-wait"><a href="#10-3-1-granting-with-wait" class="headerlink" title="10.3.1 granting with wait"></a>10.3.1 granting with wait</h3><blockquote><p>仲裁程序通过声明适当的<code>HGRANTx</code>信号来指示当前请求总线中哪个master是最高优先级的。当当前传输完成，有<code>HREADY</code>为高来指示，之后master将被授权并且仲裁器会改变<code>HMASTER[3:0]</code>信号来指示这个master的号码。</p><p><img src="https://image.beenli.cn/img/20201008/FPXL0rH173Vy.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>当master发出<code>HBUSREQx</code>后几个周期，仲裁器才授权(<code>HGRANTx</code>置高)</li><li>master只有等到<code>HGRANTx</code>和<code>HREADY</code>都为高才开始传送地址。同时<code>HMASTER[3:0]</code>指示该master</li><li>地址被slave采样，当<code>HREADY</code>为高时才传送下一个地址。</li></ul></blockquote><h3 id="10-3-2-Data-bus-owner"><a href="#10-3-2-Data-bus-owner" class="headerlink" title="10.3.2 Data bus owner"></a>10.3.2 Data bus owner</h3><blockquote><p><img src="https://image.beenli.cn/img/20201008/AWHDyOGLSx92.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>数据总线拥有权滞后于地址总线。(👆落后T5和T6两周期)</li><li>无论传输何时完成(由HREADY为高指示)，那么拥有地址总线的master(👆#2在T7可以传送写数据)将能够使用数据总线，并一直占有数据总线直到传输完成。</li></ul></blockquote><h3 id="10-3-3-handover-after-burst"><a href="#10-3-3-handover-after-burst" class="headerlink" title="10.3.3 handover after burst"></a>10.3.3 handover after burst</h3><blockquote><p><img src="https://image.beenli.cn/img/20201008/7W4Hcztx7uQz.png?imageslim" srcset="/img/loading.gif" alt=""></p><ul><li>仲裁器在倒数第二个地址被采样完(👆T5)改变<code>HGRANTx</code>信号，新的<code>HGRANTx</code>信号将和阵发的最后一个地址信号在相同时刻被采样(👆只有HREADY为高时才采样成功即T7；此时HMASTER也改为#2)。</li></ul></blockquote><h3 id="10-3-4-hgrant-and-hmaster"><a href="#10-3-4-hgrant-and-hmaster" class="headerlink" title="10.3.4 hgrant and hmaster"></a>10.3.4 hgrant and hmaster</h3><blockquote><p><img src="https://image.beenli.cn/img/20201008/i0vyocIqRNLC.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>因为有中央复用器，每一个master都能够驱动它们想要立刻执行的传输的地址，并且它们直到被授予总线才需要等待。</li><li><code>HGRANTx</code>信号仅仅被master用于决定它们何时拥有总线，因此什么时候它应该考虑地址已经被适当的slave取样。</li></ul></blockquote><h2 id="10-4-Early-burst-termination"><a href="#10-4-Early-burst-termination" class="headerlink" title="10.4 Early burst termination"></a>10.4 Early burst termination</h2><blockquote><p>正常来说，仲裁器不用移交总线给一个新的master，直到阵发传输的结束。但是，如果仲裁器认为阵发应该提前终止为了避免访问总线时间过长，那么它可能在阵发完成之前转换授权给另外一个master。</p></blockquote><h2 id="10-5-default-bus-master"><a href="#10-5-default-bus-master" class="headerlink" title="10.5 default bus master"></a>10.5 default bus master</h2><blockquote><p>每个系统一定包含一个默认的master，它在其它master都不能访问总线时被授予使用。当被授予时，默认master一定只能进行<code>IDLE</code>的传输。</p><p>如果没有master请求总线，那么仲裁器要么授权默认的master，要么授予可能从访问总线低延迟获益最大的master。</p><p>授予对总线默认的master访问权还提供了一种有用的机制，以确保总线上不会启动新的传输，是在进入低功率工作模式之前执行的一个有用的步骤</p><p>⭐如果所有其它master都在等待分割传输完成，则必须授予默认master。</p></blockquote><h1 id="11-Split-transfer"><a href="#11-Split-transfer" class="headerlink" title="11 Split transfer"></a>11 Split transfer</h1><blockquote><p>SPLIT传输通过分离<code>master向slave提供地址的操作</code>和<code>slave向master提供正确数据的操作</code>，来提高总的总线利用率。</p><p>当一次传输发生时，slave如果相信该次传输需要花费很多周期去执行，那么它将发送SPLIT响应。这个信号告诉仲裁器当前尝试传输的master不应该被授权直到slave表示它已经准备好完成传输。因此仲裁器需要观测响应信号并在内部屏蔽来自已被分割(have been SPLIT)的master的任何请求</p><p>在一次传输的地址相中，仲裁器产生一个标签或者master编号HMASTER[3:0]，指示正在执行传输的master。任何发出SPLIT响应的slave必须能够指示它们有能力完成传输，并且它通过记录HMASTER[3:0]信号上的master编号来做到这一点</p><p>随后，当slave完成了传输，它根据master编号在<code>HSPLITx[15:0]</code>上向仲裁器发出合适的位。仲裁器然后使用该信息unmask(停止屏蔽)对应master的请求信号并在适当的适合(in due course)master被授权访问来重启之前的传输。仲裁器每周期都取样HSPLITx信号，因此slave只需要发出合适的位持续一个周期以便仲裁器能够识别它。</p><p>在带有多个有能力发送SPLIT的slave系统中，来自每个slave的HSPLITx信号被或操作到一起，产生一个最终结果的HSPLIT信号给仲裁器。</p><p>在大多数系统中，可能用不到16个master的最大容量。因此仲裁器只需要一根HSPLIT总线，其位数与master个数相同。但是，我们推荐所有有能力发送split的slave都被设计成支持最多的16个master。</p></blockquote><h2 id="11-1-split-transfer-seq"><a href="#11-1-split-transfer-seq" class="headerlink" title="11.1 split transfer seq"></a>11.1 split transfer seq</h2><blockquote><p>SPLIT交易的基本阶段如下：</p><ol><li>master以和其他任何传输相同的方式开启传输，并发射地址和控制信息。</li><li>如果slave能够立刻提供数据，它可能这样做。如果slave决定它可能需要多个周期获得数据，它将给出一个SPLIT响应。在每次传输中，仲裁器广播一个号码或者标签—指示正在使用总线的master。slave必须记录这个号码，后面用这个信息重启这个传输。</li><li>仲裁器授权其它master，并且SPLIT响应的动作允许master切换的发生。如果所有其它的master也收到了SPLIT响应，那么默认的master被授权。</li><li>当slave准备好完成传输时，它发出合适的HSPLITx中的位给仲裁器指示哪个master被授权访问总线。</li><li>仲裁器每个周期都会观察HSPLITx信号，并且当HSPLITx中任何一位被声明时，仲裁器恢复该master的优先级(因为之前被屏蔽了)</li><li>最终仲裁器授权该master，好让它能够重新尝试这次传输。如果一个更高优先级的master正在使用，上述场景可能不会立刻发生。</li><li>当传输最终发生时，slave用OKAY响应结束这次传输。</li></ol></blockquote><h2 id="11-2-multiple-split-trans❓"><a href="#11-2-multiple-split-trans❓" class="headerlink" title="11.2 multiple split trans❓"></a>11.2 multiple split trans❓</h2><blockquote><p>该总线协议仅允许每个master有一个<code>滞外交易/未完成事物</code>(outstanding transaction)。如果任何master模块能够处理不止一个滞外交易，他需要为每个它能处理的滞外交易提供一组额外的请求和授权信号。在协议级别上，单个模块可以作为许多不同的master出现，每一个master只能有一个滞外交易。</p><p>❓但是，一个有能力处理SPLIT的slave可能接收比它所能并发处理更多的传输请求。如果这种情况发生，slave发送SPLIT响应，但没有记录与传输对应的地址和控制信息是可接受的，slave只是必须记录master的编号。通过为所有之前有split传输关联的master声明HSPLITx中合适的位，然后slave指示它可以处理另一个传输，但是slave没有记录地址和控制信息。</p><p>然后仲裁器能够重新授权master访问，它们也就能够重新尝试传输，给予slave所要求的地址和控制信息。这意外着master在它最终被允许完成它请求的传输前需要被授权许多时间(a number of time)。</p></blockquote><h2 id="11-3-preventing-deadlock"><a href="#11-3-preventing-deadlock" class="headerlink" title="11.3 preventing deadlock"></a>11.3 preventing deadlock</h2><blockquote><p>SPLIT和RETRY响应使用时一定要避免死锁。单个传输不可能锁住AHB,因为每个slave一定被指派在预先规定的周期内去完成传输。但是，如果大量不同的master尝试访问同一个slave，这个slave以不能处理的方式发射SPLIT和RETRY响应时可能发生死锁。</p></blockquote><h3 id="11-3-1-Split"><a href="#11-3-1-Split" class="headerlink" title="11.3.1 Split"></a>11.3.1 Split</h3><blockquote><p>对于能够发射split响应的slave，总线死锁通过确保slave能够经受得住系统中每个master的请求来避免(最多16个)。slave没必要保存每次传输的地址和控制信息，它仅仅需要记录这样的事实：一次传输请求已经发出，并且一个SPLIT响应也发出。最终所有的master都将在一个较低优先级，然后slave可以有序地处理这些请求，向仲裁器指示它正在处理哪个请求，因此保证所有的请求最终都被完成。</p><p>当一个slave有许多未完成的请求，它可以选择以任何次序去处理它们，尽管slave一定要注意<code>锁定的传输</code>(locked transfer)必须在任何其它传输可以继续之前完成。</p><p>理想情况下，master的未完成传输量不应该超过它所能支持的传输量，但是需要这种机制来防止总线死锁。</p></blockquote><h3 id="11-3-2-Retry"><a href="#11-3-2-Retry" class="headerlink" title="11.3.2 Retry"></a>11.3.2 Retry</h3><blockquote><p>对于发送<code>RETRY</code>响应的slave每次只能由一个master访问。这不是由总线的协议强制执行的，应该由系统体系结构确保。大多数情况下，发送RETRY响应的slave可能是那些一次只有一个master访问的外围设备，所以能够被更高级别协议确保。</p><p>对多master访问RETRY slaves的硬件保护不是本协议的要求，但可按下一段所述实现。在总线级别上，只要求slave一定要在预定数量的时钟周期内驱动HREADY到高电平。</p></blockquote><p>如果需要硬件保护，那么可以在RETRY slave本身上实现。当一个slave发射一个RETRY，它能采样master号码。在该时刻和传输最终被完成之间，slave检查每个传输尝试，以确保是相同的master号码。如果它检测到主编号不同，那么它可以采取另一种操作过程，例如：</p><ul><li>ERROR响应</li><li>发送仲裁器一个信号</li><li>系统级别中断(a system level interrupt)</li><li>系统重置(a complete system reset)</li></ul><h2 id="11-4-Bus-handover"><a href="#11-4-Bus-handover" class="headerlink" title="11.4 Bus handover"></a>11.4 Bus handover</h2><blockquote><p>协议要求master在接收分割(split)或重试(retry)响应后,立即执行一次IDLE传输好让总线被转交给另一个master。</p><p><img src="https://image.beenli.cn/img/20201008/Xp2VmFI5Vsgp.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><ul><li>T1之后传输的地址出现在总线上；在T2和T3时钟沿后slave返回两个周期SPLIT响应</li><li>第一个响应周期结束，T3，master检测到传输被分割(be SPLIT)所以它改变下一次传输的控制信号为IDLE。</li><li>同时在T3，仲裁器采样响应信号并发现传输将是SPLIT。然后仲裁器能够调整仲裁优先级，并且grant信号在接下来的一个周期发生改变，以至于新的master能够被授权地址总线在T4之后。</li><li>⭐新master被保证立刻访问，因为IDLE传输总是在一个周期完成。</li></ul></blockquote><h1 id="12-Reset"><a href="#12-Reset" class="headerlink" title="12 Reset"></a>12 Reset</h1><blockquote><p><code>HRESETn</code>是AHB文档中唯一的低电平有效的信号，并且是所有总线元件的主要复位。复位可异步声明，但是在HCLK上升沿之后同步失效(deasserted)。</p><p>在复位期间，所有master确保地址和控制信号都在有效状态并且<code>HTRANS[1:0]</code>指示IDLE。</p></blockquote><h1 id="13-Data-bus-width"><a href="#13-Data-bus-width" class="headerlink" title="13 Data bus width"></a>13 Data bus width</h1><blockquote><p>在不提高操作频率下，提高总线带宽的一种方法是提高总线数据通道宽度。金属层的增加和大片内存储块的使用(例如嵌入的DRAM)都是鼓励更宽总线的使用的驱动因素。</p><p>指定一个固定宽度的总线意味着，在许多情况下总线的宽度对于应用不是最优的。因此，我们采用灵活的总线宽度，但是任然保证模块在设计之间具有高度的可移植性(highly portable)</p><p><a href="#size">AHB协议允许数据总线为8，16，32，64，128，256，512或者1024bits</a>。但是，我们推荐最小总线宽度为32bits,预计最大256bits将对绝大多数应用都是足够的。</p><p>对于读和写传输，接收模块必须从总线上正确的字节通道选择数据。不需要跨所有字节通道复制数据。</p></blockquote><h1 id="14-narrow-slave-on-wide-bus"><a href="#14-narrow-slave-on-wide-bus" class="headerlink" title="14 narrow slave on wide bus"></a>14 narrow slave on wide bus</h1><blockquote><p>👇图展示了一个原本被设计成处理32位数据总线的slave模块，是如何被轻松转换为处理64位总线。这仅仅需要额外的外部逻辑，而不需要任何内部设计的改变，因此这项技术也可以被用到硬宏单元。</p></blockquote><p><img src="https://image.beenli.cn/img/20201008/Lrfh7n73r7V5.png?imageslim" srcset="/img/loading.gif" alt="mark"></p><p>对于输出，当转化窄的总线到一个宽的总线，做下面中的一条：</p><ul><li>将数据复制到宽总线的两个部分(像👆)</li><li>使用额外层次逻辑确保总线只有合适的半部分改变。这可以节约能耗。</li></ul><h1 id="15-wide-slave-on-narrow-slave"><a href="#15-wide-slave-on-narrow-slave" class="headerlink" title="15 wide slave on narrow slave"></a>15 wide slave on narrow slave</h1><blockquote><p>👇图展示了一个宽接口的slave被实现在一个窄的总线上。</p></blockquote><p><img src="https://image.beenli.cn/img/20201008/YzRiClD91a4p.png?imageslim" srcset="/img/loading.gif" alt="mark"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/RISC-V/">RISC-V</a> <a class="hover-with-bg" href="/categories/RISC-V/spec/">spec</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/specification/">specification</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/d1f5324a/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">AMBA AHB spec(2)--bus interface</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/posts/8cc45ed0/"><span class="hidden-mobile">12-hour clock using six BCD digits</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="vcomments"></div><script type="text/javascript">Fluid.utils.waitElementVisible("vcomments",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.4/Valine.min.js",(function(){new Valine({el:"#vcomments",app_id:"wL8cVEADdoKpEaDDPPnBR9sm-gzGzoHsz",app_key:"2oJflENqEmJ8ccfv0XLxRL8O",placeholder:"说点什么",path:window.location.pathname,avatar:"monsterid",meta:["nick","mail","link"],pageSize:"10",lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the <a href="https://valine.js.org" rel="nofollow noopener">comments powered by Valine.</a></noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂ICP备20001266号</a></span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e003c704a60a6fe8b1437118b71fea30";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>