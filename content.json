{"meta":{"title":"BeenLi's blog","subtitle":"趁还年轻, 多折腾几下","description":"平常爱打球, 听歌, 看书.<br>吉林大学17级微电子, 辅修CS","author":"Wan Li","url":"http://blog.beenli.com","root":"/"},"pages":[{"title":"categories","date":"2020-03-30T15:37:02.000Z","updated":"2020-04-02T11:11:56.647Z","comments":false,"path":"categories/index.html","permalink":"http://blog.beenli.com/categories/","excerpt":"","text":"目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-03-30T15:39:32.000Z","updated":"2020-03-31T11:43:51.021Z","comments":false,"path":"tags/index.html","permalink":"http://blog.beenli.com/tags/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-03-31T11:43:04.000Z","updated":"2020-04-04T02:27:03.039Z","comments":true,"path":"about/index.html","permalink":"http://blog.beenli.com/about/","excerpt":"","text":"🏫17级 吉林大学 微电子；辅修计算机 ❤打球，编程，看书，看电影 搭建这个博客主要是为了记录学习、生活过程中遇到的问题和解决办法。 博客的内容都是个人原创，整理，或者转载而成，不免会有错误的地方，如果发现错误欢迎您与我联系；如果有侵权的内容，我很抱歉，欢迎您联系我立马删除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-03-31T13:03:56.998Z","updated":"2020-03-31T03:35:18.941Z","comments":true,"path":"js/fold_action.js","permalink":"http://blog.beenli.com/js/fold_action.js","excerpt":"","text":"$(document).ready(function(){ $(document).on('click', '.fold_hider', function(){ $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); }); //默认情况下折叠 $(\"div.fold\").css(\"display\",\"none\"); }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"testbench(1)","slug":"testbench-1","date":"2020-04-04T02:38:11.000Z","updated":"2020-04-04T03:16:14.590Z","comments":true,"path":"posts/26241a85/","link":"","permalink":"http://blog.beenli.com/posts/26241a85/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"单链表翻转","slug":"单链表翻转","date":"2020-03-31T15:51:58.000Z","updated":"2020-04-03T12:21:04.484Z","comments":true,"path":"posts/39c22857/","link":"","permalink":"http://blog.beenli.com/posts/39c22857/","excerpt":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }","text":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; } 解法二、三指针法struct ListNode *reverseList(struct ListNode* head) { if (head == NULL) { // 如果为NULL，那么后指针越界。 return NULL; } struct ListNode *p0 = NULL; struct ListNode *p1 = head; struct ListNode *p2 = head-&gt;next; while (p1 != NULL) { p1-&gt;next = p0; p0 = p1; p1 = p2; if (p2 != NULL) { p2 = p2-&gt;next; } } return p0; } 参考博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://blog.beenli.com/categories/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"http://blog.beenli.com/tags/C/"}]},{"title":"开发工具","slug":"开发工具","date":"2020-03-31T11:57:08.000Z","updated":"2020-04-03T12:11:16.599Z","comments":true,"path":"posts/bc753b52/","link":"","permalink":"http://blog.beenli.com/posts/bc753b52/","excerpt":"","text":"vim + iverilog + gtkwave 1、What is Icarus Verilog Icarus Verilog is a Verilog simulation and synthesis tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called vvp assembly. This intermediate form is executed by the vvpcommand. For synthesis, the compiler generates netlists in the desired format.^iverilog ​ 从官网的描述我们可以看到: 它是一个仿真器和综合器。 ​ 有趣的是：开发者是一名软件工程师 ​ a software engineer specializing in device drivers and embedded systems 2、Why we choose Icarus Verilog 软件非常小，没有图形界面。跑跑小的程序足够了 软件扩展性特别好。我现在还没有去探索。详情见 软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的 3、How to use it 像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码 然后在编辑器里一键运行脚本，或者在终端运行。 终端主要记住几个命令即可: (后面很会详细说明) iverilog -o filename filename.v // 编译源文件 【-o 指定生成的文件名称】 vvp filename // 仿真testbench gtkwave filename.vcd // 查看仿真的波形图 4、Instance case 编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM) // 模8计数器。存储为count8.v module count8(clk, rst_n, cnt); input clk, rst_n; output[3:0] cnt; reg[3:0] cnt; always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 4'b0000; else if(cnt[3]) cnt &lt;=4'b0000; else cnt &lt;= cnt + 1'b1; end endmodule 编译一下 iverilog -o counter8 counter8.v ​ ​ 可以看到已经编译成功，生成了count8文件。即上述命令-o后面指定的。 如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。 编写测试代码 `include \"count8.v\" `timescale 1ns/1ns module count8_tb; // 数据结构声明 reg clk; reg rst_n; wire[3:0] cnt; // 实例化待测试模块 count8 U1(clk, rst_n, cnt); // 测试激励信号 always #50 clk = ~ clk; initial begin clk = 1'b0; rst_n = 1'b0; #20 rst_n = 1'b0; #200 rst_n = 1'b1; end // 输出响应 initial begin wait(cnt == 4'b1000) $display($time,,,\"cnt = %b\", cnt); $dumpfile(\"count8_tb.vcd\"); // 很关键，把仿真的数据存储到文件,待会波形图要用 $dumpvars(0, count8_tb); // 设置要观察的变量 end endmodule 编译，仿真，生成波形图 iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd 注意: 由于仿真程序没有设定停止时间。程序会一直执行。 如果你想自动停止（可以在testbench上加上# 500$stop,那么程序仿真500个tick就停止) 如果你没有加停止指令。只能手动停止ctrl+c然后你可以打印当前仿真的时间。如果不够 你可以继续仿真。如果可以了就finish 最后用gtkwave 查看你刚刚仿真生成的count8_tb.vcd文件。 如果你喜欢用modelsim也可以。 也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。 具体教程见 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"}]}],"categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://blog.beenli.com/categories/Data-Structure/"},{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"}],"tags":[{"name":"C","slug":"C","permalink":"http://blog.beenli.com/tags/C/"},{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"}]}