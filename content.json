{"meta":{"title":"BeenLi's blog","subtitle":"趁还年轻, 多折腾几下","description":"平常爱打球, 听歌, 看书.<br>吉林大学17级微电子, 辅修CS","author":"Wan Li","url":"http://blog.beenli.com","root":"/"},"pages":[{"title":"categories","date":"2020-03-30T15:37:02.000Z","updated":"2020-04-02T11:11:56.647Z","comments":false,"path":"categories/index.html","permalink":"http://blog.beenli.com/categories/","excerpt":"","text":"目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-03-30T15:39:32.000Z","updated":"2020-03-31T11:43:51.021Z","comments":false,"path":"tags/index.html","permalink":"http://blog.beenli.com/tags/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-03-31T11:43:04.000Z","updated":"2020-04-04T02:27:03.039Z","comments":true,"path":"about/index.html","permalink":"http://blog.beenli.com/about/","excerpt":"","text":"🏫17级 吉林大学 微电子；辅修计算机 ❤打球，编程，看书，看电影 搭建这个博客主要是为了记录学习、生活过程中遇到的问题和解决办法。 博客的内容都是个人原创，整理，或者转载而成，不免会有错误的地方，如果发现错误欢迎您与我联系；如果有侵权的内容，我很抱歉，欢迎您联系我立马删除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-03-31T13:03:56.998Z","updated":"2020-03-31T03:35:18.941Z","comments":true,"path":"js/fold_action.js","permalink":"http://blog.beenli.com/js/fold_action.js","excerpt":"","text":"$(document).ready(function(){ $(document).on('click', '.fold_hider', function(){ $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); }); //默认情况下折叠 $(\"div.fold\").css(\"display\",\"none\"); }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Gate-and-switch-level modeling","slug":"Gate-and-switch-level-modeling","date":"2020-04-05T01:54:38.000Z","updated":"2020-04-05T06:22:41.879Z","comments":true,"path":"posts/aff089ac/","link":"","permalink":"http://blog.beenli.com/posts/aff089ac/","excerpt":"","text":"Gate-and-switch-level modeling1、verilog-std-1364-20051There are 14 logic gates and 12 switches predefined in the Verilog HDL to provide the gate- and switch-level modeling facility. Modeling with logic gates and switches has the following advantages:— Gates provide a much closer one-to-one mapping between the actual circuit and the model.— There is no continuous assignment equivalent to the bidirectional transfer gate.Verilog1364-2005标准规定了26个基本原件，其中14个门级原件，12个开关级原件。对于这些原件不需要定义直接调用。2、门级建模2多输入门：n_input_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal { , input_terminal } ) and A1(out1, in1, in2); or O1(outa, inb, inc, ind); xor X1(outx, inx, iny, inz, inw);多输出门调用:n_output_gate_instance ::= [ name_of_gate_instance ] ( output_terminal { , output_terminal } , input_terminal ) buf BUF_1(bufout1, bufout2, bufout3, bufin); not NOT_1(out1, out2, in);三态门调用:enable_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , enable_terminal ) bufif1 BF1(data_bus, data, enable);二个电阻The instance declaration of a pullup or a pulldown source shall begin with one of the following keywords: pullup , pulldownpull_gate_instance ::= [ name_of_gate_instance ] ( output_terminal ) pullup (strong1) p1 (neta), p2 (netb); In this example, the p1 instance drives neta and the p2 instance drives netb with strong strength.注意: 门级原件的端口列表都固定好了，可以不用定义中间连接信号类型(wire)示例：// 门级建模实现最小项表达式 // F(a, b, c) = m1 + m2 + m3 + m6 + m7 = (!a)c + b module zuixiaoxiang(out, a, b, c); input a, b, c; output out; wire s1, s2; not U1(s1, a); and U2(s2, s1, c); or U3(out, s2, b); endmodule 3、开关级建模MOS switchescmospmosnmosrcmosrnmosrpmosrmos : 代表晶体管导通时源漏有较高的阻抗(impedance)The following example declares a pmos switch: pmos p1 (out, data, control); The output is out , the data input is data , and the control input is control.The instance name is p1 .Bidirectional pass switches(双向开关)trantranif1tranif0rtranrtranif1rtranif0The bidirectional pass switches shall not delay signals propagating through them. When tranif0, tranif1,rtranif0, or rtranif1 devices are turned off, they shall block signals; and when they are turned on, they shall pass signals. The tran and rtran devices cannot be turned off, and they shall always pass signals.(双向开关没有传播延时)The following example declares an instance of tranif1: tranif1 t1 (inout1,inout2,control); The bidirectional terminals are inout1 and inout2 . The control input is control . The instance name is t1 .示例：// 2输入与门 // time:2020-04-05 module and2_1(out, a, b); input a,b; output out; wire s1, s2; supply0 Gnd; supply1 Vdd; pmos U1(s1, Vdd, a); pmos U2(s1, Vdd, b); nmos U3(s1, s2, a); nmos U4(s2, Gnd, b); pmos U5(out, Vdd, s1); nmos U6(out, Gnd, s1); endmodulequarter II 综合不了，没办法直接看viewer。只能把书上的图扒来了。终于找到了一款RTL级，gate级，开关级debugger和viewer的软件trainsistor-level debugger and viewer但是目前下载不了，得找客服联系。不知有人有用过这款软件没有。有的话请你一定告诉我。Renference[1] verilog-std-1364-2005[2] 蔡觉平.2015.Verilog HDL 数字集成电路高级程序设计 31P document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"}]},{"title":"图床+评论","slug":"图床-评论","date":"2020-04-04T10:11:31.000Z","updated":"2020-04-05T07:48:10.443Z","comments":true,"path":"posts/7928fb24/","link":"","permalink":"http://blog.beenli.com/posts/7928fb24/","excerpt":"","text":"图床+评论1、什么是图床图床一般是指储存图片的服务器；就跟百度网盘差不多。只不过它是专门存储图片的。有的也可以存储文件。有很多免费的图床。会赠送10G存储空间2、为什么要用图床用图床很方便。服务器会生成一个外链。在互联网任何地方都能访问到用图床访问速度很快。服务商会使用cdn加速用图床可以节省本地空间。3、七牛云图床的使用注册一个账号（需要身份认证）创建一个存储空间注意空间名称是唯一。访问控制：选择私有：别人无法访问。如果是写博客或者公众号还是选择公开吧！这样外链别人是可以看得到的。绑定备案的域名​ 可以看到：如果不绑定自己的域名；系统30天后回收回。那么你之前的外链都失效了​ 所以最好绑定自己的域名才上线。如果你只想试试，那么到这里你就可以结束了。开始体验图床。上传完文件，然后返回。你就可以点击操作—&gt;更多—–&gt;复制外链这时候你就可以直接从浏览器输入这个外链访问到你刚刚上传的文件。这里推荐一个Windows平台图床神器；大概长这样。登陆上你之前注册的七牛云账号就可以使用了。用图床上传图片遇到的坑：由于七牛云默认生成的外链的是http的，有些浏览器会阻塞这种不安全资源。我只好去修改协议。这时遇到第二个坑。要使用https协议，你绑定的域名必须有证书。我在网上到处找，买的证书太贵，划不来。免费的证书授权又太慢。最后终于找到了一款免费证书ssl发放机构。freessl其间要下载一个软件（keymanager)最后生成证书的过程很快几分钟就搞定。4、Valine评论系统hexo的很多主题都内嵌了这个系统，你只需要去cleancloud注册个账号获取id和key填入配置文件里面就能用如果你想要邮件通知或者后台评论管理可以用这个插件Valine-Admin项目部署的一定要注意smtp_pass是授权码或者QQ独立密码，不是登陆密码。部署完成效果如下。​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software skills","slug":"Software-skills","permalink":"http://blog.beenli.com/categories/Software-skills/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.beenli.com/tags/Hexo/"}]},{"title":"testbench(1)","slug":"testbench-1","date":"2020-04-04T02:38:11.000Z","updated":"2020-04-05T07:51:32.253Z","comments":true,"path":"posts/26241a85/","link":"","permalink":"http://blog.beenli.com/posts/26241a85/","excerpt":"","text":"Testbench(1)1、testbench的结构testbench没有输入输出接口测试模块只负责对待测试系统接口提供激励信号;并监控输出testbench代码不需要可综合，即不被实现成电路产生适当的激励并达到覆盖率要求2、测试激励的描述方式信号的初始化第一种: initial 初始化 initial a = 0; 第二种: 定义信号时初始化 reg[3:0] cnt = 4'b1010;延迟控制延迟语句外部时间控制initial #5 a = b;(等待5tick后计算右端的值并赋值给左边👈) 等价于: initial begin #5; a=b; end内部时间控制initial a = #5 b;(先计算右端的值，等待5tick后再把值赋给左边👈) 等价于 initial begin temp = b; #5; a = temp; end验证程序如下：可以清楚地看到：​ 第一种延时语句，在0-5tick之间只要b变化了,那么第五tick时刻a被赋予的值就是b第五时刻的值。​ 而第二种延时语句：b的值在0时刻已经定好了，不管b在这期间怎么变化，a最终得到的是b在0时刻的值。事件语句@(&lt;事件表达式&gt;);@(&lt;事件表达式&gt;)行为语句;initial begin # 10 @(posedge en) in = ~in; //en的👆上升沿到来时,in取反 end事件语句@必须等指定事件到来才执行等待语句wait(&lt;条件表达式&gt;) 行为语句always #5 cnt=cnt+1'b1; initial wait(cnt == 4'b1111) $display($time,,,\"cnt = %b\", cnt); end等待语句只有条件为真时才执行。可以看到第0时刻cnt = 0第5时刻cnt = 1以此类推；直到第75时刻 cnt = 15再过10tick 就终止仿真了。总过时常85tick document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"}]},{"title":"单链表翻转","slug":"单链表翻转","date":"2020-03-31T15:51:58.000Z","updated":"2020-04-05T01:57:51.816Z","comments":true,"path":"posts/39c22857/","link":"","permalink":"http://blog.beenli.com/posts/39c22857/","excerpt":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }","text":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; } 解法二、三指针法struct ListNode *reverseList(struct ListNode* head) { if (head == NULL) { // 如果为NULL，那么后指针越界。 return NULL; } struct ListNode *p0 = NULL; struct ListNode *p1 = head; struct ListNode *p2 = head-&gt;next; while (p1 != NULL) { p1-&gt;next = p0; p0 = p1; p1 = p2; if (p2 != NULL) { p2 = p2-&gt;next; } } return p0; }参考博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://blog.beenli.com/categories/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"http://blog.beenli.com/tags/C/"}]},{"title":"开发工具","slug":"开发工具","date":"2020-03-31T11:57:08.000Z","updated":"2020-04-05T02:27:32.339Z","comments":true,"path":"posts/bc753b52/","link":"","permalink":"http://blog.beenli.com/posts/bc753b52/","excerpt":"","text":"vim + iverilog + gtkwave1、What is Icarus VerilogIcarus Verilog is a Verilog simulation and synthesis tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called vvp assembly. This intermediate form is executed by the vvpcommand. For synthesis, the compiler generates netlists in the desired format.1​ 从官网的描述我们可以看到: 它是一个仿真器和综合器。​ 有趣的是：开发者是一名软件工程师​ a software engineer specializing in device drivers and embedded systems2、Why we choose Icarus Verilog软件非常小，没有图形界面。跑跑小的程序足够了软件扩展性特别好。我现在还没有去探索。详情见软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的3、How to use it像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码然后在编辑器里一键运行脚本，或者在终端运行。终端主要记住几个命令即可: (后面很会详细说明)iverilog -o filename filename.v // 编译源文件 【-o 指定生成的文件名称】 vvp filename // 仿真testbench gtkwave filename.vcd // 查看仿真的波形图4、Instance case编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)// 模8计数器。存储为count8.v module count8(clk, rst_n, cnt); input clk, rst_n; output[3:0] cnt; reg[3:0] cnt; always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 4'b0000; else if(cnt[3]) cnt &lt;=4'b0000; else cnt &lt;= cnt + 1'b1; end endmodule编译一下 iverilog -o counter8 counter8.v​ ​ 可以看到已经编译成功，生成了count8文件。即上述命令-o后面指定的。如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。编写测试代码`include \"count8.v\" `timescale 1ns/1ns module count8_tb; // 数据结构声明 reg clk; reg rst_n; wire[3:0] cnt; // 实例化待测试模块 count8 U1(clk, rst_n, cnt); // 测试激励信号 always #50 clk = ~ clk; initial begin clk = 1'b0; rst_n = 1'b0; #20 rst_n = 1'b0; #200 rst_n = 1'b1; end // 输出响应 initial begin wait(cnt == 4'b1000) $display($time,,,\"cnt = %b\", cnt); $dumpfile(\"count8_tb.vcd\"); // 很关键，把仿真的数据存储到文件,待会波形图要用 $dumpvars(0, count8_tb); // 设置要观察的变量 end endmodule 编译，仿真，生成波形图iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd注意:由于仿真程序没有设定停止时间。程序会一直执行。如果你想自动停止（可以在testbench上加上# 500$stop,那么程序仿真500个tick就停止)如果你没有加停止指令。只能手动停止ctrl+c然后你可以打印当前仿真的时间。如果不够你可以继续仿真。如果可以了就finish最后用gtkwave 查看你刚刚仿真生成的count8_tb.vcd文件。如果你喜欢用modelsim也可以。也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。具体教程见references[1] iverilog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"}]}],"categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"http://blog.beenli.com/categories/Digital-IC/"},{"name":"Software skills","slug":"Software-skills","permalink":"http://blog.beenli.com/categories/Software-skills/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://blog.beenli.com/categories/Data-Structure/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://blog.beenli.com/tags/verilog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.beenli.com/tags/Hexo/"},{"name":"C","slug":"C","permalink":"http://blog.beenli.com/tags/C/"}]}