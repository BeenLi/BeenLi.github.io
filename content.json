{"meta":{"title":"BeenLi's blog","subtitle":"趁还年轻, 多折腾几下","description":"平常爱打球, 听歌, 看书.<br>吉林大学17级微电子, 辅修CS","author":"Wan Li","url":"https://www.beenli.cn","root":"/"},"pages":[{"title":"about","date":"2020-03-31T11:43:04.000Z","updated":"2020-04-04T02:27:03.039Z","comments":true,"path":"about/index.html","permalink":"https://www.beenli.cn/about/","excerpt":"","text":"🏫17级 吉林大学 微电子；辅修计算机❤打球，编程，看书，看电影搭建这个博客主要是为了记录学习、生活过程中遇到的问题和解决办法。博客的内容都是个人原创，整理，或者转载而成，不免会有错误的地方，如果发现错误欢迎您与我联系；如果有侵权的内容，我很抱歉，欢迎您联系我立马删除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-03-30T15:39:32.000Z","updated":"2020-03-31T11:43:51.021Z","comments":false,"path":"tags/index.html","permalink":"https://www.beenli.cn/tags/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-03-30T15:37:02.000Z","updated":"2020-04-02T11:11:56.647Z","comments":false,"path":"categories/index.html","permalink":"https://www.beenli.cn/categories/","excerpt":"","text":"目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"超前进位加法器","slug":"超前进位加法器","date":"2020-04-28T09:31:08.000Z","updated":"2020-04-28T09:31:08.276Z","comments":true,"path":"posts/1aa82b80/","link":"","permalink":"https://www.beenli.cn/posts/1aa82b80/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Git for novice","slug":"Git-for-novice","date":"2020-04-27T10:09:18.000Z","updated":"2020-04-28T04:49:12.995Z","comments":true,"path":"posts/f05478c5/","link":"","permalink":"https://www.beenli.cn/posts/f05478c5/","excerpt":"","text":"1、Git and GitHubGithub 可以看成是一个基于Git的系统，它提供了仓库的可视化。是一个远程托管仓库。如果是public，其他人可以随意查看，修改。如果是private只有你自己可以查看了。如果为了安全，可以团队自己搭建一个git服务器。Git大家都已经很熟悉了，分布式版本控制系统(Distributed version control system)2、Why do we use git可以更好地在GitHub上开发，分享啊。多人协同开发。版本控制，可以任意回滚到之前某个版本。3、How do we use git场景1在GitHub上看到一个不错的项目，想要研究，学习为目的。先fork一份到自己的GitHub上。clone到本地-o 指定远程仓库的名字，否则默认为origingit clone [-b &lt;指定分支名&gt;]&lt;远程仓库地址&gt; [-o booyah] 默认是克隆所有分支。进行自己的开发。修改文件后此时git status可以看到：修改过的文件红色标处。Untracked filesgit add ./[filename] // 把修改过的文件添加到暂存区。此时文件变成绿色。即已经添加到了暂存区。提交git commit -m \"添加文件的说明\" // 提交提交完成了，工作目录应该显示是空的。推送到远程仓库git pull origin [branch name] // 推送到指定仓库的指定分支上。场景2自己新建一个仓库。做项目开发。初始化一个本地仓库git init xxx // 新建一个名为xxx的仓库进入仓库，然后就可以开发了。cd xxx // 此目录就是工程根目录。如果要上传到GitHub上。即远端git服务器首先在GitHub上新建一个仓库。本地仓库与远程仓库建立联系。git remote add origin &lt;server&gt; // 与GitHub仓库建立联系. origin 可以换成任意名字。可以看到我通过origin pull不上去。因为我连接的是remote_name。push到远程服务器上git push origin master // 推送到远程服务器上如果是克隆远程仓库的话，那么可以跳过remote（因为本地master已经和远程master联系上了)。直接推送到远程服务器。4、common commands11、branch（分支)1、新建分支git checkout -b xxx // 新建分支并切换到xxx git branch xxx // 只是新建一个分支，仍留在本地。（新建的分支复刻目分支)git branch [-b branchName commitId] 从指定分支和commit号上开始新的分支2、分支切换git branch [-a] //查看分支 git checkout xxx //切换到xxx分支git branch 参数-a: 查看所有分支，包括远端的分支。 -v 查看分支指向的commit。 —remote查看远程分支3、合并分支先把你次要分支提交完全。切换到你要合并其他分支的主分支上合并git merge test // 在主分支上合并test分支可以看到已经合并了test1分支。现在它们指向同一个commit。如果遇到冲突，手动判断哪一个修改留下。4、删除分支git branch -d [branch name] git push origin --delete [branch name] // 删除远程分支 $ git push origin --delete testing To github.com:BeenLi/learn_git.git - [deleted] testing5、远程分支$ git ls-remote // 查看远程分支 From git@github.com:BeenLi/learn_git.git 6fc7758ee27a73196a81391efd803dc19541eb88 HEAD 6fc7758ee27a73196a81391efd803dc19541eb88 refs/heads/master 807b956e7a57eef2f148dc7cb5b14ae3992955e6 refs/heads/testing 807b956e7a57eef2f148dc7cb5b14ae3992955e6 refs/pull/1/head 998239f25772ea809310d9f92c9e96a67c158b82 refs/pull/1/merge $ git remote show // 查看远程仓库名字 remote_name“origin” 是当你运行 git clone 时默认的远程仓库名字6、跟踪分支git checkout -b [branch] [remotename]/[branch] git checkout --track origin/serverfix // 快捷命令 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支 git branch --set-upstream-to origin/remoteBranchName localBranchName 修改远程分支 git branch --unset-upstream // 撤销跟踪远程分支可以看到 设置了分支test3 跟踪 远端的master分支。现在分支与master分支相同。现在，本地分支 test 会自动从 remote_name/master 拉取。$ git branch -vv master 2b2be16 修改文件，制造合并冲突 test1 2b2be16 修改文件，制造合并冲突 test2 420f721 第二次本地提交 testing e051a6f [remote_name/testing: ahead 1] 测试追踪分支情况 * test3 4fdb7bd [remote_name/master] 测试本地提交 可以看到test3 是master的跟踪分支。 testing分支领先1。表示有本地有一个commit没有push到服务器上。7、分支拉取git pull == git fetch + git merge git fetch 不会修改当前工作区的文件。它只会获取数据然后让你自己合并。8、上传分支git push origin localbranch:remotebranch 如果添加了远程分支就直接push了。2、reset (撤销)参考🔗1、reset —hardreset —hard：重置stage区和工作目录(会在重置 HEAD 和branch的同时，重置stage区和工作目录里的内容)即回到上一次commit的位置。，全部清空。2、reset —softreset —soft：保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区即你之前commit的文件，退回到stage。需要重新提交。3、reset [—mixed]reset: 保留工作目录，并清空暂存区也就是你要重新add，然后commit。Reference[1] 分支用法[2] reset用法[3] 简明教程[4] 动态过程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software skills","slug":"Software-skills","permalink":"https://www.beenli.cn/categories/Software-skills/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"}]},{"title":"数据结构——树","slug":"数据结构——树","date":"2020-04-09T05:43:31.000Z","updated":"2020-04-25T15:52:20.014Z","comments":true,"path":"posts/f796a091/","link":"","permalink":"https://www.beenli.cn/posts/f796a091/","excerpt":"","text":"1、树的相关术语度：一个结点的子结点数目。树的度指度数最大的那个结点的度TD = max_{i=1...n}D(i)\\quad D(i)表示第i个结点的度叶结点，分支结点度为0的结点——叶结点；度大于0的结点——分支结点结点的层数(1) root(T)——层数为0(2)其余结点层数为前驱结点层数 + 1路径V_m——>V_{m+1}——>...——>V_{m+k} \\quad1","categories":[{"name":"计算机","slug":"计算机","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"Data Structure","slug":"计算机/Data-Structure","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"}]},{"title":"Tasks and Functions","slug":"Tasks-and-Functions","date":"2020-04-08T14:20:43.000Z","updated":"2020-04-25T16:07:54.821Z","comments":true,"path":"posts/71407778/","link":"","permalink":"https://www.beenli.cn/posts/71407778/","excerpt":"","text":"Tasks and Functions1、What are they good forTasks and functions provide the ability to execute common procedures from several different places in a description. They also provide a means of breaking up large procedures into smaller ones to make it easier to read and debug the source descriptions.从std 1364-2005的这段描述中，我们可以总结出以下用处:减少重复工作，代码复用。把大的过程拆解成几个小的任务和函数，更加易读和找bug2、Distinctions between tasks and functionsA function shall execute in one simulation time unit; a task can contain time-controlling statements.函数应该瞬间返回结果，不能有延时；而任务可以带有延时控制语句。A function cannot enable a task; a task can enable other tasks and functions.函数不能调用任务；但是任务可以调用其他任务或者函数。A function shall have at least one input type argument and shall not have an output or inout type argument; a task can have zero or more arguments of any type.函数应该至少有一个输入参数并且不能有输出或者输入输出参数。任务可以有零个或者任意个任何种类的参数。A function shall return a single value; a task shall not return a value.函数应该返回一个单一的值；任务不能返回值(只能通过把处理放在参数上带回)The purpose of a function is to respond to an input value by returning a single value. A task can support multiple goals and can calculate multiple result values. However, only the output or inout type arguments pass result values back from the invocation of a task. A function is used as an operand in an expression; the value of that operand is the value returned by the function.函数的目的：对于输入给出一个返回结果任务支持多个结果，但是只有输出或者输入输出参数能够传递这种结果函数可以在表达式中用作一个操作数。（其值就是函数返回的结果。是不是很像C)例如：switch_bytes(old_word, new_word); //task会把运算结果放在new_word上 new_word = switch_bytes(old_word); //function会直接把结果返回。比较点tasksfunctions输入输出任意多输入输出(input,output,inout)至少一个输入不能有输出触发事件控制可以包含延时控制语句(#), 只能面向仿真，不能综合不能出现always, # 等语句，函数应该在一个时间单元内返回值返回值通过输出端口传递通过函数名返回(only one)中段可以由disable中断不能语句调用其他可以调用task和function只能调用function，不能调用task其他说明task调用可以作为完整的语句出现function调用只能作为赋值语句右边的operand3、 Tasks and task enablingA task shall be enabled from a statement that defines the argument values to be passed to the task and the variables that receive the results. Control shall be passed back to the enabling process after the task has completed. Thus, if a task has timing controls inside it, then the time of enabling a task can be different from the time at which the control is returned. A task can enable other tasks, which in turn can enable still other tasks—with no limit on the number of tasks enabled. Regardless of how many tasks have been enabled,control shall not return until all enabled tasks have completed.调用task应该给出传进参数的值，和接受结果的变量。task如果有延时控制，那么task被调用时刻和控制返回时刻可以不同。task内可以再调用task，直到所有的task完成才会返回控制到顶层调用处。3.1、task declaration syntaxestask_declaration ::= (From A.2.7) task [ automatic ] task_identifier ; { task_item_declaration } statement_or_null endtask task_declaration ::= (From A.2.7) task [ automatic ] task_identifier ( [ task_port_list ] ) ; { block_item_declaration } statement_or_null endtaskTasks without the optional keyword automatic are static tasks, with all declared items being statically allocated. These items shall be shared across all uses of the task executing concurrently. All items declared inside automatic tasks are allocated dynamically for each invocation Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through use of their hierarchical name.（automatic的坑后面再填)3.2、Task enabling and argument passingtask_enable ::= (From A.6.9) hierarchical_task_identifier [ ( expression { , expression } ) ] ;If the argument is declared as an output or an inout, then the expression shall be restricted to an expression that is valid on the left-hand side of a procedural assignment.(输出参数：能位于过程赋值语句左边的有效表达式。不能是wire)reg, integer, real, realtime, and time variablesMemory referencesConcatenations of reg, integer, and time variablesConcatenations of memory referencesBit-selects and part-selects of reg, integer, and time variablesAll arguments to the task shall be passed by value rather than by reference任务参数的是值传递不是引用(指针)If an argument in the task is declared as an input, then the corresponding expression can be any expression.The order of evaluation of the expressions in the argument list is undefined.如果参数被定义为input，那么调用语句与之相应位置的表达式没有限制，表达式求值过程是没有被定义的。（求值顺序没有先后）task my_task; input a, b; inout c; output d, e; begin . . . // statements that perform the work of the task . . . c = foo1; // the assignments that initialize result regs d = foo2; e = foo3; end endtasktask my_task ( input a, b, inout c, output d, e); begin . . . // statements that perform the work of the task . . . c = foo1; // the assignments that initialize result regs d = foo2; e = foo3; end endtask一种是参数列表在函数名后定义。一种是在task里面定义。my_task (v, w, x, y, z); //调用语句The task-enabling arguments ( v , w , x , y , and z ) correspond to the arguments ( a , b , c , d , and e ) defined by the task.当函数调用时:a = v;b = w;c = x;When the task completes, the following assignments to return the computed values to thecalling process are performed:(当函数结束后，下面的赋值返回对应的结果)x = c;y = d;z = e;task enable statement中参数位置要和task definition 对应。不管你是哪种方法定义task3.3、Task memory usage and concurrent :face_with_head_bandage:（可以跳过）A task may be enabled more than once concurrently. All variables of an automatic task shall be replicated on each concurrent task invocation to store state specific to that invocation.All variables of a static task shall be static in that there shall be a single variable corresponding to each declared local variable in a module instance, regardless of the number of concurrent activations of the task. However, static tasks in different instances of a module shall have separate storage from each other.4、Disabling of named blocks and tasksThe disable statement provides the ability to terminate the activity associated with concurrently active procedures, while maintaining the structured nature of Verilog HDL procedural descriptions.（disable 语句可以终止正在运行的过程）begin : block_name rega = regb; disable block_name; regc = rega; // this assignment will never execute endbegin : block_name ... if (a == 0) disable block_name; ... end // end of named block // continue with code following named blocktask proc_a; begin ... ... if (a == 0) disable proc_a; // return if true(控制权交回调用语句) ... ... end endtaskbegin : break for (i = 0; i &lt; n; i = i+1) begin : continue @ clk if (a == 0) // \"continue\" loop disable continue; //(相当于c里面的break) statements statements @ clk if (a == b) // \"break\" from loop disable break; // (相当于c里面的break) statements statements end endfork begin : event_expr @ ev1; repeat (3) @ trig; # d action (areg, breg); //(只有当ev1出现，trig出现3次才触发) end @ reset disable event_expr; //(同上面并行进行) joinalways begin : monostable # 250 q = 0; end always @ retrig begin //（只要retrig变化间隔小于250，那么q就一直为1) disable monostable; q = 1; end5、Functions and function calling5.1、Function declarationsfunction_declaration ::= (From A.2.6) function [ automatic ] [ function_range_or_type ] function_identifier ; function_item_declaration { function_item_declaration } function_statement endfunction | function [ automatic ] [ function_range_or_type ] function_identifier ( function_port_list ) ; { block_item_declaration } function_statement endfunctionfunction [7:0] getbyte; // (如果没有给[range]那么默认为scalar) input [15:0] address; begin // code to extract low-order byte from addressed word . . . getbyte = result _expression; end endfunctionfunction [7:0] getbyte ( input [15:0] address); begin // code to extract low-order byte from addressed word . . . getbyte = result _expression; end endfunction5.2、Returning a value from a functionThe function definition shall implicitly declare a variable, internal to the function, with the same name as the function. This variable either defaults to a 1-bit reg or is the same type as the type specified in the function declaration. The function definition initializes the return value from the function by assigning the function result to the internal variable with the same name as the function.函数定义就隐含了一个变量（即函数名）函数通过给这个隐含变量赋值返回值。5.3、Calling a functionfunction_call ::= (From A.8.2) hierarchical_function_identifier{ attribute_instance } ( expression { , expression } )word = control ? {getbyte(msbyte), getbyte(lsbyte)}:0;(把两次函数调用的结果拼接起来)5.4、Function rulesA function shall not have any nonblocking assignments or procedural continuous assignments.函数不能有非阻塞赋值或者过程连续赋值（在一个时间单位内完成）A function shall not have any event triggers.函数不能有任何时间触发module tryfact; // define the function function automatic integer factorial; input [31:0] operand; integer i; if (operand &gt;= 2) factorial = factorial (operand - 1) * operand; else factorial = 1; endfunction // test the function integer result; integer n; initial begin for (n = 0; n &lt;= 7; n = n+1) begin result = factorial(n); $display (\"%0d factorial=%0d\", n, result);5.5、 Use of constant functions🤕（可以跳过）Constant function calls are used to support the building of complex calculations of values at elaboration time常量函数调用用于支持在精化阶段构建复杂的值计算🙂o_o ….待填坑。Renference[IEEE Std 1364™-2005下载🔗]：链接：https://pan.baidu.com/s/1ryz4IAuQzNPnGifUJ8oAGw提取码：2qvb document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"syntax","slug":"syntax","permalink":"https://www.beenli.cn/tags/syntax/"}]},{"title":"git hooks自动部署hexo","slug":"git-hook自动部署hexo","date":"2020-04-08T01:17:29.000Z","updated":"2020-04-25T16:11:04.739Z","comments":true,"path":"posts/fb29ac9a/","link":"","permalink":"https://www.beenli.cn/posts/fb29ac9a/","excerpt":"","text":"git hooks 自动部署hexo1、原理大致如下2、实施过程在服务器上搭建一个git服务器1adduser git(创建一个用户)可以给创建的用户设置密钥passwd git赋予git用户sudo权限chmod 740 /etc/sudoers vim /etc/sudoer给git用户添加命令权限如下保存后退出，修改回文件权限chmod 440 /etc/sudoers初始化git仓库su git //切换至git用户 mkdir blog.git //创建仓库文件夹 cd blog.git //进入文件夹 git init --bare //使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区创建网站目录sudo mkdir /var/www/blog //创建网站根目录 sudo chown -R git.git /var/www/blog //把blog目录以及子目录属组改为git (这一步很重要，否者后续提交没有权限)配置密钥[详情见:ssh协议](https://www.beenli.cn/posts/782a8ece/mkdir .ssh //创建.ssh目录(默认你在git用户的~目录下) cd .ssh touch authorized_keys //把你本地生成的公钥拷贝到此文件夹种配置hooks(git 用户下)2cd ~/blog.git/hooks //切换到hooks目录 touch post-receive //创建post-receive文件 chmod +x post-receive //赋予其可执行权限The post-receive hook runs after the entire process is completed and can be used to update other services or notify users. It takes the same stdin data as the pre-receive hook. Examples include emailing a list, notifying a continuous integration server, or updating a ticket-tracking system – you can even parse the commit messages to see if any tickets need to be opened, modified, or closed. This script can’t stop the push process, but the client doesn’t disconnect until it has completed, so be careful if you try to do anything that may take a long time.复制该段代码到刚刚创建的post-receive文件#!/bin/bash echo \"post-receive hook is running...\" GIT_REPO=/home/git/blog.git TMP_GIT_CLONE=/tmp/blog PUBLIC_WWW=/var/www/blog rm -rf ${TMP_GIT_CLONE} git clone $GIT_REPO $TMP_GIT_CLONE rm -rf ${PUBLIC_WWW}/* cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}在执行cp（复制)命令的时候，.git 作为隐藏目录不会被拷贝到 Web 根目录下，也就避免了将整个仓库历史暴露在 Web 服务中。最后配置hexo的_config.ymldeploy: type: git repository: git@VPS IP:/~/blog.git # 默认22端口 branch: masterReference[1] Hexo 博客部署到 VPS[2] git hooks document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software skills","slug":"Software-skills","permalink":"https://www.beenli.cn/categories/Software-skills/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.beenli.cn/tags/Hexo/"}]},{"title":"SSH","slug":"SSH","date":"2020-04-07T16:25:51.000Z","updated":"2020-04-25T16:12:52.228Z","comments":true,"path":"posts/782a8ece/","link":"","permalink":"https://www.beenli.cn/posts/782a8ece/","excerpt":"","text":"SSH ProtocolSecure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network.[1] Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH.摘自维基百科。主要为远程登录建立安全的通道。1、简要的工作原理ssh有两种工作方式基于口令验证只要知道帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但缺点是：不能保证你正在连接的服务器就是你想连接的服务器。以下是登录验证流程：基于密钥验证2、操作过程(本地win10+服务器centos)本地生成密钥对\"Git Bash Hear\" ssh-keygen -t rsa可以设置密码，也可以为空（既然为了免密那就设置为空吧，不然没意义了）文件路径可选。默认放在~/.ssh/上传公钥到服务器上1有两种办法：自行把刚刚上传的公钥上传到服务器指定用户.ssh/目录下的authorized_keys下。（认证密钥可以有很多把，多个localhost可以各自上传自己的🔒到服务器上。也可以所有人公用一把锁。）ssh-copy-id -i [./y.pub] username@vps ip(-i指定路径，默认是在.ssh下)这一步也是要认证密码的。不然什么人都可以上锁就乱套。免密登录服务器ssh -i[dir] username@vps ip(-i指定密钥所在，默认在.ssh/下)如果之前产生密钥对时设置了密码，这里还是要输入一遍哪个密码的。如果为空就可以直接免密进入了脚本文件加速登录2随便选择个文件夹，写一个config文件Host vps # 一个便于你区别这是哪台机器的名字 HostName 47.95.247.18 User git # 登录主机的用户名称 Port 22 IdentityFile ~/.ssh/id_rsa # 密钥所在的文件位置 ssh -F [config file] vps(指定配置文件位置)就可以直接登录你设置的那台主机可能遇到的问题3Authentication refused: bad ownership or modes for directory /root/.sshls -l /root/.ssh发现改目录的所有者不是root。只用改成root即可chown -R root.root /root/.sshReference[1] SSH 三步解决免密登录[2] ssh配置config快速登录[3] 解决权限问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机","slug":"计算机","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"Computer Network","slug":"计算机/Computer-Network","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Computer-Network/"}],"tags":[{"name":"协议","slug":"协议","permalink":"https://www.beenli.cn/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"操作系统-熟悉实验环境(1)","slug":"操作系统-熟悉实验环境(1)","date":"2020-04-07T05:07:15.000Z","updated":"2020-04-25T13:59:11.670Z","comments":true,"path":"posts/9cf5ff72/","link":"","permalink":"https://www.beenli.cn/posts/9cf5ff72/","excerpt":"","text":"熟悉实验环境1、x86模拟器Bochs1Bochs is a highly portable open source IA-32 (x86) PC emulator written in C++, that runs on most popular platforms. It includes emulation of the Intel x86 CPU, common I/O devices, and a custom BIOS. Bochs can be compiled to emulate many different x86 CPUs, from early 386 to the most recent x86-64 Intel and AMD processors which may even not reached the market yet.可以看到Boch可以模拟intel x86 CPU在它模拟出的环境中可以运行 Linux、DOS 和各种版本的 Windows 等多种操作系统2、操作系统Ubuntu因为有些实验内容涉及到在自己改进的 Linux 0.11下，运行自己编的应用程序。被改进的功能都是高 版本 Linux 内核已经具有的，在其上确认自己编写的应用程序无误后，再用之测试自己改进的 Linux 0.11，可以更有信心些。3、实验压缩包hit-oslab文件结构:. .. └── bocks | ├── BIOS-bochs-latest | ├── bochs-dbg | ├── bochs-gdb | ├── bochsrc.bxrc | ├── bochsrc-gdb.bxrc | └── vgabios.bin | └── hdc | └── umounted └── Linux-0.11 | └── boot | ├── kernel | ├── fs | ├── lib | ├── init | ├── mm | ├── tools | ├── include | ├── tags | └── Makefile ├── dbg-asm ├── dbg-c ├── gdb ├── gdb-cmd.txt ├── run ├── rungdb └── mount-hdcImage文件我们在宿主操作系统也就是ubuntu上对Linux 0.11进行开发，修改和编译。之后在Linux-0.11目录会生成一个Image的文件。（编译后的目标文件）该文件包含引导和所以内核的二进制代码。oslab 采用 bochs 模拟器加载这个 Image 文件，模拟执行 Linux 0.11，这样省却了重新启动计算机的麻烦。bochs目录bochs目录是与bochs相关的执行文件、数据文件和配置文件run 脚本run 是 运行bochs的脚本命令运行后bochs会自动在他的虚拟软驱——linux-0.11/Image虚拟硬盘——hdc-0.11.img在 0.11 下访问文件系统，访问的就是 hdc-0.11.img 文件内虚拟的文件系统。退出bochs之前现存盘，运行sync命令hdc-0.11.img 文件文件的格式是 Minix 文件系统的镜像。Linux 所有版本都支持这种格式的文件系统所以可以在宿主系统上挂载该文件系统。达到宿主系统和Linux 0.11之间文件交换的效果其中包含的文件有：Bash shell；一些基本的 Linux 命令、工具，比如 cp、rm、mv、tar；vi 编辑器；gcc 1.4 编译器，可用来编译标准 C 程序；as86 和 ld86；Linux 0.11 的源代码，可在 0.11 下编译，然后覆盖现有的二进制内核。编译make all(make 命令会自动跳过未被修改的文件 )如果重新编译没有效果可以试试删除中间文件: make clean &amp;&amp; make all运行./run4、调试汇编级调试./dbg-asmC语言调试./dbg-c./rungdb(新开一个窗口)注意：启动的顺序不能交换，否则 gdb 无法连接。5、文件交换# 启动挂载脚本 $ cd ~/oslab $ sudo ./mount-hdc # 进入文件系统 $ cd ./mount-hdc/ # 读写完毕，卸载文件系统 $ cd ~/oslab $ sudo umount hdcReference[1] 哈尔滨工业大学.操作系统 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机","slug":"计算机","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"OS","slug":"计算机/OS","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/OS/"}],"tags":[{"name":"网易云网课","slug":"网易云网课","permalink":"https://www.beenli.cn/tags/%E7%BD%91%E6%98%93%E4%BA%91%E7%BD%91%E8%AF%BE/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-04-07T04:03:20.000Z","updated":"2020-04-25T15:55:02.011Z","comments":true,"path":"posts/d0edc1ed/","link":"","permalink":"https://www.beenli.cn/posts/d0edc1ed/","excerpt":"","text":"Linux常用命令建立软链接lnln -s [源文件] [链接文件] (创建软链接)例如：在~/oslab/下有一个可执行文件gdb你只能用./gdb去执行它。但是你可以把它链接到$PATH下，这样你可以在任意路径都可以执行ln -s ~/oslab/gdb /usr/local/bin/gdbln -snf ~/oslab/xxx /usr/local/bin/gdb(修改)移动文件mvmv [source] [target]例如：​ mv ~/oslab/oslab/* ~/oslab/ (把~/oslab/oslab/下的文件全部 复制到~/oslab/)mv a.txt b.tax 把文件名a.txt改为b.txt设置权限chmod；chownr 读取权限，数字代号为4;w 写入权限，数字代号为2；x 执行或切换权限，数字代号为1；- 不具任何权限，数字代号为0；7rwx6rw-5r-x4r—3-wx2-w-1—x0—-chmod u+x,g+w f0 //为文件f0设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f0 //为文件f0设置自己可以读写执行，同组可以读写。其他人可以读 chmod 764 f0 // 效果同上 chmod a+x f0 // 所有人都可以执行 chown -R liu /usr/meng //将目录/usr/meng及其下面的所有文件、子目录的文件属主改成 liu： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.beenli.cn/categories/Linux/"}],"tags":[{"name":"Basic Use","slug":"Basic-Use","permalink":"https://www.beenli.cn/tags/Basic-Use/"}]},{"title":"VIM-Plugs","slug":"VIM-Plugs","date":"2020-04-06T09:11:58.000Z","updated":"2020-04-25T15:09:36.786Z","comments":true,"path":"posts/b71407e8/","link":"","permalink":"https://www.beenli.cn/posts/b71407e8/","excerpt":"","text":"VIM-Plugs1、vim-plug: 插件管理器call plug#begin('D:/App/vim/vim81/vimfiles/plugs')//插件安装目录(可以随意定) \" Shorthand notation for plugin Plug 'foo/bar' //插件下载地址，GitHub可以简写 call plug#end() // 函数结束标志command:PlugInstall // 安装插件:PlugClean // 清理invalid插件:PlugUpgrade // 升级插件:PlugDiff // 查看现有插件与下载地址处插件不同，即检测更新细节:PlugStatus // 查看插件加载情况:PlugSnapshot // 生成用于恢复当前插件快照的脚本featurePlug 'zhuzhzh/verilog_emacsauto.vim', {'for': ['verilog', 'systemverilog'] } // 当且仅当打开的文件为Verilog或者systemVerilog时加载此插件 Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } //当且仅当触发toggle命令时加载此插件2、lightline:彩色状态栏3、vim-colors-solarized:比较舒服的配色方案此插件含有两种色调：dark；lightcall togglebg#map(““) // 可以设置快捷键自行切换4、youcompleteme：自动补全5、vim-snippets+SirVer/ultisnips : 代码片填充第一个插件提供好多语言的代码片文件。第二插件提供的填充引擎。snippet有两种格式：snippets/*: snippets using snipMate formatUltiSnips/*: snippets using UltiSnips format可以自己编写snippets文件 {n}代表要填写的空白处。/* placeholder*/ snippet test // Author: Wan Li // time: `strftime(\"%Y-%m-%d\")` // function: ${1:/*写下测试的功能*/} // --------------------------------------------------- \\`timescale 1ns/1ns \\`include \"${2:/*包含的模块文件*/}\" 配置_vimrc文件 let g:UltiSnipsExpandTrigger=\"&lt;c-j&gt;\" //ctrl + j 触发 let g:UltiSnipsJumpForwardTrigger=\"&lt;c-b&gt;\" //ctrl + b 跳到下一个需要填写的空处 let g:UltiSnipsJumpBackwardTrigger=\"&lt;c-z&gt;\" //ctrl + z 跳到上一个需要填写的空出6、nerdtree: 可视化目录树7、tabbar: 整齐的标签窗口8、tpope/vim-commentary: 快速注释gcc ：注释/取消注释一行gc{motion}gc : 注释selection块7，17 Commentary9、vim-gutentags：借助universal ctags 自动产生标签文件🌮有了这个标签文件，你又可以&lt;C+]&gt;跳转10、vim-easy-align：自动对齐按官方配置来设置快捷键/ga触发“ Start interactive EasyAlign in visual mode (e.g. vipga)xmap ga(EasyAlign)“ Start interactive EasyAlign for a motion/text object (e.g. gaip)nmap ga(EasyAlign)1 Around the 1st occurrences of delimiters2 Around the 2nd occurrences of delimiters…* Around all occurrences of delimiters** Left-right alternating alignment around all delimiters- Around the last occurrences of delimiters (-1)-2 Around the second to last occurrences of delimitersKeyDescription/Use cases``General alignment around whitespaces=Operators containing equals sign (=, ==, !=, +=, &amp;&amp;=, …):Suitable for formatting JSON or YAML.Multi-line method chaining,Multi-line method arguments&amp;LaTeX tables (matches &amp; and \\\\)#Ruby/Python comments\"Vim comments``Table markdown document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"VIM","slug":"VIM","permalink":"https://www.beenli.cn/categories/VIM/"}],"tags":[{"name":"Plugs","slug":"Plugs","permalink":"https://www.beenli.cn/tags/Plugs/"}]},{"title":"Gate-and-switch-level modeling","slug":"Gate-and-switch-level-modeling","date":"2020-04-05T01:54:38.000Z","updated":"2020-04-28T09:38:08.947Z","comments":true,"path":"posts/aff089ac/","link":"","permalink":"https://www.beenli.cn/posts/aff089ac/","excerpt":"","text":"Gate-and-switch-level modeling1、verilog-std-1364-20051There are 14 logic gates and 12 switches predefined in the Verilog HDL to provide the gate- and switch-level modeling facility. Modeling with logic gates and switches has the following advantages:— Gates provide a much closer one-to-one mapping between the actual circuit and the model.— There is no continuous assignment equivalent to the bidirectional transfer gate.Verilog1364-2005标准规定了26个基本原件，其中14个门级原件，12个开关级原件。对于这些原件不需要定义直接调用。2、门级建模2多输入门：n_input_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal { , input_terminal } ) and A1(out1, in1, in2); or O1(outa, inb, inc, ind); xor X1(outx, inx, iny, inz, inw);多输出门调用:n_output_gate_instance ::= [ name_of_gate_instance ] ( output_terminal { , output_terminal } , input_terminal ) buf BUF_1(bufout1, bufout2, bufout3, bufin); not NOT_1(out1, out2, in);三态门调用:enable_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , enable_terminal ) bufif1 BF1(data_bus, data, enable);二个电阻The instance declaration of a pullup or a pulldown source shall begin with one of the following keywords: pullup , pulldownpull_gate_instance ::= [ name_of_gate_instance ] ( output_terminal ) pullup (strong1) p1 (neta), p2 (netb); In this example, the p1 instance drives neta and the p2 instance drives netb with strong strength.注意: 门级原件的端口列表都固定好了，可以不用定义中间连接信号类型(wire)示例：// 门级建模实现最小项表达式 // F(a, b, c) = m1 + m2 + m3 + m6 + m7 = (!a)c + b module zuixiaoxiang(out, a, b, c); input a, b, c; output out; wire s1, s2; not U1(s1, a); and U2(s2, s1, c); or U3(out, s2, b); endmodule3、开关级建模MOS switchescmospmosnmosrcmosrnmosrpmosrmos : 代表晶体管导通时源漏有较高的阻抗(impedance)The following example declares a pmos switch: pmos p1 (out, data, control); The output is out , the data input is data , and the control input is control.The instance name is p1 .Bidirectional pass switches(双向开关)trantranif1tranif0rtranrtranif1rtranif0The bidirectional pass switches shall not delay signals propagating through them. When tranif0, tranif1,rtranif0, or rtranif1 devices are turned off, they shall block signals; and when they are turned on, they shall pass signals. The tran and rtran devices cannot be turned off, and they shall always pass signals.(双向开关没有传播延时)The following example declares an instance of tranif1: tranif1 t1 (inout1,inout2,control); The bidirectional terminals are inout1 and inout2 . The control input is control . The instance name is t1 .示例：// 2输入与门 // time:2020-04-05 module and2_1(out, a, b); input a,b; output out; wire s1, s2; supply0 Gnd; supply1 Vdd; pmos U1(s1, Vdd, a); pmos U2(s1, Vdd, b); nmos U3(s1, s2, a); nmos U4(s2, Gnd, b); pmos U5(out, Vdd, s1); nmos U6(out, Gnd, s1); endmodulequarter II 综合不了，没办法直接看viewer。只能把书上的图扒来了。终于找到了一款RTL级，gate级，开关级debugger和viewer的软件trainsistor-level debugger and viewer但是目前下载不了，得找客服联系。不知有人有用过这款软件没有。有的话请你一定告诉我。Renference[1] verilog-std-1364-2005[2] 蔡觉平.2015.Verilog HDL 数字集成电路高级程序设计 31P document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://www.beenli.cn/tags/verilog/"}]},{"title":"图床+评论","slug":"图床-评论","date":"2020-04-04T10:11:31.000Z","updated":"2020-04-25T15:15:06.206Z","comments":true,"path":"posts/7928fb24/","link":"","permalink":"https://www.beenli.cn/posts/7928fb24/","excerpt":"","text":"图床+评论1、什么是图床图床一般是指储存图片的服务器；就跟百度网盘差不多。只不过它是专门存储图片的。有的也可以存储文件。有很多免费的图床。会赠送10G存储空间2、为什么要用图床用图床很方便。服务器会生成一个外链。在互联网任何地方都能访问到用图床访问速度很快。服务商会使用cdn加速用图床可以节省本地空间。3、七牛云图床的使用注册一个账号（需要身份认证）创建一个存储空间注意空间名称是唯一。访问控制：选择私有：别人无法访问。如果是写博客或者公众号还是选择公开吧！这样外链别人是可以看得到的。绑定备案的域名​ 可以看到：如果不绑定自己的域名；系统30天后回收回。那么你之前的外链都失效了​ 所以最好绑定自己的域名才上线。如果你只想试试，那么到这里你就可以结束了。开始体验图床。上传完文件，然后返回。你就可以点击操作—-&gt;更多——-&gt;复制外链这时候你就可以直接从浏览器输入这个外链访问到你刚刚上传的文件。这里推荐一个Windows平台图床神器；大概长这样。登陆上你之前注册的七牛云账号就可以使用了。用图床上传图片遇到的坑：由于七牛云默认生成的外链的是http的，有些浏览器会阻塞这种不安全资源。我只好去修改协议。这时遇到第二个坑。要使用https协议，你绑定的域名必须有证书。我在网上到处找，买的证书太贵，划不来。免费的证书授权又太慢。最后终于找到了一款免费证书ssl发放机构。freessl其间要下载一个软件（keymanager)最后生成证书的过程很快几分钟就搞定。4、Valine评论系统hexo的很多主题都内嵌了这个系统，你只需要去cleancloud注册个账号获取id和key填入配置文件里面就能用如果你想要邮件通知或者后台评论管理可以用这个插件Valine-Admin项目部署的一定要注意smtp_pass是授权码或者QQ独立密码，不是登陆密码。部署完成效果如下。​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software skills","slug":"Software-skills","permalink":"https://www.beenli.cn/categories/Software-skills/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.beenli.cn/tags/Hexo/"}]},{"title":"testbench(1)","slug":"testbench-1","date":"2020-04-04T02:38:11.000Z","updated":"2020-04-25T15:18:18.695Z","comments":true,"path":"posts/26241a85/","link":"","permalink":"https://www.beenli.cn/posts/26241a85/","excerpt":"","text":"Testbench(1)1、testbench的结构testbench没有输入输出接口测试模块只负责对待测试系统接口提供激励信号;并监控输出testbench代码不需要可综合，即不被实现成电路产生适当的激励并达到覆盖率要求2、测试激励的描述方式信号的初始化第一种: initial 初始化 initial a = 0; 第二种: 定义信号时初始化 reg[3:0] cnt = 4'b1010;延迟控制延迟语句外部时间控制initial #5 a = b;(等待5tick后计算右端的值并赋值给左边👈) 等价于: initial begin #5; a=b; end内部时间控制initial a = #5 b;(先计算右端的值，等待5tick后再把值赋给左边👈) 等价于 initial begin temp = b; #5; a = temp; end验证程序如下：可以清楚地看到：​ 第一种延时语句，在0-5tick之间只要b变化了,那么第五tick时刻a被赋予的值就是b第五时刻的值。​ 而第二种延时语句：b的值在0时刻已经定好了，不管b在这期间怎么变化，a最终得到的是b在0时刻的值。事件语句@(&lt;事件表达式&gt;);@(&lt;事件表达式&gt;)行为语句;initial begin # 10 @(posedge en) in = ~in; //en的👆上升沿到来时,in取反 end事件语句@必须等指定事件到来才执行等待语句wait(&lt;条件表达式&gt;) 行为语句always #5 cnt=cnt+1'b1; initial wait(cnt == 4'b1111) $display($time,,,\"cnt = %b\", cnt); end等待语句只有条件为真时才执行。可以看到第0时刻cnt = 0第5时刻cnt = 1以此类推；直到第75时刻 cnt = 15再过10tick 就终止仿真了。总过时常85tick document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"testbench","slug":"testbench","permalink":"https://www.beenli.cn/tags/testbench/"}]},{"title":"单链表翻转","slug":"单链表翻转","date":"2020-03-31T15:51:58.000Z","updated":"2020-04-25T15:23:37.806Z","comments":true,"path":"posts/39c22857/","link":"","permalink":"https://www.beenli.cn/posts/39c22857/","excerpt":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }","text":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }解法二、三指针法struct ListNode *reverseList(struct ListNode* head) { if (head == NULL) { // 如果为NULL，那么后指针越界。 return NULL; } struct ListNode *p0 = NULL; struct ListNode *p1 = head; struct ListNode *p2 = head-&gt;next; while (p1 != NULL) { p1-&gt;next = p0; p0 = p1; p1 = p2; if (p2 != NULL) { p2 = p2-&gt;next; } } return p0; }参考博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机","slug":"计算机","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"Data Structure","slug":"计算机/Data-Structure","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"}]},{"title":"iverilog","slug":"开发工具","date":"2020-03-31T11:57:08.000Z","updated":"2020-04-28T09:39:08.721Z","comments":true,"path":"posts/bc753b52/","link":"","permalink":"https://www.beenli.cn/posts/bc753b52/","excerpt":"","text":"vim + iverilog + gtkwave1、What is Icarus VerilogIcarus Verilog is a Verilog simulation and synthesis tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called vvp assembly. This intermediate form is executed by the vvpcommand. For synthesis, the compiler generates netlists in the desired format.1​ 从官网的描述我们可以看到: 它是一个仿真器和综合器。​ 有趣的是：开发者是一名软件工程师​ a software engineer specializing in device drivers and embedded systems2、Why we choose Icarus Verilog软件非常小，没有图形界面。跑跑小的程序足够了软件扩展性特别好。我现在还没有去探索。详情见软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的3、How to use it像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码然后在编辑器里一键运行脚本，或者在终端运行。终端主要记住几个命令即可: (后面很会详细说明)iverilog -o filename filename.v // 编译源文件 【-o 指定生成的文件名称】 vvp filename // 仿真testbench gtkwave filename.vcd // 查看仿真的波形图4、Instance case编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)// 模8计数器。存储为count8.v module count8(clk, rst_n, cnt); input clk, rst_n; output[3:0] cnt; reg[3:0] cnt; always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 4'b0000; else if(cnt[3]) cnt &lt;=4'b0000; else cnt &lt;= cnt + 1'b1; end endmodule编译一下iverilog -o counter8 counter8.v​ ​ 可以看到已经编译成功，生成了count8文件。即上述命令-o后面指定的。如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。编写测试代码`include \"count8.v\" `timescale 1ns/1ns module count8_tb; // 数据结构声明 reg clk; reg rst_n; wire[3:0] cnt; // 实例化待测试模块 count8 U1(clk, rst_n, cnt); // 测试激励信号 always #50 clk = ~ clk; initial begin clk = 1'b0; rst_n = 1'b0; #20 rst_n = 1'b0; #200 rst_n = 1'b1; end // 输出响应 initial begin wait(cnt == 4'b1000) $display($time,,,\"cnt = %b\", cnt); $dumpfile(\"count8_tb.vcd\"); // 很关键，把仿真的数据存储到文件,待会波形图要用 $dumpvars(0, count8_tb); // 设置要观察的变量 end endmodule编译，仿真，生成波形图iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd注意:由于仿真程序没有设定停止时间。程序会一直执行。如果你想自动停止（可以在testbench上加上# 500$stop,那么程序仿真500个tick就停止)如果你没有加停止指令。只能手动停止ctrl+c然后你可以打印当前仿真的时间。如果不够你可以继续仿真。如果可以了就finish最后用gtkwave 查看你刚刚仿真生成的count8_tb.vcd文件。如果你喜欢用modelsim也可以。也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。具体教程见references[1] iverilog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"开发工具","slug":"Digital-IC/开发工具","permalink":"https://www.beenli.cn/categories/Digital-IC/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://www.beenli.cn/tags/verilog/"}]}],"categories":[{"name":"Software skills","slug":"Software-skills","permalink":"https://www.beenli.cn/categories/Software-skills/"},{"name":"计算机","slug":"计算机","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"Data Structure","slug":"计算机/Data-Structure","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Data-Structure/"},{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"},{"name":"Computer Network","slug":"计算机/Computer-Network","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Computer-Network/"},{"name":"OS","slug":"计算机/OS","permalink":"https://www.beenli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/OS/"},{"name":"Linux","slug":"Linux","permalink":"https://www.beenli.cn/categories/Linux/"},{"name":"VIM","slug":"VIM","permalink":"https://www.beenli.cn/categories/VIM/"},{"name":"开发工具","slug":"Digital-IC/开发工具","permalink":"https://www.beenli.cn/categories/Digital-IC/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"},{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"},{"name":"syntax","slug":"syntax","permalink":"https://www.beenli.cn/tags/syntax/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.beenli.cn/tags/Hexo/"},{"name":"协议","slug":"协议","permalink":"https://www.beenli.cn/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"网易云网课","slug":"网易云网课","permalink":"https://www.beenli.cn/tags/%E7%BD%91%E6%98%93%E4%BA%91%E7%BD%91%E8%AF%BE/"},{"name":"Basic Use","slug":"Basic-Use","permalink":"https://www.beenli.cn/tags/Basic-Use/"},{"name":"Plugs","slug":"Plugs","permalink":"https://www.beenli.cn/tags/Plugs/"},{"name":"verilog","slug":"verilog","permalink":"https://www.beenli.cn/tags/verilog/"},{"name":"testbench","slug":"testbench","permalink":"https://www.beenli.cn/tags/testbench/"}]}