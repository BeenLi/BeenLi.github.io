{"meta":{"title":"WanLi's blog","subtitle":"Stay hungry,Stay foolish...","description":"平常爱打球, 听歌, 看书.<br>吉林大学17级微电子, 辅修CS","author":"Wan Li","url":"https://www.beenli.cn","root":"/"},"pages":[{"title":"categories","date":"2020-03-30T15:37:02.000Z","updated":"2020-04-02T11:11:56.647Z","comments":false,"path":"categories/index.html","permalink":"https://www.beenli.cn/categories/","excerpt":"","text":"目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-03-31T11:43:04.000Z","updated":"2020-10-04T14:55:07.480Z","comments":true,"path":"about/index.html","permalink":"https://www.beenli.cn/about/","excerpt":"","text":"教育经历 吉林大学&nbsp;·&nbsp;微电子&nbsp;&nbsp;[辅修计算机]兴趣爱好 ❤&nbsp;打球，编程，看书，看电影搭建这个博客主要是为了记录学习、生活中遇到的问题以及解决办法；还有些知识，技巧总结便于今后查阅。博客的内容都是个人原创，整理，或者翻译而成，不免会有错误的地方，如果发现错误欢迎您与我联系；如果有侵权的内容，我很抱歉，欢迎您联系我立马删除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-03-30T15:39:32.000Z","updated":"2020-03-31T11:43:51.021Z","comments":false,"path":"tags/index.html","permalink":"https://www.beenli.cn/tags/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"12-hour clock using six BCD digits","slug":"12-hour-clock-using-six-BCD-digits","date":"2020-10-06T01:02:04.000Z","updated":"2020-10-06T01:30:53.161Z","comments":true,"path":"posts/8cc45ed0/","link":"","permalink":"https://www.beenli.cn/posts/8cc45ed0/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"HDL Bits","slug":"Digital-IC/HDL-Bits","permalink":"https://www.beenli.cn/categories/Digital-IC/HDL-Bits/"}],"tags":[{"name":"circuits","slug":"circuits","permalink":"https://www.beenli.cn/tags/circuits/"}]},{"title":"From 1000Hz clock to 1Hz--OneHertz","slug":"From-1000Hz-clock-to-1Hz-OneHertz","date":"2020-10-03T06:47:49.000Z","updated":"2020-10-06T01:20:58.342Z","comments":true,"path":"posts/8cdff568/","link":"","permalink":"https://www.beenli.cn/posts/8cdff568/","excerpt":"","text":"problem link：https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q7bBackground从频率为1000Hz的时钟中得到频率为1Hz的信号(OneHertz)，它用来驱动一系列时/分/秒计数器的使能信号(Enable signal)以此创建一个数字时钟墙(digital wall clock)。因为需要时钟每秒计数一次，OneHertz信号必须每秒准确地断言一个周期(周期为1秒，且每周期只能翻转一次)。Problem Description用BCD计数器和少许其它的门构建分频器(frequency divider)。并且输出你所使用的BCD计数器的使能信号。(c_enable[0] for the fastest counter, c_enable[2] for the slowest)如下的BCD计数器已经提供给你，Enable为高电平计数器才能正常工作，Reset为同步高电平置位0；module bcdcount ( input clk, input reset, input enable, output reg [3:0] Q );你设计的电路中所有的计数器必须直接使用相同的1000Hz时钟信号。Templatemodule top_module ( input clk, input reset, output OneHertz, output [2:0] c_enable );First Tryanswermodule top_module ( input clk, input reset, output OneHertz, output [2:0] c_enable ); reg [3:0] Q0,Q1,Q2; /************ BCD十进制,当Q=1001时使能--&gt;十倍频 ***************/ assign c_enable[0] = 1'b1; // 让第一个计数器全速计数 assign c_enable[1] = Q0[3] &amp; Q0[0]; // 第二计数器计数周期是第一个的10倍 assign c_enable[2] = Q1[3] &amp; Q1[0]; // 第二计数器计数周期是第二个的10倍 assign OneHertz = Q2[3] &amp; Q2[0]; bcdcount counter0 (clk, reset, c_enable[0], Q0); bcdcount counter1 (clk, reset, c_enable[1], Q1); bcdcount counter2 (clk, reset, c_enable[2], Q2); endmoduleresult❌在计数0-10的时候是正确的在计数90-99的时候: c_enable[2]本该为0却变为了1，导致输出c_enable=5=3’b101;由于c_enable[2]=Q1[3] &amp; Q1[0]，起初我认为是Q1有问题；后续画出如下草图发现还是c_enable有问题由于Q1是由计数器生成的，只要使能信号没问题，那么它就还🆗又由于使能信号1和2是我们定义，所以从这里下手解决问题比较方便；由上图知使能信号2有问题，它在计数90-99期间一直为高电平，我们只希望其在99时为高电平。所有修改使能2的赋值：c_enable[2] = Q1[3] &amp; Q1[0] &amp; c_enable[1]同理我们也要修改OneHertz = Q2[3] &amp; Q2[0] &amp; c_enable[2];，让其只在999时才有效；否则其在900-999一直有效；Final answermodule top_module ( input clk, input reset, output OneHertz, output [2:0] c_enable ); // reg [3:0] Q0,Q1,Q2; assign c_enable[0] = 1'b1; assign c_enable[1] = Q0[3] &amp; Q0[0]; assign c_enable[2] = Q1[3] &amp; Q1[0] &amp; c_enable[1]; assign OneHertz = Q2[3] &amp; Q2[0] &amp; c_enable[2]; bcdcount counter0 (clk, reset, c_enable[0], Q0); bcdcount counter1 (clk, reset, c_enable[1], Q1); bcdcount counter2 (clk, reset, c_enable[2], Q2); endmoduleAdvanced problem(❓)⭐如何实现50%(xx%)占空比的10(xx)倍频电路 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"HDL Bits","slug":"Digital-IC/HDL-Bits","permalink":"https://www.beenli.cn/categories/Digital-IC/HDL-Bits/"}],"tags":[{"name":"circuits","slug":"circuits","permalink":"https://www.beenli.cn/tags/circuits/"}]},{"title":"Unprivileged Spec(1)--RV32I","slug":"RISC-V ISA Unprivileged Specification(1)--RV32I","date":"2020-09-30T01:01:08.000Z","updated":"2020-09-30T12:18:10.086Z","comments":true,"path":"posts/6c2bdcd1/","link":"","permalink":"https://www.beenli.cn/posts/6c2bdcd1/","excerpt":"","text":"RV32I Base Integer Instruction Set1 PrefaceRV32I是为了足够成为编译器目标并能支持现代操作系统环境而设计的一个基本整数指令集。它也为了减少硬件实现的最小需求而设计。RV32I包含40个独立的指令，尽管一些简单的实现可能用单一的系统硬件指令（a single SYSTEM hardware instruction)代替ECALL/EBREAK指令，它总是捕获异常(always traps)并且可能将FENCE指令实现为NOP，以减少指令数到38个。RV32I能够模拟几乎任何的ISA扩展（除了A扩展，它需要额外硬件支持原子操作(atomicity）在实践中，包含机器模式特权架构的硬件实现将需要9个CSR指令。基本整数指令集的子集也许对于教学目的很有用(pedagogical purposes), 但是基础已经被定义，对实现其子集的真正的硬件除了忽略非对齐内存访问并把所有的SYSTEM instruction视为单一的异常(single trap)，我们不应该有什么其它的动机。关于RV32I的大多注释也适用于RV64I base。2 Programmer’s Model对于RV32I非特权状态一共有32个寄存器(都是32位宽，i.e. ,XLEN=32)：x0~x31;x0被硬编码到0。另外31个寄存器保存的值可以被解释为：Ⅰ、布尔值的集合，Ⅱ、补码的有符号二进制整数，Ⅲ、无符号二进制整数有一个额外的非特权寄存器，pc(program counter)：保存当前指令的地址在Base Integer ISA中，没有指定的栈指针或者子例程返回地址链接寄存器(link register)；指令编码允许任何寄存器被用于这个目的；但是，标准软件调用惯例(calling convention)使用寄存器x1保存调用的返回地址，x5作为备用链接寄存器。标准调用例程使用x2作为栈指针(stack pointer)硬件可以使用x1或x2来加速函数调用和返回(因为可以尽早解码)；详情见JAL和JALR指令可选的压缩16-bit指令格式基于这样的假设设计的：x1：返回地址寄存器；x2:栈指针。使用其他约定的软件将正常运行，但可能有较大的代码大小。notes：可用架构寄存器(available architectural registers)的数量能够对代码大小，性能，能耗产生重大影响。尽管16个寄存器对于运行编译代码的整数ISA来说是足够的，但是在长度为16位使用3-address格式的指令中编码拥有16个寄存器完整的ISA是不可能的。(⭐PS:16个寄存器，address至少4位，三地址就12位，那么只剩下4位区分不同的指令了,即最多16条不同的指令)。尽管2-address是可能的。但它增加指令条数并且降低效率。我们想要避免立即数指令的大小来简化硬件实现，一旦32-bit的指令大小被采用，支持32个整数寄存器就很显而易见了。一个更大数量的整数寄存器也有助于提高高性能代码的性能，可广泛使用循环展开（loop unrolling)、软件流水线(software pipelining)和缓存平铺(cache tiling)。❓基于上面这些原因，我们为基础ISA选择了一个常规大小（conventional size)——32个整数寄存器。动态寄存器使用趋向于被一些经常访问的寄存器主宰，并且regfile(寄存器堆)的实现可被优化以减少频繁访问寄存器的访问能量(access energy)。可选的16位压缩指令格式绝大部分只使用8个寄存器，因此能提供稠密的指令编码(dense instruction encoding),但是如果想要的话，额外的指令集扩展能支持更大的寄存器空间(要么扁平的要么分层次的)。3 Base Instruction Formats有4种核心的指令格式：R/I/S/U。指令长度都是32位，并且必须在内存中以4字节为边界对齐。指令地址非对齐的异常，常常是由于分支的发生(taken branch)或者非条件跳转的目标地址不是4字节对齐。对于解码一个保留指令的行为是没有规定的(unspecified)RISC-V ISA保持源寄存器(rs1和rs2)和目标寄存器(rd)的位置在所有指令格式中相同以简化解码。除了使用在CSR指令中的5bit的立即数，立即数总是sign-extended，通常是打包到指令中最左边的可用位，这样分配以减少硬件的复杂程度。特别是，对于所有立即数的符号位总是在最高位(也就是Ins[31])来加速符号扩展电路。imm[x]指的是当前位在扩展成32位立即数中的位置实际应用中，大部分立即数要么很小，要么需要所有的位数(XLEN bits)。我们选择非对称立即数分割：常规指令中立即数占12bits;特殊的 load-upper-immediate 指令中立即数占20bits。这样做是为了给常规指令更多的opcode空间。4 Immediate Encoding指令格式还有两个变种(variants)：B/J，它们基于立即数的处理衍生出来。S和B仅有的区别：在B格式中12bit立即数域乘以2用于编码分支偏移。而不是像传统做法那样，将指令编码中的所有立即数位用硬件左移一位,中间的位数(imm[10:1])和符号位保留在固定位置，而S格式中的最低位(inst[7])在B格式中编码一个高阶位。U和J的仅有区别：U要向左移12位；而J只用移动1位。在U和J指令立即数中指令的位置尽量跟其他格式的指令或者它们互相重叠。5 Computational大多数的整数算术指令(Integer computational instruction)对保存在整数寄存器中的XLEN位的值进行操作。整数计算指令要么被编码为使用I格式的寄存器-立即数操作；要么使用R格式的寄存器-寄存器操作。对于这两种类型指令的目的寄存器都是rd。没有整型计算指令会导致算术异常基本指令集不包括对整数算术运算上做溢出检查(overflow checks)支持的特殊指令集。因为许多溢出检查能够更便宜地(cheaply)使用RISC-V分支来实现对无符号加法的溢出检查仅仅需要在加法指令后加上一条额外的分支指令add t0,t1,t2 blut t0, t1, overflow对于有符号加法：如果一个操作数的符号已知，溢出检查仅需要加法之后的一个分支（覆盖了带有立即数操作数的常见加法情形）addi t0, t1, +imm blt t0, t1, overflow对于常规的有符号加法，加法之后需要三条额外的指令。利用当且仅当另一个操作数为负时，该和应小于其中一个操作数的观察。add t0, t1, t2 slti t3, t2, 0 slt t4, t0, t1 bne t3, t4, overflow在RV64I中，32位有符号的加法溢出可以通过比较ADD和ADDW操作的结果来进一步优化。(ADDW肯定不会溢出)Register-ImmediateADDI：将12位立即数符号扩展后与rs1中的值相加，算术溢出忽略，结果的低32位存到rd寄存器中。/* 两条指令等效 */ ADDI rd, rs1, 0 MV rd , rs1(汇编伪指令：将rs1中的值复制给rd)SLTI(set less than immediate): 当寄存器rs1中的值小于立即数（俩者都视为有符号数)，将寄存器rd置为1；否则置0。SLTIU: 功能一样，但是把比较的对象视为无符号数。/* 两条指令等效 */ SLTIU rd, rs1, 1(当rs1等于0,rd为1,否则为0) SEQZ rd, rsANDI, ORI, XORI: 三个逻辑运算符，分别对rs1和立即数执行按位(bitwise)的与，或，异或运算。/* 两条指令等效 */ XORI rd, rs1, -1(-1的补码为全1) NOT rd, rs(将rs各位取反赋值给rd)移位被编码一种特殊的I类型指令格式。被移位的操作数为rs1；移位的位数被编码在立即数域的低五位上。👉移类型被编码在第30位上；SLLI(shift left logical)：0被移动到低位SRLI: 0被移动到高位SRAI: (shift right arithmetic): 原符号位复制到空出的高位LUI(load upper immediate): 用于构建32位常数并使用U格式指令。把U-immediate的值放在目的寄存器的高20位，其它低位用0填充。AUIPC(add upper immediate to pc)：用于构建与pc相关的地址，并使用U格式指令。形成32位的偏移(高20位来自立即数，低12位用0填充)，把这个偏移加到AUIPC指令的地址上，然后把结果放到rd中。（rd = pc-4+im)AUIPC指令支持双指令序列(two-instruction sequences)访问相对PC的任意偏移(for both control-flow transfers and data accesses)一个AUIPC和JALR中12位偏移的组合能够转换控制给任意32位的PC相对地址(PC-relative address)，而一个ALIPC加上一个常规load和store指令中的12位立即数偏移能供访问任意32位PC相对地址的数据地址(PC-relative data address)当前PC值可以通过设置立即数为0获得，尽管JAL+4指令也能获得本地PC(JAL下一指令)，它可能在简单微架构中造成流水线崩溃，或者在更复杂的微架构中污染BTB(❓)Register-RegisterRV32I定义了几个R型算术运算。所有的运算都读取rs1,rs2寄存器的值作为源操作数，把结果写回rd寄存器。funct7和funct3域选择合适的运算。意义同👆。NOP InstructionNOP指令：不会改变任何架构上可见的状态。出来推进PC，增加任何适用的性能计数器。NOP被编码为`ADDI x0, x0, 0NOPs可以被用来对齐代码段与重要的微架构地址边界。或者为内联代码修改(inline code modification)流出空间。尽管有许多可能的方法去编码NOP,我们使用了规范的NOP编码来允许微架构优化以及更易读的反汇编输出。其它的NOP编码可以用作指示指令(HINT instruction)选择ADDI作为NOP编码是因为它在跨一系列系统执行时最可能占用最少的资源;除此之外，该指令仅读取一个寄存器。并且，一个ADDI功能单元在超标量设计中更容易可用，因为adds是最常见的运算地址生成单元可以使用相同的硬件够执行ADDI，该硬件被用于base+offset地址计算，而register-register ADD，逻辑运算或移位运算操作需要额外的硬件。6 Control TransferRV32I提供两种控制转义指令：无条件跳转，条件分支RV32I控制转义指令没有架构上可见的延迟槽(delay slot)Unconditional JumpsJAL(jump and link)指令使用J-type格式，J-immediate以两字节的倍数编码一个有符号偏移。(in multiple of 2 bytes；则该偏移要乘以2)。偏移符号扩展，然后加上当前指令的地址形成跳转目标地址(jump target address)。Jumps因此能够访问±1 MiB范围。JAL存储下一条指令的地址(pc+4)到rd；标准软件调用约定使用x1作为返回地址寄存器，x5作为备用链接寄存器。JALR(jump and link register)：间接跳转指令：使用I-type，目标地址通过把符号扩展的12比特立即数加到rs1上，然后置结果的最低位为0获得；下一条指令的地址(pc+4)写到寄存器rd。如果结果不需要，可以把x0当作目的寄存器。如果目标地址没有对齐四字节边界，jar和jarl指令将产生指令地址非对齐异常。返回地址预测栈(prediction stack)是高性能取值单元的一个常见特点，要求准确检测用于过程调用和返回的指令是有效的。对于RISC-V,关于指令使用的线索通过寄存器号的使用被简单的编码。JAL指令应该把返回地址压进返回地址栈(RAS)中，当且仅当rd = x1/x5；JALR指令应该push/pop a RASlink is true when the register is either x1 or x5Conditional Branches所有分支指令使用B-type格式。12比特的立即数用2字节的倍数编码有符号偏移立即数符号扩展后与当前指令地址相加，可以访问的地址范围：±4 KiBBEQ:branch equal;&nbsp;&nbsp;BNE: branch not equal;&nbsp;&nbsp;BLT: branch less than;&nbsp;&nbsp;BGE: branch greater than;应该对软件进行优化，使顺序代码路径成为最常见的路径，并将较不经常使用的分支代码路径置于行外。软件还应该假设，至少在第一次遇到分支时，预测向后跳转的分支发生，向前跳转的分支不发生。动态预测器应该快速学习任何可预测的分支行为。不像一些其它的架构，RISC-V中对于非条件分支应该总是使用jump(JAL with rd=x0)指令而不是条件总是满足的有条件分支指令RISC-V跳转也是与pc相关的，并且比分支支持更大的偏置范围，而且不会污染条件分支预测表。7 Load and Store(😳)RV32I是一个装载和存储架构：只有load和store指令能够访问内存，算术指令只能操作CPU寄存器。RV32I提供了32-bit的地址空间，用字节编码。EEI定义了地址空间的那部分可以被哪些指令合法访问。(e.g.，一些地址可能只能被读，或仅支持按字访问)目的寄存器为x0的装载指令将抛出异常，即使装载的值被丢弃也会造成其它的副作用。In RISC-V，endianness is byte-address invariant如果一个字节以某种顺序(at some endianness)存储到内存某个地址处，那么以字节大小从那个地址以任意的顺序(in any endianness)装载的结果是存储的值。小端(little-endian): 多字节存储时把寄存器最低为字节写到内存字节地址的最低为，随后寄存器的其它字节以权重升序写入。（权重越大的字节占据的内存地址越大）装载和存储指令用于在寄存器和内存中转换数据。Loads: I-typeStores: S-type有效地址：立即数符号扩展加上基址寄存器rs1目的地址：Ⅰ、for load:从内存取值到rd;Ⅱ、for store：复制rs2的值到内存8 Memory OrderingFENCE：用于排序被其它RISC-V线程，外部设备或者协处理器可见的设备I/O和存储器访问。任何设备输入(I)，设备输出(O)，存储器读取(R),存储器写(W)的组合能够被排序成任何相同的组合。通俗地说，没有其它线程或者外部设备能够在fence之前的指令集进行任何操作之前，观测到在fence后者的指令集合所做的任何操作。就像一个屏障一样，前面的操作只有先完成，后面的指令结果才能被其它处理器观察到。memory-mapped I/O设备很典型地被没有cache的loads和store访问，它们使用I和O而不是R和W。指令集扩展也可以描述新的I/O指令，使用fence指令中I和O位进行排序fence mode域在ins[31:28]；当fm=0000时排序所有的内存操作。可选的FENCE.TSO指令其fm=1000；predecessor=RW,并且successor=RW。TSO命令它的前面集合中的所有加载操作先于它的后继集合中的所有内存操作；它的前面集合中的所有存储操作(store operation)都要先于它的后继集合中的所有存储操作9 Call and BreakpointsSYSTEM instruction：被用于访问需要特权访问的系统功能，使用I-type。分为两大类：自动读-修改-写(read-modify-write)控制状态寄存器(CSRs)。潜在的特权指令(potentially privileged instructions)系统指令被定义成运行稍简单的实现总是捕获异常给单一的软件异常处理器(software trap handle)；更加复杂的实现可能需要执行更多条系统指令这两个指令会向配套执行环境(supporting execution environment)引起一个精确的请求异常(requested trap)。ECALLECALL：向运行环境提出服务请求(service request)EEl将定义服务请求的参数如何传递，但通常这些都是在整数寄存器中指定的位置EBREAKEBREAK：返回控制权给调试器环境(debugging environment)10 HintRV32I为HINT指令保留了大的编码空间，通常是用来和微架构沟通性能提示。HINTs被编码为整数计算指令,其中rd=x0。因此，像nop指令一样，HINTs不会改变架构可见的状态，除了增加pc和任何适用的性能计数器。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://www.beenli.cn/categories/RISC-V/"},{"name":"spec","slug":"RISC-V/spec","permalink":"https://www.beenli.cn/categories/RISC-V/spec/"}],"tags":[]},{"title":"IEEE Standard(1)--Conventions","slug":"IEEE-Standard-for-Verilog(1)-Conventions","date":"2020-09-28T09:44:18.000Z","updated":"2020-09-30T12:01:11.648Z","comments":true,"path":"posts/7b1b9603/","link":"","permalink":"https://www.beenli.cn/posts/7b1b9603/","excerpt":"","text":"1、Overview1.1 Conventionshall: 用于法定的要求（mandatory requirement）may: 用于可选的特性（optional feature）1.2 Syntactic descriptionBNF描述方法(Backus-Naur Form)：基本结构为：::=::=：被定义为的意思“ ”: 双引号表示字符串，也就是终结符，不能再被定义。在双引号外的字代表着语法部分；基本类型 ::= 字符串 | 数字 | 布尔,其中字符串、数字、布尔具体是什么，由下面的规则定义（递归）&lt;&gt;：尖括号里的内容表示必选内容；[...]: 表示可选。{...}:表示重复；实例：AB ::= \"a\" {\"b\"}表示：AB由一个a加上任意数量（包括0个）个b组成(...): 表示分组，用来控制优先级；AX ::= \"a\" (\"m\"|\"n\")表示：AX由一个a加上m或者n组成(*...*) : 注释，说明性文本，不表示任何语法。小写单词，一些包含下划线的：语法目录（syntactic categories）​ module_declaration粗体：保留字、操作符、标点符号​ module =&gt; ;竖条|分割可选单元。如果它以粗体形式出现，它才表示自己。​ unary_operator ::= + | - | ! | ~ | &amp; | ~&amp; | |(或) | ~|(或非) | ^ | ~^ | ^~（都表示同或)方括号[…]包含可选项。input_declaration ::= input [range] list_of_variables;花括号{}除非以粗体出现，它才表示自己，否则表示重复。重复从左到右进行，和左递归等效。list_of_param_assignments ::= param_assignment { , param_assignment }list_of_param_assignments ::=param_assignment| list_of_param_assignment , param_assignment任何目录的名字以斜体开头，等效于没有斜体部分的目录名。斜体部分只是为了传达semantic information。正文中当一个term被定义时使用斜体；在例子，文件名，常量特别时0，1，x和z的值时使用constant-width字体（等宽字体）2、Lexical convention2.1、Lexical tokensVerilog HDL source file shall be a stream of lexical tokens. A lexical tokens shall consist of one or more characters.verilog源文件应该是一连串语法标记，一个语法标记由一个或多个字符组成。源文件中tokens的位置是随意的，也就是说：除了token分隔符，空格和换行不应该有特殊意义，转义字符除外。有如下几种语法标记White spaceCommentOperatorNumberStringIdentifierKeyword2.2、White spacewhite space应该包含：用于空格、制表符、换行符和格式提要的字符。这些字符应该被忽略除了当它们用于分割其他语法标记(tokens)。但是blanks和tabs被认为是有意义的字符在字符串中。2.3、Comments单行注释 //块注释：/* …. */2.4、Operators操作符可以是单个，双个或三个字符的序列，并被用在表达式中。Clause5将讨论表达式中操作符的使用。单目运算符(Unary operators)：在操作数(operand)的左边双目运算符(Binary operators)：在两个操作数中间三木运算符(Triple operator or conditional operator): 有两个操作符字符分割三个操作数（a? x: y)2.5、NumbersConstant numbers可以被指定为integer constant或者real constant2.5.1、Integer constant有两种表达方式：简单的十进制数：a sequence of digits of 0 through 9。开头可以加上+或者-（被视为有符号的整数）指定基码（d，h，o，b）：可选的位宽+'(ASCII 0x27)+基码+digits位宽：非零无符号十进制数基码：大小写不敏感；前面可选s指示是否为有符号数（没有s时默认为unsigned integers)'与基码中间不能有空格。:star:digits: 应该紧跟着基码，前面也可以有空格。a-f不区分大小写s不影响指定的位模式，只改变解释方式。❓负数用补码表示x代表unknown value；z代表high-impedance value（x应该设为4bit对于h的基码，3bit对于o的基码；z同理）如果无符号数位宽小于指定位宽，那么用0填充；如果无符号数最左边的位是x或z;那么用x或z填充。如果无符号位宽大于指定，那么应该从左边截断到指定位宽。没有指定位宽的数字至少为32位；对于高位是x或者z的没有位宽无符号常数应位扩展到包含该常数的表达式的大小。❓?是z的替代字符。在高阻值不需要注意时，可用？来增加可读性。在十进制常数中，无符号数不能包含任何x,z,?；除非只有一个digit，指示其中每一位都是x或者z。_下划线在数字的任何位置都是合法的，除了第一个字符。下划线是没有意义的 ，只是为了分割长的数字提高可读性。无符号数：/************* Example 1--Unsized constant numbers *****************/ 659 // is a decimal number 'h 837FF // is a hexadecimal number 'o7460 // is an octal number 4af // is illegal (hexadecimal format requires 'h) /************* Example 2--Sized constant numbers *****************/ 4'b1001 // is a 4-bit binary number 5 'D 3 // is a 5-bit decimal number 3'b01x // is a 3-bit number with the least significant bit unknown 12'hx // is a 12-bit unknown number 16'hz // is a 16-bit high-impedance number有符号数的表示意义：/************* Example 3—Using sign with constant numbers *****************/ 8 'd -6 // this is illegal syntax -8 'd 6 // this defines the two's complement of 6, held in 8 bits—equivalent to -(8'd 6) 4 'shf // this denotes the 4-bit number '1111', to be interpreted as a 2's complement number, // or '-1'. This is equivalent to -4'h 1 -4 'sd15 // this is equivalent to -(-4'd 1), or '0001' 16'sd? // the same as 16'sbz自动左填充：/************* Example 4—Automatic left padding **************************/ reg [11:0] a, b, c, d; initial begin a = 'h x; // yields xxx b = 'h 3x; // yields 03x c = 'h z3; // yields zz3 d = 'h 0z3; // yields 0z3 end reg [84:0] e, f, g; e = 'h5; // yields {82{1'b0},3'b101} f = 'hx; // yields {85{1'hx}} g = 'hz; // yields {85{1'hz}}使用下划线：/************* Using underscore character in numbers *******************/ 27_195_000 16'b0011_0101_0001_1111 32 'h 12ab_f0012.5.2、Real constantsreal constants用IEEE Std 754-1985，双精度浮点数表示有两种表示方法：十进制表示：14.72科学计数法：39e8（表示39乘以10的8次方）注意：带有小数点的实数至少在小数点两边各有一位。.12 &nbsp;9. &nbsp; 4.E3 &nbsp; .2e-7 都是不合法的2.5.3、Convertion实数向整数转化：四舍五入到最近的整数，而不是截断。当一个实数被赋值给整数时：进行隐士转化(implicit conversion)四舍五入规则：away from zero-1.5 转化为-2；1.5转化为22.6、Strings字符串是一个字符序列，用(“ “)括起来，包含在一行中。字符串可以用作表达式的操作数；赋值时被当成无符号整数常数，一个8-bit的ASCII值对应一个字符。2.6.1、String variable declaration字符串变量是reg类型，宽度=字符个数*8/********* \"Hello world!\"一共12个字符 ********/ reg [8*12:1] stringvar; initial begin stringvar = \"Hello world!\"; end2.6.2、String manipulation字符串可以用Verilog的操作符进行操纵。被操纵的值是8bit ASCII值序列module string_test; reg [8*14:1] stringvar; initial begin stringvar = \"Hello world\"; $display (\"%s is stored as %h\", stringvar,stringvar); stringvar = {stringvar,\"!!!\"}; $display (\"%s is stored as %h\", stringvar,stringvar); end endmodule /************** outputs ****************/ Hello world is stored as 00000048656c6c6f20776f726c64 Hello world!!! is stored as 48656c6c6f20776f726c64212121当变量占用空间大于所分配的空间时，值向右调整，最左边用0填充，与处理非字符串的值一样。当占用空间大于分配空间时，字符串还是向右调整，最左边的截断。2.6.3 Special characters in strings有些字符只有前面加上escape character它们才能在字符串里面使用2.7、Identifiers，keywords,and system names标识符用于给一个对象独一无二的名字，使得它们能呗引用。简单的标识符：字母，数字，$,&nbsp;&nbsp;_组成。开头只能是字母或者下划线。（_bus, wan$li)实现的时候标识符有最大长度，它的限制应该至少为1024个字符。如果一个标识符长度超过这个，系统应该报错。2.7.1 Escaped identifiers转义标识符以反斜杠\\开始，以white space(space, tab,newline)结束。它们提供了在标识符中包含任何可打印字符的方法（33(!)-126(~)；$21_h$-$7E_h$)。前导反斜杠和结尾的空白字符都不算标识符的一部分，因此，\\cpu3被认为和cpu3一样。\\busa+index \\-clock \\***error-condition*** \\net1/\\net2 \\{a,b} \\a*(b+c)2.7.2 Keywords关键字是先前定义好的非转义标识符，它们被用来定义语言结构。关键字前面加上转义字符不被解释为关键字2.7.3 System tasks and functions❓美元符号(`)引导一种语言结构：它能开发用户定义的任务和函数；System constructs不是设计原语，而是仿真功能。美元(`)开头的名字被解释为系统任务或者系统函数。/*********** for example **********/ $display (\"display a message\"); $finish ;2.7.4 Compiler directives`（ASICC value 0x60)字符引导用于实现编译器指令的语言结构；，一个描述文件中的编译器指令可以控制多个描述文件中的编译行为。`identifier 编译器指令结构在以下两种地方定义标准标识符编译器指令由软件实现定义的附加’标识符编译器指令。任何有效的标识符，包括已经在除此构造之外的上下文中使用的关键字，都可以用作编译器指令名/*********** for example **********/ `define wordsize 82.8、Attributes随着使用Verilog HDL作为源代码的仿真器以外的工具的激增(proliferation); Verilog引入一种机制：用于指定关于HDL源代码中对象、语句和语句组的属性，这些属性可被各种工具(包括模拟器)使用，以控制工具的操作或行为。这些属性被称作attribute. 本小节将介绍: 可以用于指定属性的语法机制。attribute_instance ::= (* attr_spec { , attr_spec } *) attr_spec ::= attr_name [ = constant_expression ] attr_name ::= identifierattribute_instance：1、作为声明，模块项目，语句或者端口连接的前缀。2、运算符或在一个表达式中Verilog函数名的后缀如果没有给属性指派值，那么值默认为1；如果对相同的language element定义多个相同的属性名字，那么最后一个属性值将被使用；工具可以在这种情况下给个warning。nesting of attribute instances 不被允许；用包含属性实例的常量表达式(constant expression that contains an attribute instance)去给属性赋值是不合法的。2.8.1 Examples范例1：给case语句贴上属性(* full_case, parallel_case *) case (foo) &lt;rest_of_case_statement&gt; or (* full_case=1 *) (* parallel_case=1 *) // Multiple attribute instances also OK case (foo) &lt;rest_of_case_statement&gt; or (* full_case, // no value assigned；默认为1 parallel_case=1 *) case (foo) &lt;rest_of_case_statement&gt;范例2：给模块定义加属性(* optimize_power *) module mod1 (&lt;port_list&gt;);范例3：给模块实例加属性(* optimize_power=0 *) mod1 synth1 (&lt;port_list&gt;);范例4：给reg声明加属性(* fsm_state *) reg [7:0] state1; (* fsm_state=1 *) reg [3:0] state2, state3; reg [3:0] reg1; // this reg does NOT have fsm_state set (* fsm_state=0 *) reg [3:0] reg2; // nor does this one范例5：给操作符加属性a = b ? (* no_glitch *) c : d; a = b + (* mode = \"cla\" *) c;2.8.2 Syntax(省略) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"specification","slug":"specification","permalink":"https://www.beenli.cn/tags/specification/"}]},{"title":"数据通路(4)--Multiple Issue","slug":"数据通路(4)--Multiple Issue","date":"2020-09-27T11:04:08.000Z","updated":"2020-09-28T03:50:35.348Z","comments":true,"path":"posts/a36b1d36/","link":"","permalink":"https://www.beenli.cn/posts/a36b1d36/","excerpt":"","text":"Preface指令集并行(instruction-level parallelism)有两种方式Ⅰ、Pipeline——详见数据通路(3)；流水线越深，并行度越高。Ⅱ、多发射（multiple issue）: 本节所要讲述的重点。通过复制计算机内部部件的数量，使得每个流水级可以启动多条指令多发射可以使指令执行速度超过时钟的速度，即CPI小于1。实现多发射有两种办法：1、static multiple issue；2、dynamic multiple issue。多发射流水线必须处理以下两个问题：打包指令到发射槽(issue slots)：在大多数静态多发射实现上：在一个时钟周期发射多少条指令，哪些指令被发射这个过程至少很大一部分由编译器来完成。而在动态发射处理器中，这个问题一般由处理器在运行时来处理。（尽管编译器已经优化了指令顺序来尽可能多发射）处理数据和控制冒险：在静态发射处理器中，编译器解决大部分或者所有的可能冒险。与此相反的，动态发射处理器用硬件技术在运行时至少消除某些类别的冒险。尽管，我们把它们描述成不同的方法，但事实上，一个方法经常借助另外一个方法的技术。Speculation(推测)speculation: An approach whereby the compiler or processor guesses the outcome of an instruction to remove it as a dependence in executing other instructions提前给出结果(猜测)来避免后面的指令对正在运行指令的依赖以下是几种猜测的情形：我们猜测分支的结果，那样分支后面的指令可以提早执行。我们猜测存字和取字指令访问的不是同一个地址，那样我们在执行存字指令前去执行取字指令。但是，猜测可能出现错误❌。所以：任何推测技术都必须包含一种机制：1、检查推测是否正确；2、回滚由于推测提前执行的指令的影响。推测错误时恢复机制：for compile: 插入额外的指令检查推测的正确性✔并提供一个fix-up例程供推测错误时使用。for processor: 用buffer缓存推测结果直到推测的结果得到确认。如果推测正确，把缓存的能容写到相应的寄存器中，指令完成。如果推测不正确，硬件冲刷掉buffer，重新执行正确的指令序列。推测可能引入另外的问题：对某些指令的推测会导致原本不存在的异常发生。比如，推测执行一条装载指令，在推测错误的情况下，该指令所使用的地址是非法的。Static multiple-issueStatic multiple-issue processers all use the compiler to assist with packaging instructions and handling hazards.issue packet(发射包)：在一个时钟周期内可以发射的指令集合，可以用一条完成多种操作的长指令来类比Very Long Instruction Word(超长指令字)：一种指令集架构，能够发射多条操作，这些操作在单个指令中被定义为独立的，并且一般都有独立的操作码域。静态多发射处理器有两种：编译器避免所有冒险；硬件检测数据冒险，并在两个发射包间产生阻塞，而编译器只负责避免一个指令包间的依赖。为了并行发射ALU和数据传输操作，需要有额外的硬件：寄存器堆要有额外的端口供连个操作读取操作数；要有额外的ALU来同时执行EX阶段。多发射带来的问题：由于额外的指令重叠，冒险的可能性加倍。装载指令有一个时钟周期的使用延迟（use latency)；这意味着下一个发射包中所有指令都不能使用装载的结果。原本没有使用延迟的ALU指令，其结果不能被在同一个发射包的其他指令使用。循环展开(loop unrolling)：一种从访问数组的循环程序中获得更多性能的技术。其中循环体会被复制多份并且在不同循环体中的指令会调度在一起。/***************** 例程：把一段数组中的数全部加上一个数(x21) ********************/ Loop: ld x31, 0(x20) // x31=array element add x31, x31, x21 // add scalar in x21 sd x31, 0(x20) // store result addi x20, x20, -8 // decrement pointer blt x22, x20, Loop // compare to loop limit,branch if x20 &gt; x22不进行循环展开的静态多发射调度：循环展开结果：在循环展开过程中，编译器引入了几个临时编译器（x28、x29、x30）。这个过程叫做寄存器重命名: 目的是消除一些虚假依赖。如果我们只使用x31寄存器：我们将在sd x31,8(x20)后面重复ld x31,0(x20), add x31, x31, x21。但是这些序列尽管都使用x31，它们实际上是不相关的。antidependence or name dependence(反相关或名字相关)：一组指令集和下一组指令集之间no data value flow，仅仅是因为重用寄存器名引起的相关。Dynamic multiple-issueDynamic multiple-issue processors are also known as superscalar processors, or simply superscalarsBasic concept最简单的超标量处理器：指令按顺序发射，处理器决定每个周期发射0条，1条或多条指令。显然为了获得好的性能，处理器仍然需要编译器帮忙编排指令顺序来减少依赖。简单超标量处理器与VLIW处理器(静态发射)的区别：for superscalar:：1、不管是否经过编译器编排指令顺序，都由硬件来保证执行的正确性✔。2、编译过的代码将始终正确的运行，无论发射速率还是流水线架构。for VLIW：不像👆那样，当移植到不同的处理器模型往往需要重新编译。在其他的静态发射处理器中，代码能够在不同的处理器实现上正确运行，但是效率很差也需要重新编译。许多超标量处理器扩展了基本的动态发射策略，将dynamic pipeline scheduling(动态流水线调度)包含进来。/*************** 一个简单的例子 **************/ ld x31, 0(x21) add x1, x31, x2 sub x23, x23, x3 andi x5, x23, 20说明：即使sub指令准备好执行，它也必须等待ld和add指令先结束才行。如果内存很慢，sub指令可能会等待多个周期（比如cache没有命中）dynamic pipeline schedulingDynamic pipeline scheduling chooses which instructions to execute next, possibly reordering them to avoid stalls.动态调度可以运行时动态调整指令顺序流水线被分为三个主要部分：an instruction fetch and issue unit（取指发射单元)multiple functional units（多种功能单元）commit unit(提交单元)每个功能单元有个buffer, 称为保留站（reservation station)，其中保存着操作数和操作(opcode ❓)。功能单元运算完成的结果传送给1、commit unit；2、旁路给所需的保留站。提交单元也有buffer，称为reorder buffer(重排序缓冲区)：缓存结果直到确定是安全时才写入register file或者memory。保留站缓存操作数➕提交单元缓存结果＝＝》寄存器重命名发射指令时，它被复制到对应功能单元的保留站上，如果它的操作数在寄存器堆或者提交单元缓冲区中有，那么操作数立马复制到保留站。如果指令已经发射，那么对应操作数的副本不再需要，可以重写覆盖。如果一个操作数不在register file or reorder buffer，他必须等待某个功能单元的结果。硬件帮助追踪所需的功能单元，当单元计算出结果直接复制到保留站而旁路掉寄存器堆。out-of-order execution(乱序执行)：处理器在不违背原有数据流顺序的前提下以某种顺序执行各条指令，但是执行指令的顺序可以与取指不同。in-order commit(顺序提交)：流水线执行的结果以取指顺序写回程序员可见的寄存器的一种提交方式。（当异常发生时，处理器可以找到最后执行的那条指令，而只有这条导致异常的指令之前的指令才能对寄存器状态进行改变。推测和动态调度经常结合在一起：通过对分支的预测，动态调度可以在推测方向上进行取指和执行。由于指令是顺序提交，我们可以在分支指令及所有推测执行的指令提交前知道推测是否准确。通过对装载指令目的地址的预测，对存取指令进行重排序和利用提交单元避免错误的推测。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Organization & Design","slug":"CS/Computer-Organization-Design","permalink":"https://www.beenli.cn/categories/CS/Computer-Organization-Design/"}],"tags":[{"name":"processor","slug":"processor","permalink":"https://www.beenli.cn/tags/processor/"}]},{"title":"数据通路(3)--Pipeline & hazards","slug":"数据通路(3)--Pipeline & hazards","date":"2020-09-25T10:32:54.000Z","updated":"2020-09-27T11:48:50.997Z","comments":true,"path":"posts/d4768fc/","link":"","permalink":"https://www.beenli.cn/posts/d4768fc/","excerpt":"","text":"1、An Overview of Pipeline流水线就像工厂的工人一样，每个工人只做一道工序（每个硬件只做一个功能)，同一时间几道工序同时在做(同一时间多条指令同时执行，每条指令在不同的阶段)，最后一道工序做完即完成了一件产品(所以吞吐量非常大)。RISC-V经典流水线可以分为五步Fetch instruction from memory（IF)Read register and decode the instruction(ID)Execute the operation or calculate an address(EX)Access an operand in data memory (MEM) [if necessary]Write the result into a register(WB) [if necessary]面向流水线的指令集设计RISC-V 指令等长，这一限制简化了第一级取指与第二级译码。【x86指令长度不等，从1字节到15字节不等。最近x86体系结构：先转化为简单的操作】RISC-V只有几种指令格式，每一种指令源和目的寄存器字段位置不变。【使得第二级在确定指令类型的同时开始读寄存器堆】RISC-V的memory operands仅仅出现在存取指令中(常规ALU指令的操作数直接在第二级寄存器堆读出)。意味着我们可以在执行阶段计算内存地址，然后在下一个阶段访存。【如果像x86那样可以操作在内存中的操作数，那么第三、四级将扩展为address stage，memory stage，execute stage】流水线控制2、Pipeline HazardsThere are situation in pipelining when the next instruction cannot execute in the following clock cycle. These events are called hazards.1、Structural HazardWhen a planned instruction cannot execute in the proper clock cycle because the hardware does not support the combination of instructions that are set to execute[由于硬件资源不够导致的冒险]这也是为什么我们我们的IF和MEM分开（指令寄存器和数据寄存器）2、Data HazardWhen a planned instruction cannot execute in the proper clock cycle because data that are needed to execute the instruction are not yet available[由于操作数没有准备好导致的冒险]三种经典解决办法Reorder code(重新安排代码)stall the pipeline(阻塞一个或几个周期)bypass or forwarding(旁路或者前推上一条指令运算的结果)①Reorder code//code segment in C a = b + e; c = b + f; //generated RISC-V code for above segment ld x1, 0(x31) // Load b 1 ld x2, 8(x31) // Load e 2 add x3, x1, x2 // b + e 3 sd x3, 24(x31) // Store a 4 ld x4, 16(x31) // Load f 5 add x5, x1, x4 // b + f 6 sd x5, 32(x31) // Store c 7 /************** 说明 ***************** 1、通过旁路可以去除3对1的依赖(load 指令最少需要两个周期，ALU指令在旁路技术下对下一条指令不会构成数据冒险） 2、通过旁路也可解决sd指令对上一条add指令的依赖 3、需要解决的: 3V2和6V5 */ //************* 解决办法 *************** 把第5条指令提到第二条指令和第三条中间。②Bypassingand指令需要x2，而x2只有等到第一条指令写回才有效(即第五个周期前半段)同理or指令❓假设: 写寄存器操作发生时钟周期的前半段而读寄存器操作发生在时钟周期后半段旁路的核心：前一条指令计算的结果不用等到第五周期写回寄存器堆而提前旁路到其后指令的ALU操作数输入上。EX冒险（EX/MEM流水线寄存器有需要的值）if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs1)) ForwardA = 10 if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs2)) ForwardB = 10MEM hazardif (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0) and not(EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs1)) // 先判断不是EX冒险，不然应该是旁路上一条指令EX/MEM结果旁路上上条MEM/WB and (MEM/WB.RegisterRd = ID/EX.RegisterRs1)) ForwardA = 01 if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0) and not(EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs2)) and (MEM/WB.RegisterRd = ID/EX.RegisterRs2)) ForwardB = 01旁路单元产生控制信号选着ALU的输入operand。③Stalls需要阻塞的情形：当一条指令试图读取一个由前一条装载指令读入的寄存器时，就无法使用旁路解决冒险(因为lw指令需要在第四阶段才能产生结果)冒险检测单元if (ID/EX.MemRead and ((ID/EX.RegisterRd = IF/ID.RegisterRs1) or (ID/EX.RegisterRd = IF/ID.RegisterRs2))) stall the pipeline检测单元工作在ID阶段。阻塞后面指令的方法：保持PC寄存器和IF/ID流水线寄存器不变。插入一条空指令（nop)：一种不进行任何操作或不改变任何状态的指令。实现方法：控制信号全部置为0，这些控制信号在每个时钟周期都向前传递，但不会产生不良影响，因为控制为0，那么所有寄存器和存储器都不进行写操作。3、Control HazardAn instruction must be fetched at every clock cycle to sustain the pipeline, yet in our design the decision about whether to branch doesn't occur until the MEM pipeline stage.(后面的优化🙆‍看到在ID级就可以确定分支)[由于选择✔的指令需要延迟]①Branch假定分支不发生（如果发生预取和译码的指令要丢弃）缩短分支延迟（提早确定分支，减少flush的指令数）计算分支目标地址（IF/ID流水线寄存器已经有了PC和立即数字段的值）判断分支条件：需要额外的旁路和冒险检测硬件。【因为分支条件的判断可能依赖于还在流水线中的结果】两个难点：Ⅰ、前面的ALU旁路单元在EX级，所以这里需要一个新的旁路单元工作在ID级。还需要一个equality test logic（对两个寄存器的值按位异或接着或操作）Ⅱ、可能数据在ID级旁路不过来。上一条是ALU指令，那么只能stall a cycle；如果是lw指令，那么必须stall two cycles。Ⅲ、控制信号新增一个IF.flush信号，把预取的那条指令变成nop指令。动态分支预测(缓存之前运行分支的信息进行判断)fetching new instructions from the same places as the last time.)分支预测缓存(branch prediction buffer)也称为分支历史记录表(branch history table):使用分支指令地址地位索引的一小块存储区。这类缓存我们实际上不知道预测是否正确，而且它还可能由其他具有相同地址地位的分支设置。预测错误❌时，错误的预取指令删除，预测位取反，回到原来的位置（❓得有缓存），继续按照正确的方向取指并执行。分支预测缓存可以用很小，用指令地址访问的special buffer in IF pipe stage。如果预测分支，那么从分支target取指令。为了改善非常有规律的分支的预测正确率（比如循环，9次分支只有最后一次循环退出不分支）；可以使用两位的预测机制。相关预测器（correlation predictors)：不仅使用local branch的信息，还综合global behavior of recently executed branches 。典型的相关预测器为每个分支提供两个两位的预测器，根据上一次分支是否执行选择其中一个预测器，因此全局分支行为可以看成adding additional index bits for the prediction lookup.竞争预测器(tournament branch predictor)：为每个分支使用多个预测器，并记录哪个预测器预测结果最好。典型的竞争预测器：对每个分支索引包含两个预测结果，一个基于本地信息，一个基于全局分支行为。一个选择器选择哪个作为预测结果。条件移动指令(conditional move instruction)：不同于分支指令改变PC值，条件移动指令将根据条件改变move指令的目的寄存器。在ARMv8指令集架构中：CSEL X8, X11,X4,NE 如果条件码不为零，复制x11到x8；否则复制X4到X8;②ExceptionControl is the most challenging aspect of processor design: it is both the hardest part to get right and toughest part to make fast然而控制中最难的就是实现异常或中断——除分支外改变正常指令执行流当异常发生时，处理器必须做的基本事情是：在SEPC(supervisor exception cause register)保存出错指令的地址把控制权交给操作系统的特定地址处对于处理异常的OS,它必须知道异常的原因：设置一个原因寄存器（Supervisor Exception Cause Register or SCAUSE):其中有个域指示异常的原因使用向量中断(vectored interrupts), 控制权被转移到的地址是由异常原因决定，该地址可能被添加到指向向量中断内存范围的base register中。例如，我们可以使用下面的异常中断向量地址来表示异常种类。异常在流水线中的实现(使用自前相同的机制，不过这次由异常重置控制信号)IF级指令的清除用之前的IF.flush信号新增ID.Flush信号和之前的冒险检测单元产生的stall信号进行或运算，然后加在自前的多选器上，实现ID级指令清除新增一个EX.Flush信号清除EX级的指令为了从异常处理程序的地址取指，只要简单家一个额外的输入到PC的多选器。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Organization & Design","slug":"CS/Computer-Organization-Design","permalink":"https://www.beenli.cn/categories/CS/Computer-Organization-Design/"}],"tags":[{"name":"processor","slug":"processor","permalink":"https://www.beenli.cn/tags/processor/"}]},{"title":"数据通路(2)--Control","slug":"数据通路(2)--Control","date":"2020-08-20T12:54:40.000Z","updated":"2020-09-27T11:07:21.876Z","comments":true,"path":"posts/f0189490/","link":"","permalink":"https://www.beenli.cn/posts/f0189490/","excerpt":"","text":"1、ALU控制MIPS ALU在4位控制信号上定义了6种有效的输入组合存储器访问指令：addR型指令：根据指令低6位的funct字段1 ，ALU执行5种操作中的一种(nor暂时没用)branch指令：sub(两个操作数相减判断是否为零)多级译码：输入：6位funct字段和2位ALUOP字段————&gt;输出：4位ALU control lines主控制单元生成ALUOP真值表——优化后转换为门电路（坑待定）2、主控制单元指令格式R型指令opcode为0；lw为35；sw为43 ; branch为4⃣7个多选器控制信号的作用主控单元产生7个一位控制信号+2位ALUOP控制信号真值表op[5:0]取至Instruction[31:26]RegDst: R为1表示目的寄存器为rd; lw为rs; sw和branch不用写回寄存器堆所以没有目的寄存器。ALUSrc: R和branch为0表示ALU第二个操作数来自rt; lw和sw表示第二个操作数来自低16位的扩展。MemtoReg: sw和branch为x表示不用写回。R为0表示ALU计算结果写回；lw表示数据寄存器取出来的数写回Regwirte: R和lw要写回所以为1。MenRead: 只要lw要读所以只有lw为1MemWrite: 只有sw要写Branch: 只有branch才触发ALUOP: R为10；存储为00；branch为01跳转实现（即改变PC的值）其OPcode为2.低26位都是offset_address。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Organization & Design","slug":"CS/Computer-Organization-Design","permalink":"https://www.beenli.cn/categories/CS/Computer-Organization-Design/"}],"tags":[{"name":"processor","slug":"processor","permalink":"https://www.beenli.cn/tags/processor/"}]},{"title":"数据通路(1)--Basic Datapath","slug":"数据通路(1)--Basic Datapath","date":"2020-08-20T07:10:16.000Z","updated":"2020-09-27T11:08:18.082Z","comments":true,"path":"posts/74018a17/","link":"","permalink":"https://www.beenli.cn/posts/74018a17/","excerpt":"","text":"1、Preface计算机性能：①指令数目(编译器和指令集），②时钟周期长度(组合电路最大延时)，③每条指令所需要的时钟周期数(处理器架构，指令类别，多发射超标量流水)本篇只是一个基本的MIPS实现。存储器访问指令：取字(lw) 和存字(sw)算数逻辑指令：加法(add)、减法(sub)、与运算(and)、或运算(or)和小于则设置(slt)分支指令：相等则分支(beq)和跳转(j)R指令对应算数逻辑指令。(rs, rt对应两个源操作数，rd对应目的寄存器)add $t1, $t2, $t3 # $t1=$t2+$t3 slt $to, $s0, $a1 # reg $t0 = 0 if $s0 &gt;= $a1I指令对应访存和分支指令。sw $t1, offset_value($t2) # 把$t1的值存到以$t2为基址加上16位地址偏移上去。 # rs=$t2, rt=$t1(目标寄存器),[15:0]=offset lw $t1, offset_value($t2) # 把$t2为基址加上16位地址偏移所在地址的值存到t1。 beq $t3, $zero, loop1 # if($t3==$zero) go to loop1 # loop1是后16位。rs=$t3,rt=$zero;J指令对应无条件跳转j for2tst # jump tp for2tst2、An Overview of the Implementation实现每条指令的前两步是一样的程序计数器(PC)指向指令所在的存储单元，并从中取出指令。(PC是地址)通过指令字段内容，选择读取一个或两个寄存器。对于取字指令，只需读一个寄存器即rs,而其它大多数指令要求读取两个寄存器（rs， rt)。前面两步完成后，为完成指令而进行的后续步骤则取决于具体的指令类型所有指令中除了jump，在读取寄存器后都要使用ALU。访存指令：address calculation算术逻辑指令：operation execution分支指令：comparisonALU之后又各不相同访问Data Memory: store指令要写入数据到data memory；load指令要从memory读数据写回registers: R指令需要把ALU计算的结果; load指令要data memory读出的数据改变PC: 如果分支成立那么改变PC值，否则自增4。3、Building a Datapath数据通路部件：一个用来操作或保存处理器中数据的单元。在MPIS实现中，数据通路部件包括指令存储器、数据存储器、寄存器堆、ALU、加法器.3.1、basic components取指令，更新指令根据寄存器号取操作数进行ALU运算向内存读或者写数据3.2、combination componentsbranch指令需要[15:0]左移两位并符号扩展到32位与PC相加组成新的PC3.3、single data path假设我们在一个时钟周期内执行任意一条指令。那意味着每条指令不能用某个部件两次或以上。所以任何需要重复的部件都必须被复制。1、需要一个指令存储器外，还需要一个数据存储器2、尽管有的功能单元需要复制，但在执行不同指令时，很多功能单元可以被共享(复用)复用ALU和寄存器堆 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Organization & Design","slug":"CS/Computer-Organization-Design","permalink":"https://www.beenli.cn/categories/CS/Computer-Organization-Design/"}],"tags":[{"name":"processor","slug":"processor","permalink":"https://www.beenli.cn/tags/processor/"}]},{"title":"存储电路","slug":"存储电路","date":"2020-08-05T10:28:10.000Z","updated":"2020-09-30T11:56:14.695Z","comments":true,"path":"posts/19fa4593/","link":"","permalink":"https://www.beenli.cn/posts/19fa4593/","excerpt":"","text":"一、概述在复杂的数字电路中，不仅需要对各种数字信号进行算术运算和逻辑运算，而且还需要在运算过程中不断将运算数据和运算结果保存起来。因此，存储电路就成为计算机以及所有复杂数字系统不可缺少的组成部分。分类总结二、SR锁存器SR锁存器(Set-Reset Latch) 是静态存储单元中最基本，也是电路结构最简单的一种。或门锁存器当$R_D$是1或者$S_D$是1而另外一个是0时，可以看到S起到set 1；而R起到reset 0的作用。当有一个回到0时(此时两输入都为0)，可以保持原来的状态不变。(因为输出的1反馈到输入)❌不允许输入同为1。（此时输出同为0为无效状态，并且同时变为0时存在竞争冒险）与门锁存器(同理)🙂三、触发器触发器与锁存器不同在于：增加了一个触发信号输入端(时钟信号CLK)。只有当触发信号到来时，其功能与锁存器相同。1、电平触发只有触发信号在有效电平的时候，输入信号才能作用。1①同步SR触发器框图Cl外面没有⭕代表高电平有效②异步复位置位// 将置位信号$S_{D}^{‘}$接入G1, 复位信号$R_{D}^{‘}$接G2③单端输入(D型号锁存器)// 规避了约束条件SR=0④Transparent D-Latch// CMOS传输门构成当TG2打开，TG1关闭时。两个反相器串联把截止前瞬间的信号(反相器G1输入电容)锁住。2、边沿触发提高触发器可靠性，增强抗干扰能力，希望触发器次态仅取决于CLK信号边沿到达时刻输入信号的状态。而边沿之前或之后输入状态的变化对触发器的次态没有影响。①两个电平触发D触发器不看置位信号就是两个Transparent D-Latch当第一个工作时，第二个保持。透明D锁存器：所以输出能跟随时钟边沿瞬间输入的值②维持阻塞📌③门电路传输延迟📌3、脉冲触发为了提高可靠性：希望每个CLK周期里面输出端状态只能改变一次①主从SRMaster-Slave SR Flip-Flop￢：延时输出高电平有效，下降沿状态才会改变clk高电平主触发器有效，从触发器保持原来状态。clk从高变到低时，主触发器被封锁，从触发器按照主触发器相同的状态翻转。因此：一个周期输出只可能翻转一次。②主从JK(规避SR=1)Q^* = S + \\overline RQ(for\\quad SR)JK: S=J \\overline Q\\quad R=KQQ^*=J \\overline Q+(\\overline K+\\overline Q)Q=J \\overline Q + \\overline KQ\\quad(for\\quad JK)clk变低电平时把主触发器的值复制给了次触发器。（所以上边推导时Q即代表中间输出也代表后边输出）主触发器有效时(高电平)Q要么为1要么为0，不可能同时为0或者为1。因为G3,G4都为1。它们通过反相器互咬。考察当J=1，R=1时，G7,G8输出$Q$和$\\overline Q$(不是全0，就🆗)。所以当Q=1，输出为0，当Q=0,输出为1,即反向。四、触发器的动态特性📌五、References1.外国教材有时把此电路叫（Gated SR latch), 时钟信号叫做“使能”信号（enable） ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"digital electronic technique","slug":"Digital-IC/digital-electronic-technique","permalink":"https://www.beenli.cn/categories/Digital-IC/digital-electronic-technique/"}],"tags":[{"name":"circuits","slug":"circuits","permalink":"https://www.beenli.cn/tags/circuits/"}]},{"title":"riscv-gnu-toolchain 下载、编译","slug":"riscv-gnu-toolchain-下载、编译","date":"2020-08-01T01:23:29.000Z","updated":"2020-09-30T12:18:58.860Z","comments":true,"path":"posts/6c0abcd9/","link":"","permalink":"https://www.beenli.cn/posts/6c0abcd9/","excerpt":"","text":"1、前言riscv-gnu-toolchain 是学习 risc-v 的前提，但是网上对这方面的介绍很少，并且工具链种类繁多，很可能让我们摸不清头脑。2、下载篇由于riscv-gnu-toolchain包含有好多第三方库，整个项目文件很大[官方说的是6.65GB]，加上国内GitHub堪比🐢速，你多半是不可能按官方教程下下来。项目名称项目描述项目用途qemu模拟器（类似bochs,PearPC)riscv-binutils开发工具(compiler、assemble、linker、debugger…)riscv-dejagnu测试其它程序的框架(framework)riscv-gccGNU Compiler Collectionriscv-gdb同riscv-binutilsriscv-glibcGNU C Library(system-API,其它的语言也通过它访问OS)riscv-newlib一套开发工具（用的库有别于riscv-binutils)binutils 和 newlib 之间的区别（坑待填o_o ….）PrerequisitesPC: x86OS: Ubuntu 20.04.1 LTSVM: wmware15.5Pro下载源代码（推荐使用hub.fastgit.org镜像站，比原生站快几百倍）git clone https://hub.fastgit.org/riscv/riscv-gnu-toolchain cd riscv-gnu-toolchain git submodule update --init --recursive安装依赖（其它系统查看官方readme)sudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev下载失败解决方案git clone qemu下载速度太慢导致失败（因为qemu没有把项目托管在GitHub上)链接：https://pan.baidu.com/s/1xGrafiu4I0yPAnE0iuTYzw提取码：3iyy下载源码, 解压到相应的目录上即可。其它模块没有拉下来。在源项目下挨个手动克隆。cd ~/riscv/riscv-gnu-toolchain git clone https://hub.fastgit.org/riscv/riscv-gcc.git3、编译篇1、Newlib建立一个安装路径：makdir /opt/riscv[最好建立一个编译文件夹]：makdir build &amp;&amp; cd build配置环境变量：export PATH=$PATH:/opt/riscv/bin(建议写到~/.bashrc上，永久有效./configure --prefix=/opt/riscv make2、Linux跟上面相同的步骤，不过最好换一个干净的文件夹。默认是安装RV64GC(64-bit), 即使在32-bit的构建环境中。./configure --prefix=/opt/riscv make linuxAlternatively：（构建32-bit RV32GC)./configure --prefix=/opt/riscv --with-arch=rv32gc --with-abi=ilp32d make linux支持的架构有：rv32i、rv64i标准扩展： (a)tomics, (m)ultiplication and division, (f)loat, (d)ouble, or (g)eneral for MAFD支持的ABIs: ilp32 (32-bit soft-float), ilp32d (32-bit hard-float), ilp32f (32-bit with single-precision in registers and double in memory, niche use only), lp64 lp64f lp64d (same but with 64-bit long and pointers).3、Linux multilib同时支持32-bit和64-bit的Linux。./configure --prefix=/opt/riscv --enable-multilib make linux编译出来的工具带有前缀：riscv64-unknown-linux-gnu-, 但是能编译32位和64位程序。4、编译结果经过漫长的等待，我终于编译Linux 64bit版本。Referencesriscv各种版本gcc工具链编译与安装 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://www.beenli.cn/categories/RISC-V/"},{"name":"environment","slug":"RISC-V/environment","permalink":"https://www.beenli.cn/categories/RISC-V/environment/"}],"tags":[{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"}]},{"title":"jupyter notebook","slug":"jupyter-notebook","date":"2020-07-23T07:13:27.000Z","updated":"2020-09-30T12:21:08.467Z","comments":true,"path":"posts/2641cf45/","link":"","permalink":"https://www.beenli.cn/posts/2641cf45/","excerpt":"","text":"jupyter notebook1、安装安装python安装pip（安装ipython）安装jupyter notebook(pip install jupyter notebook)2、jupyter命令查看已经安装的核jupyter kernelspec list Available kernels: py38 C:\\Users\\wanli\\AppData\\Roaming\\jupyter\\kernels\\py38 python3 C:\\ProgramData\\jupyter\\kernels\\python3移除已经安装的核jupyter kernelspec remove [kernelname]安装核python -m ipykernel install [--user] --name [kernelname]3、conda创建虚拟环境查看已经有的环境$ conda env list # conda environments: # base * D:\\APP\\miniconda py38 D:\\APP\\miniconda\\envs\\py38安装新的环境conda create -n py36 python=3.6激活环境/推出环境conda activate envname conda deactivate4、遇到的问题jupyter ImportError: DLL load failed: 找不到指定的程序。(kernel error)where jupyter我发现我有两个jupyter, 两个python试过了网上好多办法都不管用(大多叫你添加环境变量)最终我把其中一个jupyter(有问题的)卸载了，用另外一个就好了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software","slug":"Software","permalink":"https://www.beenli.cn/categories/Software/"},{"name":"jupyter","slug":"Software/jupyter","permalink":"https://www.beenli.cn/categories/Software/jupyter/"}],"tags":[{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"}]},{"title":"超前进位加法器","slug":"超前进位加法器","date":"2020-04-28T09:31:08.000Z","updated":"2020-09-30T12:02:22.737Z","comments":true,"path":"posts/1aa82b80/","link":"","permalink":"https://www.beenli.cn/posts/1aa82b80/","excerpt":"","text":"1、1bit全加器S = A\\oplus B \\oplus C_{in}C_{out} = AB + (A \\oplus B)C_{in}2、4bit行波加法器可以看到要得到最后的进位要经过9个门的延时。3、4bit超前进位加法器进位产生信号:g_i = A_iB_i进位传输信号:p_i = A_i\\oplus B_i则：S_i = p_i \\oplus c_iC_{i+1} = p_ic_i + g_i\\quad(c_o = c_{in})判断进位的步骤:如果 $g_i$=1 (其他不用看肯定会进位)如果 $g_i$=0；看传输信号$p_i$。如果 $p_i$=0; 那不用看，已经否决了进位如果 $p_i$=1; 那么用同样的方法看下一位是否有进位判断结果的步骤: 只需把传输信号与进位信号异或。化简得到：c_1 = g_0 + p_oc_0(3个门延时)c_2 = g_1 + g_0p_1 + p_1p_0c_0(3个门延时)c_3 = g_2 + p_2g_1 + p_2p_1g_0 + p_2p_1p_0c_0(3个延时)c_4 = g_3 + p_3g_2 + p_3p_2g_1 + p_3p_2p_1g_0 + p_3p_2p_1p_0c_0👇下面是经过综合器优化门个数后的图。可以明显看到虽然门个数减少但是延时变长。4、超前进位加法器级联pp = p[0] \\& p[1] \\& p[2] \\& p[3](传输信号)gg = c_4(进位信号)pp： 代表相加结果为1111的时候。那么低一级要是有进位，传到我这一级，会产生想上一级的进位。// Author: Wan Li // time: 2020-04-28 // function: 把4个超前进位组成16位的 // --------------------------------------------------- /* `include \"adder4.v\" */ module adder_16(a, b, c_in, sum, c_out); input[15:0] a, b; input c_in; output[15:0] sum; output c_out; wire[3:0] p, g, c; assign c[0] = c_in; add4_head add1(.a(a[3:0]), .b(b[3:0]), .ci(c[0]), .s(sum[3:0]), .pp(p[0]), .gg(g[0])); assign c[1] = g[0] | (p[0] &amp; c[0]); add4_head add2(.a(a[7:4]), .b(b[7:4]), .ci(c[1]), .s(sum[7:4]), .pp(p[1]), .gg(g[1])); assign c[2] = g[1] | (p[1] &amp; c[1]); add4_head add3(.a(a[11:8]), .b(b[11:8]), .ci(c[2]), .s(sum[11:8]), .pp(p[2]), .gg(g[2])); assign c[3] = g[2] | (p[2] &amp; c[2]); add4_head add4(.a(a[15:12]), .b(b[15:12]), .ci(c[3]), .s(sum[15:12]), .pp(p[3]), .gg(g[3])); assign c_out = g[3] | (p[3] &amp; c[3]); endmodule document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"circuits","slug":"circuits","permalink":"https://www.beenli.cn/tags/circuits/"}]},{"title":"Git for novice","slug":"Git-for-novice","date":"2020-04-27T10:09:18.000Z","updated":"2020-08-05T09:57:24.460Z","comments":true,"path":"posts/f05478c5/","link":"","permalink":"https://www.beenli.cn/posts/f05478c5/","excerpt":"","text":"1、Git and GitHubGithub 可以看成是一个基于Git的系统，它提供了仓库的可视化。是一个远程托管仓库。如果是public，其他人可以随意查看，修改。如果是private只有你自己可以查看了。如果为了安全，可以团队自己搭建一个git服务器。Git大家都已经很熟悉了，分布式版本控制系统(Distributed version control system)2、Why do we use git可以更好地在GitHub上开发，分享啊。多人协同开发。版本控制，可以任意回滚到之前某个版本。3、How do we use git场景1在GitHub上看到一个不错的项目，想要研究，学习为目的。先fork一份到自己的GitHub上。clone到本地-o 指定远程仓库的名字，否则默认为origingit clone [-b &lt;指定分支名&gt;]&lt;远程仓库地址&gt; [-o booyah] 默认是克隆所有分支。进行自己的开发。修改文件后此时git status可以看到：修改过的文件红色标处。Untracked filesgit add ./[filename] // 把修改过的文件添加到暂存区。此时文件变成绿色。即已经添加到了暂存区。提交git commit -m \"添加文件的说明\" // 提交提交完成了，工作目录应该显示是空的。推送到远程仓库git pull origin [branch name] // 推送到指定仓库的指定分支上。场景2自己新建一个仓库。做项目开发。初始化一个本地仓库git init xxx // 新建一个名为xxx的仓库进入仓库，然后就可以开发了。cd xxx // 此目录就是工程根目录。如果要上传到GitHub上。即远端git服务器首先在GitHub上新建一个仓库。本地仓库与远程仓库建立联系。git remote add origin &lt;server&gt; // 与GitHub仓库建立联系. origin 可以换成任意名字。可以看到我通过origin pull不上去。因为我连接的是remote_name。push到远程服务器上git push origin master // 推送到远程服务器上如果是克隆远程仓库的话，那么可以跳过remote（因为本地master已经和远程master联系上了)。直接推送到远程服务器。4、common commands11、branch（分支)1、新建分支git checkout -b xxx // 新建分支并切换到xxx git branch xxx // 只是新建一个分支，仍留在本地。（新建的分支复刻目分支)git branch [-b branchName commitId] 从指定分支和commit号上开始新的分支2、分支切换git branch [-a] //查看分支 git checkout xxx //切换到xxx分支git branch 参数-a: 查看所有分支，包括远端的分支。 -v 查看分支指向的commit。 —remote查看远程分支3、合并分支先把你次要分支提交完全。切换到你要合并其他分支的主分支上合并git merge test // 在主分支上合并test分支可以看到已经合并了test1分支。现在它们指向同一个commit。如果遇到冲突，手动判断哪一个修改留下。4、删除分支git branch -d [branch name] git push origin --delete [branch name] // 删除远程分支 $ git push origin --delete testing To github.com:BeenLi/learn_git.git - [deleted] testing5、远程分支$ git ls-remote // 查看远程分支 From git@github.com:BeenLi/learn_git.git 6fc7758ee27a73196a81391efd803dc19541eb88 HEAD 6fc7758ee27a73196a81391efd803dc19541eb88 refs/heads/master 807b956e7a57eef2f148dc7cb5b14ae3992955e6 refs/heads/testing 807b956e7a57eef2f148dc7cb5b14ae3992955e6 refs/pull/1/head 998239f25772ea809310d9f92c9e96a67c158b82 refs/pull/1/merge $ git remote show // 查看远程仓库名字 remote_name“origin” 是当你运行 git clone 时默认的远程仓库名字6、跟踪分支git checkout -b [branch] [remotename]/[branch] git checkout --track origin/serverfix // 快捷命令 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支 git branch --set-upstream-to origin/remoteBranchName localBranchName 修改远程分支 git branch --unset-upstream // 撤销跟踪远程分支可以看到 设置了分支test3 跟踪 远端的master分支。现在分支与master分支相同。现在，本地分支 test 会自动从 remote_name/master 拉取。$ git branch -vv master 2b2be16 修改文件，制造合并冲突 test1 2b2be16 修改文件，制造合并冲突 test2 420f721 第二次本地提交 testing e051a6f [remote_name/testing: ahead 1] 测试追踪分支情况 * test3 4fdb7bd [remote_name/master] 测试本地提交 可以看到test3 是master的跟踪分支。 testing分支领先1。表示有本地有一个commit没有push到服务器上。7、分支拉取git pull == git fetch + git merge git fetch 不会修改当前工作区的文件。它只会获取数据然后让你自己合并。8、上传分支git push origin localbranch:remotebranch 如果添加了远程分支就直接push了。2、reset (撤销)参考🔗1、reset —hardreset —hard：重置stage区和工作目录(会在重置 HEAD 和branch的同时，重置stage区和工作目录里的内容)即回到上一次commit的位置。，全部清空。2、reset —softreset —soft：保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区即你之前commit的文件，退回到stage。需要重新提交。3、reset [—mixed]reset: 保留工作目录，并清空暂存区也就是你要重新add，然后commit。Reference[1] 分支用法[2] reset用法[3] 简明教程[4] 动态过程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software","slug":"Software","permalink":"https://www.beenli.cn/categories/Software/"},{"name":"Git","slug":"Software/Git","permalink":"https://www.beenli.cn/categories/Software/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"}]},{"title":"数据结构——树","slug":"数据结构——树","date":"2020-04-09T05:43:31.000Z","updated":"2020-08-22T07:22:18.619Z","comments":true,"path":"posts/f796a091/","link":"","permalink":"https://www.beenli.cn/posts/f796a091/","excerpt":"","text":"1、树的相关术语度：一个结点的子结点数目。树的度指度数最大的那个结点的度TD = max_{i=1...n}D(i)\\quad D(i)表示第i个结点的度叶结点，分支结点度为0的结点——叶结点；度大于0的结点——分支结点结点的层数(1) root(T)——层数为0(2)其余结点层数为前驱结点层数 + 1路径V_m——>V_{m+1}——>...——>V_{m+k} \\quad1","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Data Structure","slug":"CS/Data-Structure","permalink":"https://www.beenli.cn/categories/CS/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"}]},{"title":"Tasks and Functions","slug":"Tasks-and-Functions","date":"2020-04-08T14:20:43.000Z","updated":"2020-09-30T12:00:56.368Z","comments":true,"path":"posts/71407778/","link":"","permalink":"https://www.beenli.cn/posts/71407778/","excerpt":"","text":"Tasks and Functions1、What are they good forTasks and functions provide the ability to execute common procedures from several different places in a description. They also provide a means of breaking up large procedures into smaller ones to make it easier to read and debug the source descriptions.从std 1364-2005的这段描述中，我们可以总结出以下用处:减少重复工作，代码复用。把大的过程拆解成几个小的任务和函数，更加易读和找bug2、Distinctions between tasks and functionsA function shall execute in one simulation time unit; a task can contain time-controlling statements.函数应该瞬间返回结果，不能有延时；而任务可以带有延时控制语句。A function cannot enable a task; a task can enable other tasks and functions.函数不能调用任务；但是任务可以调用其他任务或者函数。A function shall have at least one input type argument and shall not have an output or inout type argument; a task can have zero or more arguments of any type.函数应该至少有一个输入参数并且不能有输出或者输入输出参数。任务可以有零个或者任意个任何种类的参数。A function shall return a single value; a task shall not return a value.函数应该返回一个单一的值；任务不能返回值(只能通过把处理放在参数上带回)The purpose of a function is to respond to an input value by returning a single value. A task can support multiple goals and can calculate multiple result values. However, only the output or inout type arguments pass result values back from the invocation of a task. A function is used as an operand in an expression; the value of that operand is the value returned by the function.函数的目的：对于输入给出一个返回结果任务支持多个结果，但是只有输出或者输入输出参数能够传递这种结果函数可以在表达式中用作一个操作数。（其值就是函数返回的结果。是不是很像C)例如：switch_bytes(old_word, new_word); //task会把运算结果放在new_word上 new_word = switch_bytes(old_word); //function会直接把结果返回。比较点tasksfunctions输入输出任意多输入输出(input,output,inout)至少一个输入不能有输出触发事件控制可以包含延时控制语句(#), 只能面向仿真，不能综合不能出现always, # 等语句，函数应该在一个时间单元内返回值返回值通过输出端口传递通过函数名返回(only one)中段可以由disable中断不能语句调用其他可以调用task和function只能调用function，不能调用task其他说明task调用可以作为完整的语句出现function调用只能作为赋值语句右边的operand3、 Tasks and task enablingA task shall be enabled from a statement that defines the argument values to be passed to the task and the variables that receive the results. Control shall be passed back to the enabling process after the task has completed. Thus, if a task has timing controls inside it, then the time of enabling a task can be different from the time at which the control is returned. A task can enable other tasks, which in turn can enable still other tasks—with no limit on the number of tasks enabled. Regardless of how many tasks have been enabled,control shall not return until all enabled tasks have completed.调用task应该给出传进参数的值，和接受结果的变量。task如果有延时控制，那么task被调用时刻和控制返回时刻可以不同。task内可以再调用task，直到所有的task完成才会返回控制到顶层调用处。3.1、task declaration syntaxestask_declaration ::= (From A.2.7) task [ automatic ] task_identifier ; { task_item_declaration } statement_or_null endtask task_declaration ::= (From A.2.7) task [ automatic ] task_identifier ( [ task_port_list ] ) ; { block_item_declaration } statement_or_null endtaskTasks without the optional keyword automatic are static tasks, with all declared items being statically allocated. These items shall be shared across all uses of the task executing concurrently. All items declared inside automatic tasks are allocated dynamically for each invocation Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through use of their hierarchical name.（automatic的坑后面再填)3.2、Task enabling and argument passingtask_enable ::= (From A.6.9) hierarchical_task_identifier [ ( expression { , expression } ) ] ;If the argument is declared as an output or an inout, then the expression shall be restricted to an expression that is valid on the left-hand side of a procedural assignment.(输出参数：能位于过程赋值语句左边的有效表达式。不能是wire)reg, integer, real, realtime, and time variablesMemory referencesConcatenations of reg, integer, and time variablesConcatenations of memory referencesBit-selects and part-selects of reg, integer, and time variablesAll arguments to the task shall be passed by value rather than by reference任务参数的是值传递不是引用(指针)If an argument in the task is declared as an input, then the corresponding expression can be any expression.The order of evaluation of the expressions in the argument list is undefined.如果参数被定义为input，那么调用语句与之相应位置的表达式没有限制，表达式求值过程是没有被定义的。（求值顺序没有先后）task my_task; input a, b; inout c; output d, e; begin . . . // statements that perform the work of the task . . . c = foo1; // the assignments that initialize result regs d = foo2; e = foo3; end endtasktask my_task ( input a, b, inout c, output d, e); begin . . . // statements that perform the work of the task . . . c = foo1; // the assignments that initialize result regs d = foo2; e = foo3; end endtask一种是参数列表在函数名后定义。一种是在task里面定义。my_task (v, w, x, y, z); //调用语句The task-enabling arguments ( v , w , x , y , and z ) correspond to the arguments ( a , b , c , d , and e ) defined by the task.当函数调用时:a = v;b = w;c = x;When the task completes, the following assignments to return the computed values to thecalling process are performed:(当函数结束后，下面的赋值返回对应的结果)x = c;y = d;z = e;task enable statement中参数位置要和task definition 对应。不管你是哪种方法定义task3.3、Task memory usage and concurrent :face_with_head_bandage:（可以跳过）A task may be enabled more than once concurrently. All variables of an automatic task shall be replicated on each concurrent task invocation to store state specific to that invocation.All variables of a static task shall be static in that there shall be a single variable corresponding to each declared local variable in a module instance, regardless of the number of concurrent activations of the task. However, static tasks in different instances of a module shall have separate storage from each other.4、Disabling of named blocks and tasksThe disable statement provides the ability to terminate the activity associated with concurrently active procedures, while maintaining the structured nature of Verilog HDL procedural descriptions.（disable 语句可以终止正在运行的过程）begin : block_name rega = regb; disable block_name; regc = rega; // this assignment will never execute endbegin : block_name ... if (a == 0) disable block_name; ... end // end of named block // continue with code following named blocktask proc_a; begin ... ... if (a == 0) disable proc_a; // return if true(控制权交回调用语句) ... ... end endtaskbegin : break for (i = 0; i &lt; n; i = i+1) begin : continue @ clk if (a == 0) // \"continue\" loop disable continue; //(相当于c里面的break) statements statements @ clk if (a == b) // \"break\" from loop disable break; // (相当于c里面的break) statements statements end endfork begin : event_expr @ ev1; repeat (3) @ trig; # d action (areg, breg); //(只有当ev1出现，trig出现3次才触发) end @ reset disable event_expr; //(同上面并行进行) joinalways begin : monostable # 250 q = 0; end always @ retrig begin //（只要retrig变化间隔小于250，那么q就一直为1) disable monostable; q = 1; end5、Functions and function calling5.1、Function declarationsfunction_declaration ::= (From A.2.6) function [ automatic ] [ function_range_or_type ] function_identifier ; function_item_declaration { function_item_declaration } function_statement endfunction | function [ automatic ] [ function_range_or_type ] function_identifier ( function_port_list ) ; { block_item_declaration } function_statement endfunctionfunction [7:0] getbyte; // (如果没有给[range]那么默认为scalar) input [15:0] address; begin // code to extract low-order byte from addressed word . . . getbyte = result _expression; end endfunctionfunction [7:0] getbyte ( input [15:0] address); begin // code to extract low-order byte from addressed word . . . getbyte = result _expression; end endfunction5.2、Returning a value from a functionThe function definition shall implicitly declare a variable, internal to the function, with the same name as the function. This variable either defaults to a 1-bit reg or is the same type as the type specified in the function declaration. The function definition initializes the return value from the function by assigning the function result to the internal variable with the same name as the function.函数定义就隐含了一个变量（即函数名）函数通过给这个隐含变量赋值返回值。5.3、Calling a functionfunction_call ::= (From A.8.2) hierarchical_function_identifier{ attribute_instance } ( expression { , expression } )word = control ? {getbyte(msbyte), getbyte(lsbyte)}:0;(把两次函数调用的结果拼接起来)5.4、Function rulesA function shall not have any nonblocking assignments or procedural continuous assignments.函数不能有非阻塞赋值或者过程连续赋值（在一个时间单位内完成）A function shall not have any event triggers.函数不能有任何时间触发module tryfact; // define the function function automatic integer factorial; input [31:0] operand; integer i; if (operand &gt;= 2) factorial = factorial (operand - 1) * operand; else factorial = 1; endfunction // test the function integer result; integer n; initial begin for (n = 0; n &lt;= 7; n = n+1) begin result = factorial(n); $display (\"%0d factorial=%0d\", n, result);5.5、 Use of constant functions🤕（可以跳过）Constant function calls are used to support the building of complex calculations of values at elaboration time常量函数调用用于支持在精化阶段构建复杂的值计算🙂o_o ….待填坑。Renference[IEEE Std 1364™-2005下载🔗]：链接：https://pan.baidu.com/s/1ryz4IAuQzNPnGifUJ8oAGw提取码：2qvb document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"specification","slug":"specification","permalink":"https://www.beenli.cn/tags/specification/"}]},{"title":"git hooks自动部署hexo","slug":"git-hook自动部署hexo","date":"2020-04-08T01:17:29.000Z","updated":"2020-08-05T09:57:43.216Z","comments":true,"path":"posts/fb29ac9a/","link":"","permalink":"https://www.beenli.cn/posts/fb29ac9a/","excerpt":"","text":"git hooks 自动部署hexo1、原理大致如下2、实施过程在服务器上搭建一个git服务器1adduser git(创建一个用户)可以给创建的用户设置密钥passwd git赋予git用户sudo权限chmod 740 /etc/sudoersvim /etc/sudoer `给git用户添加命令权限如下` 保存后退出，修改回文件权限`chmod 440 /etc/sudoers` ![mark](http://image.beenli.cn/img/20200408/cSLiyuqjcxOU.jpg?imageslim) 2. 初始化git仓库 ```bash su git //切换至git用户 mkdir blog.git //创建仓库文件夹 cd blog.git //进入文件夹 git init --bare //使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区创建网站目录sudo mkdir /var/www/blog //创建网站根目录 sudo chown -R git.git /var/www/blog //把blog目录以及子目录属组改为git (这一步很重要，否者后续提交没有权限)配置密钥[详情见:ssh协议](https://www.beenli.cn/posts/782a8ece/mkdir .ssh //创建.ssh目录(默认你在git用户的~目录下) cd .ssh touch authorized_keys //把你本地生成的公钥拷贝到此文件夹种配置hooks(git 用户下)2cd ~/blog.git/hooks //切换到hooks目录 touch post-receive //创建post-receive文件 chmod +x post-receive //赋予其可执行权限The post-receive hook runs after the entire process is completed and can be used to update other services or notify users. It takes the same stdin data as the pre-receive hook. Examples include emailing a list, notifying a continuous integration server, or updating a ticket-tracking system – you can even parse the commit messages to see if any tickets need to be opened, modified, or closed. This script can’t stop the push process, but the client doesn’t disconnect until it has completed, so be careful if you try to do anything that may take a long time.复制该段代码到刚刚创建的post-receive文件#!/bin/bash echo \"post-receive hook is running...\" GIT_REPO=/home/git/blog.git TMP_GIT_CLONE=/tmp/blog PUBLIC_WWW=/var/www/blog rm -rf ${TMP_GIT_CLONE} git clone $GIT_REPO $TMP_GIT_CLONE rm -rf ${PUBLIC_WWW}/* cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}在执行cp（复制)命令的时候，.git 作为隐藏目录不会被拷贝到 Web 根目录下，也就避免了将整个仓库历史暴露在 Web 服务中。最后配置hexo的_config.ymldeploy: type: git repository: git@VPS IP:/~/blog.git # 默认22端口 branch: masterReference[1] Hexo 博客部署到 VPS[2] git hooks document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software","slug":"Software","permalink":"https://www.beenli.cn/categories/Software/"},{"name":"Git","slug":"Software/Git","permalink":"https://www.beenli.cn/categories/Software/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.beenli.cn/tags/Hexo/"}]},{"title":"SSH","slug":"SSH","date":"2020-04-07T16:25:51.000Z","updated":"2020-09-30T11:59:15.058Z","comments":true,"path":"posts/782a8ece/","link":"","permalink":"https://www.beenli.cn/posts/782a8ece/","excerpt":"","text":"SSH ProtocolSecure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network.[1] Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH.摘自维基百科。主要为远程登录建立安全的通道。1、简要的工作原理ssh有两种工作方式基于口令验证只要知道帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但缺点是：不能保证你正在连接的服务器就是你想连接的服务器。以下是登录验证流程：基于密钥验证2、操作过程(本地win10+服务器centos)本地生成密钥对\"Git Bash Hear\" ssh-keygen -t rsa可以设置密码，也可以为空（既然为了免密那就设置为空吧，不然没意义了）文件路径可选。默认放在~/.ssh/上传公钥到服务器上1有两种办法：自行把刚刚上传的公钥上传到服务器指定用户.ssh/目录下的authorized_keys下。（认证密钥可以有很多把，多个localhost可以各自上传自己的🔒到服务器上。也可以所有人公用一把锁。）ssh-copy-id -i [./y.pub] username@vps ip(-i指定路径，默认是在.ssh下)这一步也是要认证密码的。不然什么人都可以上锁就乱套。免密登录服务器ssh -i[dir] username@vps ip(-i指定密钥所在，默认在.ssh/下)如果之前产生密钥对时设置了密码，这里还是要输入一遍哪个密码的。如果为空就可以直接免密进入了脚本文件加速登录2随便选择个文件夹，写一个config文件Host vps # 一个便于你区别这是哪台机器的名字 HostName 47.95.247.18 User git # 登录主机的用户名称 Port 22 IdentityFile ~/.ssh/id_rsa # 密钥所在的文件位置 ssh -F [config file] vps(指定配置文件位置)就可以直接登录你设置的那台主机可能遇到的问题3Authentication refused: bad ownership or modes for directory /root/.sshls -l /root/.ssh发现改目录的所有者不是root。只用改成root即可chown -R root.root /root/.sshReference[1] SSH 三步解决免密登录[2] ssh配置config快速登录[3] 解决权限问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Network","slug":"CS/Computer-Network","permalink":"https://www.beenli.cn/categories/CS/Computer-Network/"}],"tags":[{"name":"protocols","slug":"protocols","permalink":"https://www.beenli.cn/tags/protocols/"}]},{"title":"操作系统-熟悉实验环境(1)","slug":"操作系统-熟悉实验环境(1)","date":"2020-04-07T05:07:15.000Z","updated":"2020-09-30T12:09:20.331Z","comments":true,"path":"posts/9cf5ff72/","link":"","permalink":"https://www.beenli.cn/posts/9cf5ff72/","excerpt":"","text":"熟悉实验环境1、x86模拟器Bochs1Bochs is a highly portable open source IA-32 (x86) PC emulator written in C++, that runs on most popular platforms. It includes emulation of the Intel x86 CPU, common I/O devices, and a custom BIOS. Bochs can be compiled to emulate many different x86 CPUs, from early 386 to the most recent x86-64 Intel and AMD processors which may even not reached the market yet.可以看到Boch可以模拟intel x86 CPU在它模拟出的环境中可以运行 Linux、DOS 和各种版本的 Windows 等多种操作系统2、操作系统Ubuntu因为有些实验内容涉及到在自己改进的 Linux 0.11下，运行自己编的应用程序。被改进的功能都是高 版本 Linux 内核已经具有的，在其上确认自己编写的应用程序无误后，再用之测试自己改进的 Linux 0.11，可以更有信心些。3、实验压缩包hit-oslab文件结构:. .. └── bocks | ├── BIOS-bochs-latest | ├── bochs-dbg | ├── bochs-gdb | ├── bochsrc.bxrc | ├── bochsrc-gdb.bxrc | └── vgabios.bin | └── hdc | └── umounted └── Linux-0.11 | └── boot | ├── kernel | ├── fs | ├── lib | ├── init | ├── mm | ├── tools | ├── include | ├── tags | └── Makefile ├── dbg-asm ├── dbg-c ├── gdb ├── gdb-cmd.txt ├── run ├── rungdb └── mount-hdcImage文件我们在宿主操作系统也就是ubuntu上对Linux 0.11进行开发，修改和编译。之后在Linux-0.11目录会生成一个Image的文件。（编译后的目标文件）该文件包含引导和所以内核的二进制代码。oslab 采用 bochs 模拟器加载这个 Image 文件，模拟执行 Linux 0.11，这样省却了重新启动计算机的麻烦。bochs目录bochs目录是与bochs相关的执行文件、数据文件和配置文件run 脚本run 是 运行bochs的脚本命令运行后bochs会自动在他的虚拟软驱——linux-0.11/Image虚拟硬盘——hdc-0.11.img在 0.11 下访问文件系统，访问的就是 hdc-0.11.img 文件内虚拟的文件系统。退出bochs之前现存盘，运行sync命令hdc-0.11.img 文件文件的格式是 Minix 文件系统的镜像。Linux 所有版本都支持这种格式的文件系统所以可以在宿主系统上挂载该文件系统。达到宿主系统和Linux 0.11之间文件交换的效果其中包含的文件有：Bash shell；一些基本的 Linux 命令、工具，比如 cp、rm、mv、tar；vi 编辑器；gcc 1.4 编译器，可用来编译标准 C 程序；as86 和 ld86；Linux 0.11 的源代码，可在 0.11 下编译，然后覆盖现有的二进制内核。编译make all(make 命令会自动跳过未被修改的文件 )如果重新编译没有效果可以试试删除中间文件: make clean &amp;&amp; make all运行./run4、调试汇编级调试./dbg-asmC语言调试./dbg-c./rungdb(新开一个窗口)注意：启动的顺序不能交换，否则 gdb 无法连接。5、文件交换# 启动挂载脚本 $ cd ~/oslab $ sudo ./mount-hdc # 进入文件系统 $ cd ./mount-hdc/ # 读写完毕，卸载文件系统 $ cd ~/oslab $ sudo umount hdcReference[1] 哈尔滨工业大学.操作系统 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"OS","slug":"CS/OS","permalink":"https://www.beenli.cn/categories/CS/OS/"}],"tags":[{"name":"online course","slug":"online-course","permalink":"https://www.beenli.cn/tags/online-course/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-04-07T04:03:20.000Z","updated":"2020-09-30T12:06:54.423Z","comments":true,"path":"posts/d0edc1ed/","link":"","permalink":"https://www.beenli.cn/posts/d0edc1ed/","excerpt":"","text":"Linux常用命令建立软链接lnln -s [源文件] [链接文件] (创建软链接)例如：在~/oslab/下有一个可执行文件gdb你只能用./gdb去执行它。但是你可以把它链接到$PATH下，这样你可以在任意路径都可以执行ln -s ~/oslab/gdb /usr/local/bin/gdbln -snf ~/oslab/xxx /usr/local/bin/gdb(修改)移动文件mvmv [source] [target]例如：​ mv ~/oslab/oslab/* ~/oslab/ (把~/oslab/oslab/下的文件全部 复制到~/oslab/)mv a.txt b.tax 把文件名a.txt改为b.txt设置权限chmod；chownr 读取权限，数字代号为4;w 写入权限，数字代号为2；x 执行或切换权限，数字代号为1；- 不具任何权限，数字代号为0；7rwx6rw-5r-x4r—3-wx2-w-1—x0—-chmod u+x,g+w f0 //为文件f0设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f0 //为文件f0设置自己可以读写执行，同组可以读写。其他人可以读 chmod 764 f0 // 效果同上 chmod a+x f0 // 所有人都可以执行 chown -R liu /usr/meng //将目录/usr/meng及其下面的所有文件、子目录的文件属主改成 liu： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.beenli.cn/categories/Linux/"}],"tags":[{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"}]},{"title":"VIM Plug-in","slug":"VIM-Plugs","date":"2020-04-06T09:11:58.000Z","updated":"2020-09-30T12:05:04.847Z","comments":true,"path":"posts/b71407e8/","link":"","permalink":"https://www.beenli.cn/posts/b71407e8/","excerpt":"","text":"VIM-Plugs1、vim-plug: 插件管理器call plug#begin('D:/App/vim/vim81/vimfiles/plugs')//插件安装目录(可以随意定) \" Shorthand notation for plugin Plug 'foo/bar' //插件下载地址，GitHub可以简写 call plug#end() // 函数结束标志command:PlugInstall // 安装插件:PlugClean // 清理invalid插件:PlugUpgrade // 升级插件:PlugDiff // 查看现有插件与下载地址处插件不同，即检测更新细节:PlugStatus // 查看插件加载情况:PlugSnapshot // 生成用于恢复当前插件快照的脚本featurePlug 'zhuzhzh/verilog_emacsauto.vim', {'for': ['verilog', 'systemverilog'] } // 当且仅当打开的文件为Verilog或者systemVerilog时加载此插件 Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } //当且仅当触发toggle命令时加载此插件2、lightline:彩色状态栏3、vim-colors-solarized:比较舒服的配色方案此插件含有两种色调：dark；lightcall togglebg#map(““) // 可以设置快捷键自行切换4、youcompleteme：自动补全5、vim-snippets+SirVer/ultisnips : 代码片填充第一个插件提供好多语言的代码片文件。第二插件提供的填充引擎。snippet有两种格式：snippets/*: snippets using snipMate formatUltiSnips/*: snippets using UltiSnips format可以自己编写snippets文件 {n}代表要填写的空白处。/* placeholder*/ snippet test // Author: Wan Li // time: `strftime(\"%Y-%m-%d\")` // function: ${1:/*写下测试的功能*/} // --------------------------------------------------- \\`timescale 1ns/1ns \\`include \"${2:/*包含的模块文件*/}\" 配置_vimrc文件 let g:UltiSnipsExpandTrigger=\"&lt;c-j&gt;\" //ctrl + j 触发 let g:UltiSnipsJumpForwardTrigger=\"&lt;c-b&gt;\" //ctrl + b 跳到下一个需要填写的空处 let g:UltiSnipsJumpBackwardTrigger=\"&lt;c-z&gt;\" //ctrl + z 跳到上一个需要填写的空出6、nerdtree: 可视化目录树7、tabbar: 整齐的标签窗口8、tpope/vim-commentary: 快速注释gcc ：注释/取消注释一行gc{motion}gc : 注释selection块7，17 Commentary9、vim-gutentags：借助universal ctags 自动产生标签文件🌮有了这个标签文件，你又可以&lt;C+]&gt;跳转10、vim-easy-align：自动对齐按官方配置来设置快捷键/ga触发“ Start interactive EasyAlign in visual mode (e.g. vipga)xmap ga(EasyAlign)“ Start interactive EasyAlign for a motion/text object (e.g. gaip)nmap ga(EasyAlign)1 Around the 1st occurrences of delimiters2 Around the 2nd occurrences of delimiters…* Around all occurrences of delimiters** Left-right alternating alignment around all delimiters- Around the last occurrences of delimiters (-1)-2 Around the second to last occurrences of delimitersKeyDescription/Use cases``General alignment around whitespaces=Operators containing equals sign (=, ==, !=, +=, &amp;&amp;=, …):Suitable for formatting JSON or YAML.Multi-line method chaining,Multi-line method arguments&amp;LaTeX tables (matches &amp; and \\\\)#Ruby/Python comments\"Vim comments``Table markdown document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Software","slug":"Software","permalink":"https://www.beenli.cn/categories/Software/"},{"name":"VIM","slug":"Software/VIM","permalink":"https://www.beenli.cn/categories/Software/VIM/"}],"tags":[{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"}]},{"title":"Gate-and-switch-level modeling","slug":"Gate-and-switch-level-modeling","date":"2020-04-05T01:54:38.000Z","updated":"2020-09-30T12:02:50.978Z","comments":true,"path":"posts/aff089ac/","link":"","permalink":"https://www.beenli.cn/posts/aff089ac/","excerpt":"","text":"Gate-and-switch-level modeling1、verilog-std-1364-20051There are 14 logic gates and 12 switches predefined in the Verilog HDL to provide the gate- and switch-level modeling facility. Modeling with logic gates and switches has the following advantages:— Gates provide a much closer one-to-one mapping between the actual circuit and the model.— There is no continuous assignment equivalent to the bidirectional transfer gate.Verilog1364-2005标准规定了26个基本原件，其中14个门级原件，12个开关级原件。对于这些原件不需要定义直接调用。2、门级建模2多输入门：n_input_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal { , input_terminal } ) and A1(out1, in1, in2); or O1(outa, inb, inc, ind); xor X1(outx, inx, iny, inz, inw);多输出门调用:n_output_gate_instance ::= [ name_of_gate_instance ] ( output_terminal { , output_terminal } , input_terminal ) buf BUF_1(bufout1, bufout2, bufout3, bufin); not NOT_1(out1, out2, in);三态门调用:enable_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , enable_terminal ) bufif1 BF1(data_bus, data, enable);二个电阻The instance declaration of a pullup or a pulldown source shall begin with one of the following keywords: pullup , pulldownpull_gate_instance ::= [ name_of_gate_instance ] ( output_terminal ) pullup (strong1) p1 (neta), p2 (netb); In this example, the p1 instance drives neta and the p2 instance drives netb with strong strength.注意: 门级原件的端口列表都固定好了，可以不用定义中间连接信号类型(wire)示例：// 门级建模实现最小项表达式 // F(a, b, c) = m1 + m2 + m3 + m6 + m7 = (!a)c + b module zuixiaoxiang(out, a, b, c); input a, b, c; output out; wire s1, s2; not U1(s1, a); and U2(s2, s1, c); or U3(out, s2, b); endmodule3、开关级建模MOS switchescmospmosnmosrcmosrnmosrpmosrmos : 代表晶体管导通时源漏有较高的阻抗(impedance)The following example declares a pmos switch: pmos p1 (out, data, control); The output is out , the data input is data , and the control input is control.The instance name is p1 .Bidirectional pass switches(双向开关)trantranif1tranif0rtranrtranif1rtranif0The bidirectional pass switches shall not delay signals propagating through them. When tranif0, tranif1,rtranif0, or rtranif1 devices are turned off, they shall block signals; and when they are turned on, they shall pass signals. The tran and rtran devices cannot be turned off, and they shall always pass signals.(双向开关没有传播延时)The following example declares an instance of tranif1: tranif1 t1 (inout1,inout2,control); The bidirectional terminals are inout1 and inout2 . The control input is control . The instance name is t1 .示例：// 2输入与门 // time:2020-04-05 module and2_1(out, a, b); input a,b; output out; wire s1, s2; supply0 Gnd; supply1 Vdd; pmos U1(s1, Vdd, a); pmos U2(s1, Vdd, b); nmos U3(s1, s2, a); nmos U4(s2, Gnd, b); pmos U5(out, Vdd, s1); nmos U6(out, Gnd, s1); endmodulequarter II 综合不了，没办法直接看viewer。只能把书上的图扒来了。终于找到了一款RTL级，gate级，开关级debugger和viewer的软件trainsistor-level debugger and viewer但是目前下载不了，得找客服联系。不知有人有用过这款软件没有。有的话请你一定告诉我。Renference[1] verilog-std-1364-2005[2] 蔡觉平.2015.Verilog HDL 数字集成电路高级程序设计 31P document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"specification","slug":"specification","permalink":"https://www.beenli.cn/tags/specification/"}]},{"title":"testbench(1)","slug":"testbench-1","date":"2020-04-04T02:38:11.000Z","updated":"2020-09-30T12:01:40.761Z","comments":true,"path":"posts/26241a85/","link":"","permalink":"https://www.beenli.cn/posts/26241a85/","excerpt":"","text":"Testbench(1)1、testbench的结构testbench没有输入输出接口测试模块只负责对待测试系统接口提供激励信号;并监控输出testbench代码不需要可综合，即不被实现成电路产生适当的激励并达到覆盖率要求2、测试激励的描述方式信号的初始化第一种: initial 初始化 initial a = 0; 第二种: 定义信号时初始化 reg[3:0] cnt = 4'b1010;延迟控制延迟语句外部时间控制initial #5 a = b;(等待5tick后计算右端的值并赋值给左边👈) 等价于: initial begin #5; a=b; end内部时间控制initial a = #5 b;(先计算右端的值，等待5tick后再把值赋给左边👈) 等价于 initial begin temp = b; #5; a = temp; end验证程序如下：可以清楚地看到：​ 第一种延时语句，在0-5tick之间只要b变化了,那么第五tick时刻a被赋予的值就是b第五时刻的值。​ 而第二种延时语句：b的值在0时刻已经定好了，不管b在这期间怎么变化，a最终得到的是b在0时刻的值。事件语句@(&lt;事件表达式&gt;);@(&lt;事件表达式&gt;)行为语句;initial begin # 10 @(posedge en) in = ~in; //en的👆上升沿到来时,in取反 end事件语句@必须等指定事件到来才执行等待语句wait(&lt;条件表达式&gt;) 行为语句always #5 cnt=cnt+1'b1; initial wait(cnt == 4'b1111) $display($time,,,\"cnt = %b\", cnt); end等待语句只有条件为真时才执行。可以看到第0时刻cnt = 0第5时刻cnt = 1以此类推；直到第75时刻 cnt = 15再过10tick 就终止仿真了。总过时常85tick document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"}],"tags":[{"name":"specification","slug":"specification","permalink":"https://www.beenli.cn/tags/specification/"}]},{"title":"单链表翻转","slug":"单链表翻转","date":"2020-03-31T15:51:58.000Z","updated":"2020-08-05T10:20:10.325Z","comments":true,"path":"posts/39c22857/","link":"","permalink":"https://www.beenli.cn/posts/39c22857/","excerpt":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }","text":"单链表翻转解法一、拆卸+拼接struct ListNode *reverseList(struct ListNode* head){ struct ListNOde *newHead = NUll; struct ListNode *node = NULL; while (head != NULL) { //1. 对之前的链表做头删 node = head; // node始终指向head的前驱 head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; } return newHead; }解法二、三指针法struct ListNode *reverseList(struct ListNode* head) { if (head == NULL) { // 如果为NULL，那么后指针越界。 return NULL; } struct ListNode *p0 = NULL; struct ListNode *p1 = head; struct ListNode *p2 = head-&gt;next; while (p1 != NULL) { p1-&gt;next = p0; p0 = p1; p1 = p2; if (p2 != NULL) { p2 = p2-&gt;next; } } return p0; }参考博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Data Structure","slug":"CS/Data-Structure","permalink":"https://www.beenli.cn/categories/CS/Data-Structure/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"}]},{"title":"iverilog","slug":"开发工具","date":"2020-03-31T11:57:08.000Z","updated":"2020-09-30T12:06:22.074Z","comments":true,"path":"posts/bc753b52/","link":"","permalink":"https://www.beenli.cn/posts/bc753b52/","excerpt":"","text":"vim + iverilog + gtkwave1、What is Icarus VerilogIcarus Verilog is a Verilog simulation and synthesis tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format. For batch simulation, the compiler can generate an intermediate form called vvp assembly. This intermediate form is executed by the vvpcommand. For synthesis, the compiler generates netlists in the desired format.1​ 从官网的描述我们可以看到: 它是一个仿真器和综合器。​ 有趣的是：开发者是一名软件工程师​ a software engineer specializing in device drivers and embedded systems2、Why we choose Icarus Verilog软件非常小，没有图形界面。跑跑小的程序足够了软件扩展性特别好。我现在还没有去探索。详情见软件完全开源。如果有兴趣可以探索是如何把RTL代码转换为netlist的3、How to use it像在quarter II 或者其他IDE一样，你可以在任意一款编辑器上编写Verilog源代码然后在编辑器里一键运行脚本，或者在终端运行。终端主要记住几个命令即可: (后面很会详细说明)iverilog -o filename filename.v // 编译源文件 【-o 指定生成的文件名称】 vvp filename // 仿真testbench gtkwave filename.vcd // 查看仿真的波形图4、Instance case编写源代码(最好用有高亮的编辑器notepad、sublime、VScode、VIM)// 模8计数器。存储为count8.v module count8(clk, rst_n, cnt); input clk, rst_n; output[3:0] cnt; reg[3:0] cnt; always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 4'b0000; else if(cnt[3]) cnt &lt;=4'b0000; else cnt &lt;= cnt + 1'b1; end endmodule编译一下iverilog -o counter8 counter8.v​ ​ 可以看到已经编译成功，生成了count8文件。即上述命令-o后面指定的。如果想查看电路图。好像只能在quarter II里面viewer一下了。还没发现专门从netlist生成电路图的程序。编写测试代码`include \"count8.v\" `timescale 1ns/1ns module count8_tb; // 数据结构声明 reg clk; reg rst_n; wire[3:0] cnt; // 实例化待测试模块 count8 U1(clk, rst_n, cnt); // 测试激励信号 always #50 clk = ~ clk; initial begin clk = 1'b0; rst_n = 1'b0; #20 rst_n = 1'b0; #200 rst_n = 1'b1; end // 输出响应 initial begin wait(cnt == 4'b1000) $display($time,,,\"cnt = %b\", cnt); $dumpfile(\"count8_tb.vcd\"); // 很关键，把仿真的数据存储到文件,待会波形图要用 $dumpvars(0, count8_tb); // 设置要观察的变量 end endmodule编译，仿真，生成波形图iverilog -o count8_tb count8_tb.v &amp; vvp count8_tb &amp; gtkwave count8_tb.vcd注意:由于仿真程序没有设定停止时间。程序会一直执行。如果你想自动停止（可以在testbench上加上# 500$stop,那么程序仿真500个tick就停止)如果你没有加停止指令。只能手动停止ctrl+c然后你可以打印当前仿真的时间。如果不够你可以继续仿真。如果可以了就finish最后用gtkwave 查看你刚刚仿真生成的count8_tb.vcd文件。如果你喜欢用modelsim也可以。也很简单，只需要建个项目，把你写的源文件放进去编译，仿真一下就可以了。具体教程见references[1] iverilog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"tools","slug":"Digital-IC/tools","permalink":"https://www.beenli.cn/categories/Digital-IC/tools/"}],"tags":[{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"}]}],"categories":[{"name":"Digital IC","slug":"Digital-IC","permalink":"https://www.beenli.cn/categories/Digital-IC/"},{"name":"HDL Bits","slug":"Digital-IC/HDL-Bits","permalink":"https://www.beenli.cn/categories/Digital-IC/HDL-Bits/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://www.beenli.cn/categories/RISC-V/"},{"name":"spec","slug":"RISC-V/spec","permalink":"https://www.beenli.cn/categories/RISC-V/spec/"},{"name":"verilog","slug":"Digital-IC/verilog","permalink":"https://www.beenli.cn/categories/Digital-IC/verilog/"},{"name":"CS","slug":"CS","permalink":"https://www.beenli.cn/categories/CS/"},{"name":"Computer Organization & Design","slug":"CS/Computer-Organization-Design","permalink":"https://www.beenli.cn/categories/CS/Computer-Organization-Design/"},{"name":"digital electronic technique","slug":"Digital-IC/digital-electronic-technique","permalink":"https://www.beenli.cn/categories/Digital-IC/digital-electronic-technique/"},{"name":"environment","slug":"RISC-V/environment","permalink":"https://www.beenli.cn/categories/RISC-V/environment/"},{"name":"Software","slug":"Software","permalink":"https://www.beenli.cn/categories/Software/"},{"name":"jupyter","slug":"Software/jupyter","permalink":"https://www.beenli.cn/categories/Software/jupyter/"},{"name":"Git","slug":"Software/Git","permalink":"https://www.beenli.cn/categories/Software/Git/"},{"name":"Data Structure","slug":"CS/Data-Structure","permalink":"https://www.beenli.cn/categories/CS/Data-Structure/"},{"name":"Computer Network","slug":"CS/Computer-Network","permalink":"https://www.beenli.cn/categories/CS/Computer-Network/"},{"name":"OS","slug":"CS/OS","permalink":"https://www.beenli.cn/categories/CS/OS/"},{"name":"Linux","slug":"Linux","permalink":"https://www.beenli.cn/categories/Linux/"},{"name":"VIM","slug":"Software/VIM","permalink":"https://www.beenli.cn/categories/Software/VIM/"},{"name":"tools","slug":"Digital-IC/tools","permalink":"https://www.beenli.cn/categories/Digital-IC/tools/"}],"tags":[{"name":"circuits","slug":"circuits","permalink":"https://www.beenli.cn/tags/circuits/"},{"name":"specification","slug":"specification","permalink":"https://www.beenli.cn/tags/specification/"},{"name":"processor","slug":"processor","permalink":"https://www.beenli.cn/tags/processor/"},{"name":"toolkits","slug":"toolkits","permalink":"https://www.beenli.cn/tags/toolkits/"},{"name":"git","slug":"git","permalink":"https://www.beenli.cn/tags/git/"},{"name":"C","slug":"C","permalink":"https://www.beenli.cn/tags/C/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.beenli.cn/tags/Hexo/"},{"name":"protocols","slug":"protocols","permalink":"https://www.beenli.cn/tags/protocols/"},{"name":"online course","slug":"online-course","permalink":"https://www.beenli.cn/tags/online-course/"}]}